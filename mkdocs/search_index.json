{
    "docs": [
        {
            "location": "/", 
            "text": "MATRIX Ecosystem Overview\n\n\nObjective: Hardware shouldn't be hard\n\nThe MATRIX Ecosystem was created to make powerful hardware projects very approachable for software developers. The pillars of MATRIX, computer vision, hardware interfaces, distributed internet communication, and data-driven end-user clients, are all programming disciplines which require years for an individual to master, or for a team to build a solution around.\n\n\n\n\nSupport \n Resources\n\n\nFeel free to visit our communities and projects for any suggestions and/or questions you may have!\n\n\n Post questions or comments on \ncommunity.matrix.one\n.\n\n\n\n \nSubmit documentation issues or improvements to the \nMATRIX Documentation Repository\n.\n\n\n\n Check out our Hackster projects and guides on our \nHackster Page\n.\n\n\n\n Follow our live streams and tutorial videos on \nYouTube\n.\n\n\n\n View blog posts \n&\n project guides on our \nelement14 page\n.\n\n\n\n \nAlert issues on our \nGitHub\n under the corresponding repository.\n\n\n\n\n\nProgramming Layers\n\n\nThe MATRIX platform adds powerful capabilities to your Raspberry Pi, depending on your background and the kind of application you want to write, you may need to decide on which layer best fits your need. The documentation is organized according to these layers:\n\n\nMATRIX Lite\n\n\n\nLanguages:\n JavaScript, Python, Go, \n Ruby\n\n\nA straightforward library that's aimed at users of all skill levels. This layer is an abstraction around MATRIX HAL and allows you to program your MATRIX Device with as little as one line of code.\n\n\nRead more about MATRIX Lite\n\n\nMATRIX HAL\n\n\n\nLanguage:\n C++\n\n\nInteracts with the kernel modules by using C++ drivers, enabling it to access available sensors and components on your device.\n\n\nRead more about MATRIX HAL\n\n\nMATRIX Core\n\n\n\nLanguages:\n Over 40 (Examples in JavaScript \n Python)\n\n\nAbstraction layer for \nMATRIX HAL\n. Hosts a ZeroMQ + Protobuf communication layer which makes device information accessible via high-level interfaces. Supports multiple different languages through Protocol Buffers: C++, Python, Ruby, PHP, Java, etc.\n\n\nRead more about MATRIX Core\n\n\n\n\nDevices\n\n\n\n\nEach programming layer in the MATRIX platform is compatible with each MATRIX product, excluding specific components on the boards.\n\n\n\n\nMATRIX Creator\n\n\n\n\n\n\nA fully-featured development board for the Raspberry Pi with various sensors and communication protocols such as a 3D Gyroscope, Accelerometer, an 8 Microphone Array, zigbee, Z-Wave, and more!\n\n\nRead more about the MATRIX Creator\n\n\nMATRIX Voice\n\n\n\n\n\n\nA voice and audio focused development board with an 8 microphone array that enables you to create your own audio driven applications or use voice assistants such as \n\nAmazon Alexa\n, \n\nGoogle Assistant\n, \nPocketSphinx, etc.\n\n\nRead more about the MATRIX Voice", 
            "title": "Overview"
        }, 
        {
            "location": "/#matrix-ecosystem-overview", 
            "text": "", 
            "title": "MATRIX Ecosystem Overview"
        }, 
        {
            "location": "/#support-resources", 
            "text": "Feel free to visit our communities and projects for any suggestions and/or questions you may have!   Post questions or comments on  community.matrix.one .   \nSubmit documentation issues or improvements to the  MATRIX Documentation Repository .   Check out our Hackster projects and guides on our  Hackster Page .   Follow our live streams and tutorial videos on  YouTube .   View blog posts  &  project guides on our  element14 page .   \nAlert issues on our  GitHub  under the corresponding repository.", 
            "title": "Support &amp; Resources"
        }, 
        {
            "location": "/#programming-layers", 
            "text": "The MATRIX platform adds powerful capabilities to your Raspberry Pi, depending on your background and the kind of application you want to write, you may need to decide on which layer best fits your need. The documentation is organized according to these layers:", 
            "title": "Programming Layers"
        }, 
        {
            "location": "/#devices", 
            "text": "Each programming layer in the MATRIX platform is compatible with each MATRIX product, excluding specific components on the boards.", 
            "title": "Devices"
        }, 
        {
            "location": "/help/", 
            "text": "Support \n Resources\n\n\nFeel free to visit our communities and projects for any suggestions and/or questions you may have!\n\n\n Post questions or comments on \ncommunity.matrix.one\n.\n\n\n\n \nSubmit documentation issues or improvements to the \nMATRIX Documentation Repository\n.\n\n\n\n Check out our Hackster projects and guides on our \nHackster Page\n.\n\n\n\n Follow our live streams and tutorial videos on \nYouTube\n.\n\n\n\n View blog posts \n&\n project guides on our \nelement14 page\n.\n\n\n\n \nAlert issues on our \nGitHub\n under the corresponding repository.", 
            "title": "Support"
        }, 
        {
            "location": "/help/#support-resources", 
            "text": "Feel free to visit our communities and projects for any suggestions and/or questions you may have!   Post questions or comments on  community.matrix.one .   \nSubmit documentation issues or improvements to the  MATRIX Documentation Repository .   Check out our Hackster projects and guides on our  Hackster Page .   Follow our live streams and tutorial videos on  YouTube .   View blog posts  &  project guides on our  element14 page .   \nAlert issues on our  GitHub  under the corresponding repository.", 
            "title": "Support &amp; Resources"
        }, 
        {
            "location": "/matrix-creator/overview/", 
            "text": "MATRIX Creator\n\n\n\n\nThe MATRIX Creator is a fully-featured development board, including sensors, wireless communications, and an FPGA. MATRIX Creator was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) app creation.\n\n\nOverview\n\n\nDevice Setup\n\nHow to get started with your MATRIX Creator\n\n\nResources\n\n\n\nView and download helpful information about the MATRIX Creator\n\n\nTroubleshooting\n\n\n\nLook at common debugging solutions and test the hardware on your MATRIX Creator", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-creator/overview/#matrix-creator", 
            "text": "The MATRIX Creator is a fully-featured development board, including sensors, wireless communications, and an FPGA. MATRIX Creator was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) app creation.", 
            "title": "MATRIX Creator"
        }, 
        {
            "location": "/matrix-creator/overview/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-creator/device-setup/", 
            "text": "Hardware Prerequisites\n\n\n\n\nMATRIX Creator\n\n\nCompatible Raspberry Pi:\n\n\n3 Model B+\n\n\n3 Model B\n\n\n2 Model B\n\n\n1 Model B+\n\n\nZero\n\n\nZero W\n\n\n\n\n\n\n5V 2.5A Micro USB Power Supply\n\n\nMicroSD Card With \nRaspbian Stretch\n Lite or Desktop Installed\n\n\nWe recommend using \nEtcher.io\n for easy flashing\n\n\n\n\n\n\n\n\nDevice Installation\n\n\n\n\nSteps\n\n\n\n\nInsert flashed microSD card into Raspberry Pi\n\n\nAttach MATRIX Creator onto Raspberry Pi GPIO pins\n\n\nPower Raspberry Pi with micro USB power supply\n\n\n\n\nChoosing A Programming Environment\n\n\nAfter your MATRIX Creator is setup, visit \nEcosystem Overview\n for information about the three programming environments available to you in the MATRIX platform.", 
            "title": "Device Setup"
        }, 
        {
            "location": "/matrix-creator/device-setup/#hardware-prerequisites", 
            "text": "MATRIX Creator  Compatible Raspberry Pi:  3 Model B+  3 Model B  2 Model B  1 Model B+  Zero  Zero W    5V 2.5A Micro USB Power Supply  MicroSD Card With  Raspbian Stretch  Lite or Desktop Installed  We recommend using  Etcher.io  for easy flashing", 
            "title": "Hardware Prerequisites"
        }, 
        {
            "location": "/matrix-creator/device-setup/#device-installation", 
            "text": "", 
            "title": "Device Installation"
        }, 
        {
            "location": "/matrix-creator/device-setup/#choosing-a-programming-environment", 
            "text": "After your MATRIX Creator is setup, visit  Ecosystem Overview  for information about the three programming environments available to you in the MATRIX platform.", 
            "title": "Choosing A Programming Environment"
        }, 
        {
            "location": "/matrix-creator/resources/overview/", 
            "text": "Resources\n\n\nPinout\n\n\n\nLists and labels of the MATRIX Creator's Pinouts\n\n\nMicrophones\n\n\n\nMicrophone drivers, sample rate, and board position\n\n\nIR\n\n\n\nGeneral information on the infrared receiver and transmitters.\n\n\nReference Models\n\n\n\nDownload or view the Matrix Creator's 3D models and case\n\n\nSystem Architecture\n\n\n\nView a technical diagram of the MATRIX Creator architecture.\n\n\nTechnical Datasheets\n\n\n\nPDFs of MATRIX Creator Components\n\n\nMCU\n\n\n\nMicrocontroller source and flashing guide\n\n\nFPGA\n\n\n\nFPGA source and flashing guide", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-creator/resources/overview/#resources", 
            "text": "", 
            "title": "Resources"
        }, 
        {
            "location": "/matrix-creator/resources/pinout/", 
            "text": "Expansion GPIO\n\n\n\n\n\n\nRev 1 Boards do not include pin 25 \n 26. Rev 2 boards can be identified if there is a QR code sticker on the MATRIX Creator's face.\n\n\n\n\nRaspberry Pi GPIO\n\n\n\n\nGPIO Locations", 
            "title": "Pinout"
        }, 
        {
            "location": "/matrix-creator/resources/pinout/#expansion-gpio", 
            "text": "Rev 1 Boards do not include pin 25   26. Rev 2 boards can be identified if there is a QR code sticker on the MATRIX Creator's face.", 
            "title": "Expansion GPIO"
        }, 
        {
            "location": "/matrix-creator/resources/pinout/#raspberry-pi-gpio", 
            "text": "", 
            "title": "Raspberry Pi GPIO"
        }, 
        {
            "location": "/matrix-creator/resources/pinout/#gpio-locations", 
            "text": "", 
            "title": "GPIO Locations"
        }, 
        {
            "location": "/matrix-creator/resources/ir/", 
            "text": "IR on MATRIX Creator\n\n\n\n\nOverview\n\n\nThere are two IR transmitters and one IR receiver on the MATRIX Creator. Both components are wired to the \nPi's GPIO pins\n for you to directly call.\n\n\n\n\nIR Transmitters\n\n\nRaspberry Pi\n \nGPIO BCM Pin: 13\n\nBoth transmitters are located on the front \n back of the MATRIX Creator. They are both connected to the same pin.\n\n\n\n\n\n\nIR Receiver\n\n\nRaspberry Pi\n \nGPIO BCM Pin: 16\n\nThe receiver is located on the front of the MATRIX Creator.\n\n\n\n\nUsage\n\n\nThe IR components on the MATRIX Creator should work the same as if they were directly placed on a Raspberry Pi. This means that libraries which utilize IR components can work with the MATRIX Creator. Below are a few we've seen work.\n\n\n\n\npigpio\n\n\nThe \n\npigpio library\n \nhas an example that can record and send IR signals you want to record. However, the implementation will cause issues with using audio recording/playback.\n\n\nExample Repositories:\n\n\n\n\nIR Test\n: Simple record \n playback of an IR signal.\n\n\nTV Remote Website\n: Website that can command the MATRIX Creator to send IR signals. \n\n\n\n\n\n\n\n\nLIRC\n\n\nThe \n\nLIRC Package\n \nallows for receiving and sending IR signals with common IR remotes. Unlike pigpio, this package seems to play well with audio recording/playback.\n\n\n\n\nKernel 4.19 workaround\n\n\nTo utilize LIRC on the latest Kernel modules for Raspbian Stretch, A patch needs to be applied for the package. \n\nThese community contributed instructions\n \ncan help solve this issue.", 
            "title": "IR"
        }, 
        {
            "location": "/matrix-creator/resources/ir/#ir-on-matrix-creator", 
            "text": "", 
            "title": "IR on MATRIX Creator"
        }, 
        {
            "location": "/matrix-creator/resources/ir/#overview", 
            "text": "There are two IR transmitters and one IR receiver on the MATRIX Creator. Both components are wired to the  Pi's GPIO pins  for you to directly call.   IR Transmitters  Raspberry Pi   GPIO BCM Pin: 13 \nBoth transmitters are located on the front   back of the MATRIX Creator. They are both connected to the same pin.    IR Receiver  Raspberry Pi   GPIO BCM Pin: 16 \nThe receiver is located on the front of the MATRIX Creator.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-creator/resources/ir/#usage", 
            "text": "The IR components on the MATRIX Creator should work the same as if they were directly placed on a Raspberry Pi. This means that libraries which utilize IR components can work with the MATRIX Creator. Below are a few we've seen work.   pigpio  The  pigpio library  \nhas an example that can record and send IR signals you want to record. However, the implementation will cause issues with using audio recording/playback.  Example Repositories:   IR Test : Simple record   playback of an IR signal.  TV Remote Website : Website that can command the MATRIX Creator to send IR signals.      LIRC  The  LIRC Package  \nallows for receiving and sending IR signals with common IR remotes. Unlike pigpio, this package seems to play well with audio recording/playback.   Kernel 4.19 workaround  To utilize LIRC on the latest Kernel modules for Raspbian Stretch, A patch needs to be applied for the package.  These community contributed instructions  \ncan help solve this issue.", 
            "title": "Usage"
        }, 
        {
            "location": "/matrix-creator/resources/microphone/", 
            "text": "Microphone Array on MATRIX Creator\n\n\n\n\nUsage\n\n\nDriver installation\n\nFollow the instructions below for allowing your MATRIX Creator to register as a microphone for your Raspberry Pi.\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\nsudo apt-get update\nsudo apt-get upgrade\n\n\nA reboot will be required after following the steps above.\n\nsudo reboot\n\n\nThe next commands will install the MATRIX kernel modules, overriding the stock Raspbian kernel.\n\nsudo apt install matrixio-kernel-modules\n\n\nA second reboot will be required.\n\nsudo reboot\n\n\n\nCheck If Everything Works\n\nYour Raspberry Pi should now treat your MATRIX Creator as a regular microphone. You can test this by using the following commands to record and play a 5 second long audio file on your Raspberry Pi.\n\n\n\n\nBe sure to have something connected to the Raspberry Pi's audio output.\n\narecord recording.wav -f S16_LE -r \n16000\n -d \n5\n\naplay recording.wav\n\n\n\n\n\nALSA Configuration\n\n\n\nThe microphones can be grabbed using ALSA. Multiple libraries that support ALSA use these configurations to read microphone data with ALSA.\n\n\nDevice name - \nhw:2,0\n\n\nRates(Hz) - \n8000\n \n12000\n \n16000\n \n22050\n \n24000\n \n32000\n \n44100\n \n48000\n\n\nChannels for each microphone - \n1\n \n2\n \n3\n \n4\n \n5\n \n6\n \n7\n \n8\n\n\nAudio Specifications\n\n\nSample Rate:\n 8 to 96 kHz\n\n\nBit Depth:\n Signed 16 bit\n\n\nPosition [x,y] of each mic in the array (mm)\n\n\n\n\n\n\n\n\n\nMic\n\n\nX\n\n\nY\n\n\n\n\n\n\n\n\n\n\nM1\n\n\n20.0908795\n\n\n-48.5036755\n\n\n\n\n\n\nM2\n\n\n-20.0908795\n\n\n-48.5036755\n\n\n\n\n\n\nM3\n\n\n-48.5036755\n\n\n-20.0908795\n\n\n\n\n\n\nM4\n\n\n-48.5036755\n\n\n20.0908795\n\n\n\n\n\n\nM5\n\n\n-20.0908795\n\n\n48.5036755\n\n\n\n\n\n\nM6\n\n\n20.0908795\n\n\n48.5036755\n\n\n\n\n\n\nM7\n\n\n48.5036755\n\n\n20.0908795\n\n\n\n\n\n\nM8\n\n\n48.5036755\n\n\n-20.0908795\n\n\n\n\n\n\n\n\nConnection to the FPGA\n\n\n\nYou can check the physical connection between the FPGA and other components in \n\ncreator.ucf\n\n\n\n\n\n\n\n\nMic\n\n\nFPGA pin\n\n\nPDM_Data\n\n\n\n\n\n\n\n\n\n\nM1\n\n\nP45\n\n\npdm_data\n0\n\n\n\n\n\n\nM2\n\n\nP46\n\n\npdm_data\n1\n\n\n\n\n\n\nM3\n\n\nP47\n\n\npdm_data\n2\n\n\n\n\n\n\nM4\n\n\nP58\n\n\npdm_data\n3\n\n\n\n\n\n\nM5\n\n\nP59\n\n\npdm_data\n4\n\n\n\n\n\n\nM6\n\n\nP64\n\n\npdm_data\n5\n\n\n\n\n\n\nM7\n\n\nP65\n\n\npdm_data\n6\n\n\n\n\n\n\nM8\n\n\nP44\n\n\npdm_data\n7\n\n\n\n\n\n\nCLK\n\n\nP47\n\n\npdm_clk", 
            "title": "Microphones"
        }, 
        {
            "location": "/matrix-creator/resources/microphone/#microphone-array-on-matrix-creator", 
            "text": "", 
            "title": "Microphone Array on MATRIX Creator"
        }, 
        {
            "location": "/matrix-creator/resources/microphone/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/matrix-creator/resources/microphone/#audio-specifications", 
            "text": "Sample Rate:  8 to 96 kHz  Bit Depth:  Signed 16 bit", 
            "title": "Audio Specifications"
        }, 
        {
            "location": "/matrix-creator/resources/reference-models/", 
            "text": "Board Model\n\n\nTop View\n\n\n\n\nBottom View\n\n\n\n\n\nModel Download\n\n\n\nAccess to 3D models \nhere\n. Also, you can take a look online \n\nhere\n.\n\n\nCase Model\n\n\nPrinted Case\n\n\n\n\nModel Download\n\n\n\nAccess to 3D case models \nhere\n.", 
            "title": "Reference Models"
        }, 
        {
            "location": "/matrix-creator/resources/reference-models/#board-model", 
            "text": "", 
            "title": "Board Model"
        }, 
        {
            "location": "/matrix-creator/resources/reference-models/#case-model", 
            "text": "", 
            "title": "Case Model"
        }, 
        {
            "location": "/matrix-creator/resources/system-architecture/", 
            "text": "System Architecture", 
            "title": "System Architecture"
        }, 
        {
            "location": "/matrix-creator/resources/system-architecture/#system-architecture", 
            "text": "", 
            "title": "System Architecture"
        }, 
        {
            "location": "/matrix-creator/resources/technical-datasheets/", 
            "text": "Datasheets:\n\n\n\n\n\n\nAtmel 32 bits Cortex M3 SAM3S2\n\n\n\n\n\n\nXilinx Spartan 6S XC6SLX4 FPGA\n\n\n\n\n\n\n8 MEMS audio sensor digital microphones\n\n\n\n\n\n\nST LSM9DS1 3D accelerometer, 3D gyroscope, 3D magnetometer\n\n\n\n\n\n\nST HTS221 digital sensor for relative humidity and temperature\n\n\n\n\n\n\nNXP PN512 NFC reader\n\n\n\n\n\n\nNXP MPL3115A2 Altimeter\n\n\n\n\n\n\nVishay VEML6070 UV Light Sensor\n\n\n\n\n\n\nVishay INFRARED Receptor\n\n\n\n\n\n\nRGBW everloop LED", 
            "title": "Technical Datasheets"
        }, 
        {
            "location": "/matrix-creator/resources/technical-datasheets/#datasheets", 
            "text": "Atmel 32 bits Cortex M3 SAM3S2    Xilinx Spartan 6S XC6SLX4 FPGA    8 MEMS audio sensor digital microphones    ST LSM9DS1 3D accelerometer, 3D gyroscope, 3D magnetometer    ST HTS221 digital sensor for relative humidity and temperature    NXP PN512 NFC reader    NXP MPL3115A2 Altimeter    Vishay VEML6070 UV Light Sensor    Vishay INFRARED Receptor    RGBW everloop LED", 
            "title": "Datasheets:"
        }, 
        {
            "location": "/matrix-creator/resources/mcu/", 
            "text": "Microprocessor (MCU)\n\n\n\nFlashing Guide\n\n\n\n\n\n\u26a0\ufe0fModifying MCU source may have unintended consequences\u26a0\ufe0f\n\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe MCU handles:\n\n\n\n\nInterfacing with and processing sensor data\n\n\nCalculating Yaw, Pitch, Roll\n\n\n\n\nMCU Source\n\n\nMCU source code is located \nhere\n.\n\n\nMCU Flashing\n\n\nBelow is a guide on how to flash modified source onto the Atmel SAM3S MCU for the MATRIX Creator.\n\n\nFor this guide, the source code will be modified to disable the blue blinking led (labeled D48 on board), which is controlled by the MCU.\n\n\n\n\nWe first need to install a few prerequisites.\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the required packages.\n\n\nsudo apt-get install matrixio-creator-init git gcc-arm-none-eabi\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nThen, clone the MCU source repo.\n\n\ncd\n ~/\ngit clone https://github.com/matrix-io/matrix-creator-mcu.git\n\n\n\n\nEdit the file \nmatrix-creator-mcu/creator/main.cpp\n, commenting out line 82. This change disables the blue blinking led.\n\n\n\n\nThen build the modified MCU source.\n\n\ncd\n ~/\n\ncd\n matrix-creator-mcu/creator/\nmake\n\n\n\n\nBackup the stock \nch.bin\n file.\n\n\nsudo mv /usr/share/matrixlabs/matrixio-devices/blob/ch.bin /usr/share/matrixlabs/matrixio-devices/blob/ch_stock.bin\n\n\n\n\nCopy your built \nch.bin\n file to the blob folder.\n\n\ncd\n ~/\n\ncd\n matrix-creator-mcu/creator/\nsudo cp ./build/ch.bin /usr/share/matrixlabs/matrixio-devices/blob/ch.bin\n\n\n\n\nNow you can flash the MCU.\n\n\ncd\n /usr/share/matrixlabs/matrixio-devices/\nsudo openocd -f cfg/sam3s_rpi_sysfs.cfg\n\n\n\n\nThe last part of the \nopenocd\n flashing command output should be the following (may vary due to user-provided file).\n\n\nflash \nat91sam3\n found at 0x00400000\nwrote \n36636\n bytes from file blob/ch.bin to flash bank \n0\n at offset 0x00000000 in \n4\n.665386s \n(\n7\n.669 KiB/s\n)\n\nInfo : JTAG tap: em358.cpu tap/device found: 0x3ba00477 \n(\nmfg: 0x23b \n(\nARM Ltd.\n)\n, part: 0xba00, ver: 0x3\n)\n\nInfo : JTAG tap: em357.bs tap/device found: 0x069aa62b \n(\nmfg: 0x315 \n(\nEmber Corporation\n)\n, part: 0x69aa, ver: 0x0\n)\nInfo : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 \n(\nmfg: 0x049 \n(\nXilinx\n)\n, part: 0x4000, ver: 0x2\n)\n\nInfo : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 \n(\nmfg: 0x23b \n(\nARM Ltd.\n)\n, part: 0xba00, ver: 0x4\n)\n\nWarn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support.\nshutdown \ncommand\n invoked\n\n\n\n\nIn order to maintain compatibility with the \nmatrixio-creator-init\n package, you'll need to backup the original \nmcu_firmware.version\n file, and create your own.\n\n\ncd\n /usr/share/matrixlabs/matrixio-devices/\nsudo mv /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version /usr/share/matrixlabs/matrixio-devices/mcu_firmware_stock.version\n\n(\n./firmware_info \n|\n grep MCU\n)\n \n|\n sudo tee mcu_firmware.version\n\n\n\n\nUpdating the \nmatrixio-creator-init\n package will cause the stock FPGA bitstream to be flashed upon next boot.\n\n\nYou can stop \nsudo apt-get upgrade\n from automatically updating the \nmatrixio-creator-init\n package with the following command.\n\n\nsudo apt-mark hold matrixio-creator-init\n\n\n\n\nPower off your device.\n\n\nsudo poweroff\n\n\n\n\nWait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.\n\n\nPlug the power cable back into your Raspberry Pi.\n\n\nRestore Original Firmware\n\n\nTo restore the original firmware, restore the stock \nch.bin\n file in the blob folder.\n\n\nsudo rm /usr/share/matrixlabs/matrixio-devices/blob/ch.bin\nsudo cp /usr/share/matrixlabs/matrixio-devices/blob/ch_stock.bin /usr/share/matrixlabs/matrixio-devices/blob/ch.bin\n\n\n\n\nNow you can flash the MCU.\n\n\ncd\n /usr/share/matrixlabs/matrixio-devices/\nsudo openocd -f cfg/sam3s_rpi_sysfs.cfg\n\n\n\n\nThe last part of the \nopenocd\n flashing command output should be the following.\n\n\nflash \nat91sam3\n found at 0x00400000\nwrote \n36636\n bytes from file blob/ch.bin to flash bank \n0\n at offset 0x00000000 in \n4\n.665386s \n(\n7\n.669 KiB/s\n)\n\nInfo : JTAG tap: em358.cpu tap/device found: 0x3ba00477 \n(\nmfg: 0x23b \n(\nARM Ltd.\n)\n, part: 0xba00, ver: 0x3\n)\n\nInfo : JTAG tap: em357.bs tap/device found: 0x069aa62b \n(\nmfg: 0x315 \n(\nEmber Corporation\n)\n, part: 0x69aa, ver: 0x0\n)\nInfo : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 \n(\nmfg: 0x049 \n(\nXilinx\n)\n, part: 0x4000, ver: 0x2\n)\n\nInfo : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 \n(\nmfg: 0x23b \n(\nARM Ltd.\n)\n, part: 0xba00, ver: 0x4\n)\n\nWarn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support.\nshutdown \ncommand\n invoked\n\n\n\n\nRestore the stock \nmcu_firmware.version\n file.\n\n\nsudo rm /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version\nsudo cp /usr/share/matrixlabs/matrixio-devices/mcu_firmware_stock.version /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version\n\n\n\n\nAllow \nsudo apt-get upgrade\n to update the \nmatrixio-creator-init\n package.\n\n\nsudo apt-mark unhold matrixio-creator-init\n\n\n\n\nPower off your device.\n\n\nsudo poweroff\n\n\n\n\nWait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.\n\n\nPlug the power cable back into your Raspberry Pi.", 
            "title": "MCU"
        }, 
        {
            "location": "/matrix-creator/resources/mcu/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-creator/resources/mcu/#overview", 
            "text": "The MCU handles:   Interfacing with and processing sensor data  Calculating Yaw, Pitch, Roll", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-creator/resources/mcu/#mcu-source", 
            "text": "MCU source code is located  here .", 
            "title": "MCU Source"
        }, 
        {
            "location": "/matrix-creator/resources/mcu/#mcu-flashing", 
            "text": "Below is a guide on how to flash modified source onto the Atmel SAM3S MCU for the MATRIX Creator.  For this guide, the source code will be modified to disable the blue blinking led (labeled D48 on board), which is controlled by the MCU.   We first need to install a few prerequisites.  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the required packages.  sudo apt-get install matrixio-creator-init git gcc-arm-none-eabi  Reboot your device.  sudo reboot  Then, clone the MCU source repo.  cd  ~/\ngit clone https://github.com/matrix-io/matrix-creator-mcu.git  Edit the file  matrix-creator-mcu/creator/main.cpp , commenting out line 82. This change disables the blue blinking led.   Then build the modified MCU source.  cd  ~/ cd  matrix-creator-mcu/creator/\nmake  Backup the stock  ch.bin  file.  sudo mv /usr/share/matrixlabs/matrixio-devices/blob/ch.bin /usr/share/matrixlabs/matrixio-devices/blob/ch_stock.bin  Copy your built  ch.bin  file to the blob folder.  cd  ~/ cd  matrix-creator-mcu/creator/\nsudo cp ./build/ch.bin /usr/share/matrixlabs/matrixio-devices/blob/ch.bin  Now you can flash the MCU.  cd  /usr/share/matrixlabs/matrixio-devices/\nsudo openocd -f cfg/sam3s_rpi_sysfs.cfg  The last part of the  openocd  flashing command output should be the following (may vary due to user-provided file).  flash  at91sam3  found at 0x00400000\nwrote  36636  bytes from file blob/ch.bin to flash bank  0  at offset 0x00000000 in  4 .665386s  ( 7 .669 KiB/s ) \nInfo : JTAG tap: em358.cpu tap/device found: 0x3ba00477  ( mfg: 0x23b  ( ARM Ltd. ) , part: 0xba00, ver: 0x3 ) \nInfo : JTAG tap: em357.bs tap/device found: 0x069aa62b  ( mfg: 0x315  ( Ember Corporation ) , part: 0x69aa, ver: 0x0 ) Info : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093  ( mfg: 0x049  ( Xilinx ) , part: 0x4000, ver: 0x2 ) \nInfo : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477  ( mfg: 0x23b  ( ARM Ltd. ) , part: 0xba00, ver: 0x4 ) \nWarn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support.\nshutdown  command  invoked  In order to maintain compatibility with the  matrixio-creator-init  package, you'll need to backup the original  mcu_firmware.version  file, and create your own.  cd  /usr/share/matrixlabs/matrixio-devices/\nsudo mv /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version /usr/share/matrixlabs/matrixio-devices/mcu_firmware_stock.version ( ./firmware_info  |  grep MCU )   |  sudo tee mcu_firmware.version  Updating the  matrixio-creator-init  package will cause the stock FPGA bitstream to be flashed upon next boot.  You can stop  sudo apt-get upgrade  from automatically updating the  matrixio-creator-init  package with the following command.  sudo apt-mark hold matrixio-creator-init  Power off your device.  sudo poweroff  Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.  Plug the power cable back into your Raspberry Pi.", 
            "title": "MCU Flashing"
        }, 
        {
            "location": "/matrix-creator/resources/mcu/#restore-original-firmware", 
            "text": "To restore the original firmware, restore the stock  ch.bin  file in the blob folder.  sudo rm /usr/share/matrixlabs/matrixio-devices/blob/ch.bin\nsudo cp /usr/share/matrixlabs/matrixio-devices/blob/ch_stock.bin /usr/share/matrixlabs/matrixio-devices/blob/ch.bin  Now you can flash the MCU.  cd  /usr/share/matrixlabs/matrixio-devices/\nsudo openocd -f cfg/sam3s_rpi_sysfs.cfg  The last part of the  openocd  flashing command output should be the following.  flash  at91sam3  found at 0x00400000\nwrote  36636  bytes from file blob/ch.bin to flash bank  0  at offset 0x00000000 in  4 .665386s  ( 7 .669 KiB/s ) \nInfo : JTAG tap: em358.cpu tap/device found: 0x3ba00477  ( mfg: 0x23b  ( ARM Ltd. ) , part: 0xba00, ver: 0x3 ) \nInfo : JTAG tap: em357.bs tap/device found: 0x069aa62b  ( mfg: 0x315  ( Ember Corporation ) , part: 0x69aa, ver: 0x0 ) Info : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093  ( mfg: 0x049  ( Xilinx ) , part: 0x4000, ver: 0x2 ) \nInfo : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477  ( mfg: 0x23b  ( ARM Ltd. ) , part: 0xba00, ver: 0x4 ) \nWarn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support.\nshutdown  command  invoked  Restore the stock  mcu_firmware.version  file.  sudo rm /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version\nsudo cp /usr/share/matrixlabs/matrixio-devices/mcu_firmware_stock.version /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version  Allow  sudo apt-get upgrade  to update the  matrixio-creator-init  package.  sudo apt-mark unhold matrixio-creator-init  Power off your device.  sudo poweroff  Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.  Plug the power cable back into your Raspberry Pi.", 
            "title": "Restore Original Firmware"
        }, 
        {
            "location": "/matrix-creator/resources/fpga/", 
            "text": "FPGA\n\n\n\nFlashing Guide\n\n\n\n\n\n\u26a0\ufe0fModifying FPGA source may have unintended consequences\u26a0\ufe0f\n\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe FPGA handles:\n\n\n\n\nGPIO output\n\n\nUART for Zigbee and Z-Wave\n\n\nConnections between board components\n\n\nMicrophone processing (not provided in source code)\n\n\n\n\nFPGA Source\n\n\n\n\n\u26a0\ufe0fFPGA source does not contain audio processing code\u26a0\ufe0f\n\n\n\n\nFPGA source code is located \nhere\n.\n\n\nFPGA Flashing\n\n\nBelow is a guide on how to flash a premade user-provided FPGA bitstream onto the Xilinx Spartan-6 FPGA for the MATRIX Creator.\n\n\nWe first need to install a few prerequisites.\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the required packages.\n\n\nsudo apt-get install matrixio-creator-init\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nBackup the stock \nsystem_creator.bit\n file.\n\n\nsudo mv /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit /usr/share/matrixlabs/matrixio-devices/blob/system_creator_stock.bit\n\n\n\n\nCopy your built \nsystem_creator.bit\n FPGA bitstream file to the blob folder.\n\n\nsudo cp /path/to/your/file /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit\n\n\n\n\nNow you can flash the FPGA.\n\n\nReset the FPGA.\n\n\necho\n \n18\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio18/direction\n\necho\n \n1\n \n /sys/class/gpio/gpio18/value\n\necho\n \n0\n \n /sys/class/gpio/gpio18/value\n\necho\n \n1\n \n /sys/class/gpio/gpio18/value\n\n\n\n\nFlash the FPGA.\n\n\ncd\n /usr/share/matrixlabs/matrixio-devices/\nxc3sprog -c matrix_creator blob/system_creator.bit -p \n1\n\n\n\n\n\nYou should receive the following (may vary due to user-provided file).\n\n\nXC3SPROG \n(\nc\n)\n \n2004\n-2011 xc3sprog project \n$Rev\n: \n774\n $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id\n=\n170565\n\nCheck Sourceforge \nfor\n updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0x99a9bca3325faafd\n\n\n\n\nReset the FPGA.\n\n\necho\n \n18\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio18/direction\n\necho\n \n1\n \n /sys/class/gpio/gpio18/value\n\necho\n \n0\n \n /sys/class/gpio/gpio18/value\n\necho\n \n1\n \n /sys/class/gpio/gpio18/value\n\n\n\n\nUpdating the \nmatrixio-creator-init\n package will cause the stock FPGA bitstream to be flashed upon next boot.\n\n\nYou can stop \nsudo apt-get upgrade\n from automatically updating the \nmatrixio-creator-init\n package with the following command.\n\n\nsudo apt-mark hold matrixio-creator-init\n\n\n\n\nPower off your device.\n\n\nsudo poweroff\n\n\n\n\nWait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.\n\n\nPlug the power cable back into your Raspberry Pi.\n\n\nRestore Original Firmware\n\n\nTo restore the original firmware, restore the stock \nsystem_creator.bit\n file in the blob folder.\n\n\nsudo rm /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit\nsudo cp /usr/share/matrixlabs/matrixio-devices/blob/system_creator_stock.bit /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit\n\n\n\n\nNow you can flash the FPGA.\n\n\nReset the FPGA.\n\n\necho\n \n18\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio18/direction\n\necho\n \n1\n \n /sys/class/gpio/gpio18/value\n\necho\n \n0\n \n /sys/class/gpio/gpio18/value\n\necho\n \n1\n \n /sys/class/gpio/gpio18/value\n\n\n\n\nFlash the FPGA.\n\n\ncd\n /usr/share/matrixlabs/matrixio-devices/\nxc3sprog -c matrix_creator blob/system_creator.bit -p \n1\n\n\n\n\n\nYou should receive the following.\n\n\nXC3SPROG \n(\nc\n)\n \n2004\n-2011 xc3sprog project \n$Rev\n: \n774\n $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id\n=\n170565\n\nCheck Sourceforge \nfor\n updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0x99a9bca3325faafd\n\n\n\n\nReset the FPGA.\n\n\necho\n \n18\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio18/direction\n\necho\n \n1\n \n /sys/class/gpio/gpio18/value\n\necho\n \n0\n \n /sys/class/gpio/gpio18/value\n\necho\n \n1\n \n /sys/class/gpio/gpio18/value\n\n\n\n\nAllow \nsudo apt-get upgrade\n to update the \nmatrixio-creator-init\n package.\n\n\nsudo apt-mark unhold matrixio-creator-init\n\n\n\n\nPower off your device.\n\n\nsudo poweroff\n\n\n\n\nWait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.\n\n\nPlug the power cable back into your Raspberry Pi.", 
            "title": "FPGA"
        }, 
        {
            "location": "/matrix-creator/resources/fpga/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-creator/resources/fpga/#overview", 
            "text": "The FPGA handles:   GPIO output  UART for Zigbee and Z-Wave  Connections between board components  Microphone processing (not provided in source code)", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-creator/resources/fpga/#fpga-source", 
            "text": "\u26a0\ufe0fFPGA source does not contain audio processing code\u26a0\ufe0f   FPGA source code is located  here .", 
            "title": "FPGA Source"
        }, 
        {
            "location": "/matrix-creator/resources/fpga/#fpga-flashing", 
            "text": "Below is a guide on how to flash a premade user-provided FPGA bitstream onto the Xilinx Spartan-6 FPGA for the MATRIX Creator.  We first need to install a few prerequisites.  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the required packages.  sudo apt-get install matrixio-creator-init  Reboot your device.  sudo reboot  Backup the stock  system_creator.bit  file.  sudo mv /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit /usr/share/matrixlabs/matrixio-devices/blob/system_creator_stock.bit  Copy your built  system_creator.bit  FPGA bitstream file to the blob folder.  sudo cp /path/to/your/file /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit  Now you can flash the FPGA.  Reset the FPGA.  echo   18    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio18/direction echo   1    /sys/class/gpio/gpio18/value echo   0    /sys/class/gpio/gpio18/value echo   1    /sys/class/gpio/gpio18/value  Flash the FPGA.  cd  /usr/share/matrixlabs/matrixio-devices/\nxc3sprog -c matrix_creator blob/system_creator.bit -p  1   You should receive the following (may vary due to user-provided file).  XC3SPROG  ( c )   2004 -2011 xc3sprog project  $Rev :  774  $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id = 170565 \nCheck Sourceforge  for  updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0x99a9bca3325faafd  Reset the FPGA.  echo   18    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio18/direction echo   1    /sys/class/gpio/gpio18/value echo   0    /sys/class/gpio/gpio18/value echo   1    /sys/class/gpio/gpio18/value  Updating the  matrixio-creator-init  package will cause the stock FPGA bitstream to be flashed upon next boot.  You can stop  sudo apt-get upgrade  from automatically updating the  matrixio-creator-init  package with the following command.  sudo apt-mark hold matrixio-creator-init  Power off your device.  sudo poweroff  Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.  Plug the power cable back into your Raspberry Pi.", 
            "title": "FPGA Flashing"
        }, 
        {
            "location": "/matrix-creator/resources/fpga/#restore-original-firmware", 
            "text": "To restore the original firmware, restore the stock  system_creator.bit  file in the blob folder.  sudo rm /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit\nsudo cp /usr/share/matrixlabs/matrixio-devices/blob/system_creator_stock.bit /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit  Now you can flash the FPGA.  Reset the FPGA.  echo   18    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio18/direction echo   1    /sys/class/gpio/gpio18/value echo   0    /sys/class/gpio/gpio18/value echo   1    /sys/class/gpio/gpio18/value  Flash the FPGA.  cd  /usr/share/matrixlabs/matrixio-devices/\nxc3sprog -c matrix_creator blob/system_creator.bit -p  1   You should receive the following.  XC3SPROG  ( c )   2004 -2011 xc3sprog project  $Rev :  774  $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id = 170565 \nCheck Sourceforge  for  updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0x99a9bca3325faafd  Reset the FPGA.  echo   18    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio18/direction echo   1    /sys/class/gpio/gpio18/value echo   0    /sys/class/gpio/gpio18/value echo   1    /sys/class/gpio/gpio18/value  Allow  sudo apt-get upgrade  to update the  matrixio-creator-init  package.  sudo apt-mark unhold matrixio-creator-init  Power off your device.  sudo poweroff  Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.  Plug the power cable back into your Raspberry Pi.", 
            "title": "Restore Original Firmware"
        }, 
        {
            "location": "/matrix-creator/troubleshooting/", 
            "text": "Community\n\n\nPlease visit our community support forums at\n\ncommunity.matrix.one\n\n\nReinstall MATRIX Init Package and Reflash FPGA and MCU\n\n\nIf you experience strange behavior, reinstall the MATRIX init package and reflash FPGA and MCU.\n\n\nUninstall the \nmatrixio-creator-init\n package.\n\n\nsudo apt-get --purge remove matrixio-creator-init\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the \nmatrixio-creator-init\n package.\n\n\nsudo apt-get install matrixio-creator-init\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\n\n\nFPGA will be reflashed with stock firmware.\n\n\n\n\nNow you can flash the FPGA.\n\n\nReset the FPGA.\n\n\necho\n \n18\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio18/direction\n\necho\n \n1\n \n /sys/class/gpio/gpio18/value\n\necho\n \n0\n \n /sys/class/gpio/gpio18/value\n\necho\n \n1\n \n /sys/class/gpio/gpio18/value\n\n\n\n\nFlash the FPGA.\n\n\ncd\n /usr/share/matrixlabs/matrixio-devices/\nxc3sprog -c matrix_creator blob/system_creator.bit -p \n1\n\n\n\n\n\nYou should receive the following.\n\n\nXC3SPROG \n(\nc\n)\n \n2004\n-2011 xc3sprog project \n$Rev\n: \n774\n $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id\n=\n170565\n\nCheck Sourceforge \nfor\n updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0x99a9bca3325faafd\n\n\n\n\nReset the FPGA.\n\n\necho\n \n26\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio26/direction  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n0\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value\n\n\n\n\n\n\nMCU will be reflashed with stock firmware.\n\n\n\n\nNow you can flash the MCU.\n\n\ncd\n /usr/share/matrixlabs/matrixio-devices/\nsudo openocd -f cfg/sam3s_rpi_sysfs.cfg\n\n\n\n\nThe last part of the \nopenocd\n flashing command output should be the following.\n\n\nflash \nat91sam3\n found at 0x00400000\nwrote \n36636\n bytes from file blob/ch.bin to flash bank \n0\n at offset 0x00000000 in \n4\n.665386s \n(\n7\n.669 KiB/s\n)\n\nInfo : JTAG tap: em358.cpu tap/device found: 0x3ba00477 \n(\nmfg: 0x23b \n(\nARM Ltd.\n)\n, part: 0xba00, ver: 0x3\n)\n\nInfo : JTAG tap: em357.bs tap/device found: 0x069aa62b \n(\nmfg: 0x315 \n(\nEmber Corporation\n)\n, part: 0x69aa, ver: 0x0\n)\nInfo : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 \n(\nmfg: 0x049 \n(\nXilinx\n)\n, part: 0x4000, ver: 0x2\n)\n\nInfo : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 \n(\nmfg: 0x23b \n(\nARM Ltd.\n)\n, part: 0xba00, ver: 0x4\n)\n\nWarn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support.\nshutdown \ncommand\n invoked\n\n\n\n\nPower off your device.\n\n\nsudo poweroff\n\n\n\n\nWait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.\n\n\nPlug the power cable back into your Raspberry Pi.\n\n\nReinstall MATRIX Kernel Modules\n\n\nIf you experience strange behavior, reinstall the MATRIX kernel modules.\n\n\nUninstall the \nmatrixio-kernel-modules\n package.\n\n\nsudo apt-get --purge remove matrixio-kernel-modules\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the \nmatrixio-kernel-modules\n package.\n\n\nsudo apt-get install matrixio-kernel-modules\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nCheck Raspberry Pi GPIO\n\n\nIf you experience strange behavior, check the Raspberry Pi GPIO.\n\n\nsudo cat /sys/kernel/debug/gpio\n\n\n\n\nYou should receive the following.\n\n\ngpiochip0: GPIOs \n0\n-53, parent: platform/3f200000.gpio, pinctrl-bcm2835:\n gpio-4   \n(\n                    \n|\nsysfs               \n)\n in  hi\n gpio-16  \n(\n                    \n|\nsysfs               \n)\n out lo\n gpio-17  \n(\n                    \n|\nsysfs               \n)\n in  hi\n gpio-18  \n(\n                    \n|\nsysfs               \n)\n out hi\n gpio-19  \n(\n                    \n|\nsysfs               \n)\n out hi\n gpio-20  \n(\n                    \n|\nsysfs               \n)\n out hi\n gpio-21  \n(\n                    \n|\nsysfs               \n)\n out hi\n gpio-22  \n(\n                    \n|\nsysfs               \n)\n in  lo\n gpio-23  \n(\n                    \n|\nsysfs               \n)\n out hi\n gpio-27  \n(\n                    \n|\nsysfs               \n)\n in  hi\n\n\n\n\nIf \nsysfs\n above is replaced with \nw1\n, use raspi-config to disable the 1-Wire interface.\n\n\nsudo raspi-config\n\n\n\n\nInside raspi-config, navigate to \nInterfacing Options\n \n \n1-Wire\n \n \nNO\n.\n\n\nHardware Tests\n\n\nThese tests will check if your MATRIX Creator is functioning properly.\n\n\nWe first need to install matrixio-creator-init, which handles the flashing of FPGA.\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the MATRIX init package.\n\n\nsudo apt-get install matrixio-creator-init\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nMatrix Init Script\n\n\nAfter the reboot, run the matrix init script manually.\n\n\nsudo /usr/share/matrixlabs/matrixio-devices/matrix-init.bash\n\n\n\n\nYou should receive the following.\n\n\n**** MATRIX Creator FPGA has been programmed!\nINFO: \n[\n/dev/spidev0.0\n]\n was opened\nFPGA \nIDENTIFY\n \n=\n 5c344e8\nFPGA \nVERSION\n \n=\n 1000a\n*** MATRIX Creator initial process has been launched\n*** Running the program instead of the bootloader\nEM358 MCU was programmed before. Not programming it again.\nRunning the program instead of the bootloader\nSAM3 MCU was programmed before. Not programming it again.\n\n\n\n\nIf you have the matrixio-kernel-modules installed, you should receive this instead.\n\n\n**** MATRIX Creator FPGA has been programmed!\nINFO: \n[\n/dev/matrixio_regmap\n]\n was opened\nFPGA \nIDENTIFY\n \n=\n 5c344e8\nFPGA \nVERSION\n \n=\n 1000a\n*** MATRIX Creator initial process has been launched\n*** Running the program instead of the bootloader\nEM358 MCU was programmed before. Not programming it again.\nRunning the program instead of the bootloader\nSAM3 MCU was programmed before. Not programming it again.\n\n\n\n\nFPGA Info\n\n\nThis program checks the fpga info.\n\n\nsudo /usr/share/matrixlabs/matrixio-devices/fpga_info\n\n\n\n\nYou should receive the following.\n\n\nINFO: \n[\n/dev/spidev0.0\n]\n was opened\nFPGA \nIDENTIFY\n \n=\n 5c344e8\nFPGA \nVERSION\n \n=\n 1000a\n\n\n\n\nIf you have the matrixio-kernel-modules installed, you should receive this instead.\n\n\nINFO: \n[\n/dev/matrixio_regmap\n]\n was opened\nFPGA \nIDENTIFY\n \n=\n 5c344e8\nFPGA \nVERSION\n \n=\n 1000a\n\n\n\n\nFPGA Flash\n\n\nIf you don\u2019t get the proper FPGA info you will need to run the FPGA flashing process.\n\n\ncd\n /usr/share/matrixlabs/matrixio-devices/\nsudo ./fpga-program.bash\n\n\n\n\nYou should receive the following.\n\n\n**** MATRIX Creator FPGA has been programmed!\nINFO: \n[\n/dev/spidev0.0\n]\n was opened\nFPGA \nIDENTIFY\n \n=\n 5c344e8\nFPGA \nVERSION\n \n=\n 1000a\n\n\n\n\nIf you have the matrixio-kernel-modules installed, you should receive this instead.\n\n\n**** MATRIX Creator FPGA has been programmed!\nINFO: \n[\n/dev/matrixio_regmap\n]\n was opened\nFPGA \nIDENTIFY\n \n=\n 5c344e8\nFPGA \nVERSION\n \n=\n 1000a\n\n\n\n\nIf you get \n**** Could not program FPGA\n, please \ncontact us\n.\n\n\nTest Other Components\n\n\nInstall MATRIX HAL \n and test other components such as the microphone array using the \nMATRIX HAL examples\n.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-creator/troubleshooting/#community", 
            "text": "Please visit our community support forums at community.matrix.one", 
            "title": "Community"
        }, 
        {
            "location": "/matrix-creator/troubleshooting/#reinstall-matrix-init-package-and-reflash-fpga-and-mcu", 
            "text": "If you experience strange behavior, reinstall the MATRIX init package and reflash FPGA and MCU.  Uninstall the  matrixio-creator-init  package.  sudo apt-get --purge remove matrixio-creator-init  Reboot your device.  sudo reboot  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the  matrixio-creator-init  package.  sudo apt-get install matrixio-creator-init  Reboot your device.  sudo reboot   FPGA will be reflashed with stock firmware.   Now you can flash the FPGA.  Reset the FPGA.  echo   18    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio18/direction echo   1    /sys/class/gpio/gpio18/value echo   0    /sys/class/gpio/gpio18/value echo   1    /sys/class/gpio/gpio18/value  Flash the FPGA.  cd  /usr/share/matrixlabs/matrixio-devices/\nxc3sprog -c matrix_creator blob/system_creator.bit -p  1   You should receive the following.  XC3SPROG  ( c )   2004 -2011 xc3sprog project  $Rev :  774  $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id = 170565 \nCheck Sourceforge  for  updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0x99a9bca3325faafd  Reset the FPGA.  echo   26    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio26/direction   echo   1    /sys/class/gpio/gpio26/value   echo   0    /sys/class/gpio/gpio26/value   echo   1    /sys/class/gpio/gpio26/value   MCU will be reflashed with stock firmware.   Now you can flash the MCU.  cd  /usr/share/matrixlabs/matrixio-devices/\nsudo openocd -f cfg/sam3s_rpi_sysfs.cfg  The last part of the  openocd  flashing command output should be the following.  flash  at91sam3  found at 0x00400000\nwrote  36636  bytes from file blob/ch.bin to flash bank  0  at offset 0x00000000 in  4 .665386s  ( 7 .669 KiB/s ) \nInfo : JTAG tap: em358.cpu tap/device found: 0x3ba00477  ( mfg: 0x23b  ( ARM Ltd. ) , part: 0xba00, ver: 0x3 ) \nInfo : JTAG tap: em357.bs tap/device found: 0x069aa62b  ( mfg: 0x315  ( Ember Corporation ) , part: 0x69aa, ver: 0x0 ) Info : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093  ( mfg: 0x049  ( Xilinx ) , part: 0x4000, ver: 0x2 ) \nInfo : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477  ( mfg: 0x23b  ( ARM Ltd. ) , part: 0xba00, ver: 0x4 ) \nWarn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support.\nshutdown  command  invoked  Power off your device.  sudo poweroff  Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.  Plug the power cable back into your Raspberry Pi.", 
            "title": "Reinstall MATRIX Init Package and Reflash FPGA and MCU"
        }, 
        {
            "location": "/matrix-creator/troubleshooting/#reinstall-matrix-kernel-modules", 
            "text": "If you experience strange behavior, reinstall the MATRIX kernel modules.  Uninstall the  matrixio-kernel-modules  package.  sudo apt-get --purge remove matrixio-kernel-modules  Reboot your device.  sudo reboot  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the  matrixio-kernel-modules  package.  sudo apt-get install matrixio-kernel-modules  Reboot your device.  sudo reboot", 
            "title": "Reinstall MATRIX Kernel Modules"
        }, 
        {
            "location": "/matrix-creator/troubleshooting/#check-raspberry-pi-gpio", 
            "text": "If you experience strange behavior, check the Raspberry Pi GPIO.  sudo cat /sys/kernel/debug/gpio  You should receive the following.  gpiochip0: GPIOs  0 -53, parent: platform/3f200000.gpio, pinctrl-bcm2835:\n gpio-4    (                      | sysfs                )  in  hi\n gpio-16   (                      | sysfs                )  out lo\n gpio-17   (                      | sysfs                )  in  hi\n gpio-18   (                      | sysfs                )  out hi\n gpio-19   (                      | sysfs                )  out hi\n gpio-20   (                      | sysfs                )  out hi\n gpio-21   (                      | sysfs                )  out hi\n gpio-22   (                      | sysfs                )  in  lo\n gpio-23   (                      | sysfs                )  out hi\n gpio-27   (                      | sysfs                )  in  hi  If  sysfs  above is replaced with  w1 , use raspi-config to disable the 1-Wire interface.  sudo raspi-config  Inside raspi-config, navigate to  Interfacing Options     1-Wire     NO .", 
            "title": "Check Raspberry Pi GPIO"
        }, 
        {
            "location": "/matrix-creator/troubleshooting/#hardware-tests", 
            "text": "These tests will check if your MATRIX Creator is functioning properly.  We first need to install matrixio-creator-init, which handles the flashing of FPGA.  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the MATRIX init package.  sudo apt-get install matrixio-creator-init  Reboot your device.  sudo reboot", 
            "title": "Hardware Tests"
        }, 
        {
            "location": "/matrix-creator/troubleshooting/#matrix-init-script", 
            "text": "After the reboot, run the matrix init script manually.  sudo /usr/share/matrixlabs/matrixio-devices/matrix-init.bash  You should receive the following.  **** MATRIX Creator FPGA has been programmed!\nINFO:  [ /dev/spidev0.0 ]  was opened\nFPGA  IDENTIFY   =  5c344e8\nFPGA  VERSION   =  1000a\n*** MATRIX Creator initial process has been launched\n*** Running the program instead of the bootloader\nEM358 MCU was programmed before. Not programming it again.\nRunning the program instead of the bootloader\nSAM3 MCU was programmed before. Not programming it again.  If you have the matrixio-kernel-modules installed, you should receive this instead.  **** MATRIX Creator FPGA has been programmed!\nINFO:  [ /dev/matrixio_regmap ]  was opened\nFPGA  IDENTIFY   =  5c344e8\nFPGA  VERSION   =  1000a\n*** MATRIX Creator initial process has been launched\n*** Running the program instead of the bootloader\nEM358 MCU was programmed before. Not programming it again.\nRunning the program instead of the bootloader\nSAM3 MCU was programmed before. Not programming it again.", 
            "title": "Matrix Init Script"
        }, 
        {
            "location": "/matrix-creator/troubleshooting/#fpga-info", 
            "text": "This program checks the fpga info.  sudo /usr/share/matrixlabs/matrixio-devices/fpga_info  You should receive the following.  INFO:  [ /dev/spidev0.0 ]  was opened\nFPGA  IDENTIFY   =  5c344e8\nFPGA  VERSION   =  1000a  If you have the matrixio-kernel-modules installed, you should receive this instead.  INFO:  [ /dev/matrixio_regmap ]  was opened\nFPGA  IDENTIFY   =  5c344e8\nFPGA  VERSION   =  1000a", 
            "title": "FPGA Info"
        }, 
        {
            "location": "/matrix-creator/troubleshooting/#fpga-flash", 
            "text": "If you don\u2019t get the proper FPGA info you will need to run the FPGA flashing process.  cd  /usr/share/matrixlabs/matrixio-devices/\nsudo ./fpga-program.bash  You should receive the following.  **** MATRIX Creator FPGA has been programmed!\nINFO:  [ /dev/spidev0.0 ]  was opened\nFPGA  IDENTIFY   =  5c344e8\nFPGA  VERSION   =  1000a  If you have the matrixio-kernel-modules installed, you should receive this instead.  **** MATRIX Creator FPGA has been programmed!\nINFO:  [ /dev/matrixio_regmap ]  was opened\nFPGA  IDENTIFY   =  5c344e8\nFPGA  VERSION   =  1000a  If you get  **** Could not program FPGA , please  contact us .", 
            "title": "FPGA Flash"
        }, 
        {
            "location": "/matrix-creator/troubleshooting/#test-other-components", 
            "text": "Install MATRIX HAL   and test other components such as the microphone array using the  MATRIX HAL examples .", 
            "title": "Test Other Components"
        }, 
        {
            "location": "/matrix-voice/overview/", 
            "text": "MATRIX Voice\n\n\n\n\nThe MATRIX Voice is a development board for building sound driven behaviors and interfaces. MATRIX Voice was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) voice app creation.\n\n\nOverview\n\n\nDevice Setup\n\n\n\nHow to get started with your MATRIX Voice \n MATRIX Voice ESP32 version\n\n\nESP32\n\n\n\nInstructions to setup your ESP32 module\n\n\nResources\n\n\n\nView and download helpful information about the MATRIX Voice\n\n\nTroubleshooting\n\n\n\nLook at common debugging solutions and test the hardware on your MATRIX Voice\n\n\nBoard Versions\n\n\nBoth versions of these boards run the same on a Raspberry Pi, however, the MATRIX Voice ESP32 version has the option to run standalone by programming the ESP32 module.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-voice/overview/#matrix-voice", 
            "text": "The MATRIX Voice is a development board for building sound driven behaviors and interfaces. MATRIX Voice was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) voice app creation.", 
            "title": "MATRIX Voice"
        }, 
        {
            "location": "/matrix-voice/overview/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-voice/overview/#board-versions", 
            "text": "Both versions of these boards run the same on a Raspberry Pi, however, the MATRIX Voice ESP32 version has the option to run standalone by programming the ESP32 module.", 
            "title": "Board Versions"
        }, 
        {
            "location": "/matrix-voice/device-setup/", 
            "text": "Hardware Prerequisites\n\n\n\n\nMATRIX Voice\n\n\nCompatible Raspberry Pi:\n\n\n3 Model B+\n\n\n3 Model B\n\n\n2 Model B\n\n\n1 Model B+\n\n\nZero\n\n\nZero W\n\n\n\n\n\n\n5V 2.5A Micro USB Power Supply\n\n\nMicroSD Card With \nRaspbian Stretch\n Lite or Desktop Installed\n\n\nWe recommend using \nEtcher.io\n for easy flashing\n\n\n\n\n\n\n\n\nDevice Installation\n\n\n\n\nSteps\n\n\n\n\nInsert flashed microSD card into Raspberry Pi\n\n\nAttach MATRIX Voice onto Raspberry Pi GPIO pins\n\n\nPower Raspberry Pi with micro USB power supply\n\n\n\n\n\n\nThe yellow startup LED sequence (with 1 LED off) will be removed when a programming environment is installed.\n\n\n\n\nChoosing A Programming Environment\n\n\nAfter your MATRIX Voice is setup, visit \nEcosystem Overview\n for information about the three programming environments available to you in the MATRIX platform.\n\n\n\n\nAll 3 programming environments are compatible with the MATRIX Voice \n MATRIX Voice ESP32 version on a Raspberry Pi.  \n\n\n\n\nESP32 Setup\n\n\nUsers with a MATRIX Voice ESP32 version can also follow this \nguide\n on how to program their ESP32 module.", 
            "title": "Device Setup"
        }, 
        {
            "location": "/matrix-voice/device-setup/#hardware-prerequisites", 
            "text": "MATRIX Voice  Compatible Raspberry Pi:  3 Model B+  3 Model B  2 Model B  1 Model B+  Zero  Zero W    5V 2.5A Micro USB Power Supply  MicroSD Card With  Raspbian Stretch  Lite or Desktop Installed  We recommend using  Etcher.io  for easy flashing", 
            "title": "Hardware Prerequisites"
        }, 
        {
            "location": "/matrix-voice/device-setup/#device-installation", 
            "text": "", 
            "title": "Device Installation"
        }, 
        {
            "location": "/matrix-voice/device-setup/#choosing-a-programming-environment", 
            "text": "After your MATRIX Voice is setup, visit  Ecosystem Overview  for information about the three programming environments available to you in the MATRIX platform.   All 3 programming environments are compatible with the MATRIX Voice   MATRIX Voice ESP32 version on a Raspberry Pi.", 
            "title": "Choosing A Programming Environment"
        }, 
        {
            "location": "/matrix-voice/device-setup/#esp32-setup", 
            "text": "Users with a MATRIX Voice ESP32 version can also follow this  guide  on how to program their ESP32 module.", 
            "title": "ESP32 Setup"
        }, 
        {
            "location": "/matrix-voice/esp32/", 
            "text": "ESP32 Setup\n\n\nThis guide will show you how to get started with the ESP32 module on the MATRIX Voice ESP32 version.\n\n\nStep 1: Raspberry Pi Setup\n\n\nRun the following commands inside your Raspberry Pi terminal to install the MATRIX Voice Software. This will keep the FPGA firmware updated and install few tools to flash the ESP-WROOM-32.\n\n\nAdd the MATRIX repository and key.\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\nUpdate your repository and packages.\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\nInstall the MATRIX init package.\n\nsudo apt install matrixio-creator-init\n\n\n\nReboot your Raspberry Pi.\n\nsudo reboot\n\n\n\nStep 2: Personal Computer Setup\n\n\nHere we're installing the requirements needed to allow your pc to develop and compile ESP32 projects.\n\n\nInstall Git:\n\n\n\n\nhttps://git-scm.com/downloads\n\n\n\n\nInstall ESP32 toolchain:\n\n\n\n\nLinux: \nhttps://esp-idf.readthedocs.io/en/latest/get-started/linux-setup.html\n\n\nMac: \nhttps://esp-idf.readthedocs.io/en/latest/get-started/macos-setup.html\n\n\nWindows: \nhttps://esp-idf.readthedocs.io/en/latest/get-started/windows-setup.html\n\n\nStop Following when you reach \"Next Steps\"\n\n\n\n\nSetup ESP-IDF development framework:\n\n\n\n\nDownload ESP-IDF: \nhttps://esp-idf.readthedocs.io/en/latest/get-started/index.html#get-esp-idf\n\n\nSet ESP-IDF Path: \nhttps://esp-idf.readthedocs.io/en/latest/get-started/add-idf_path-to-profile.html\n\n\n\n\nClone MATRIX Voice ESP32 repository\n\n\nThis repository contains the necessary libraries to control the MATRIX Voice's components.\n\n# windows must be using MINGw32 terminal from toolchain step\n\ngit clone https://github.com/matrix-io/matrixio_hal_esp32.git\n\n\n\nStep 3: Build and Deploy\n\n\nHere we will be deploying and running one of the example apps in the Repository we just downloaded.\n\n\nConfiguring IDF (one time setup):\n\n\ncd\n matrixio_hal_esp32/examples/mic_energy/\nmake menuconfig\n\n\n\n\n\nYou will now be taken to the IDF Configuration screen, as shown above. Once there, select the \n option to save default configuration.\n\n\nRunning example project:\n\n\nTo finish running the example, all that's left is to make and deploy the code to the Raspberry Pi. This requires the Pi's IP address and you will be prompted to insert the Pi's password as well.\n\nexport\n \nRPI_HOST\n=\npi@RASPBERRY_IP_ADDRESS\nmake deploy\n\n\n\nStep 4: Finishing Up\n\n\n\n\nYour MATRIX Voice ESP32 should now be running the deployed example. With the program properly flashed in the ESP32, the Voice can now run without the Pi if you choose to do so. Ensure the MATRIX Voice and Pi are not powered before connecting or disconnecting.", 
            "title": "ESP32"
        }, 
        {
            "location": "/matrix-voice/esp32/#esp32-setup", 
            "text": "This guide will show you how to get started with the ESP32 module on the MATRIX Voice ESP32 version.", 
            "title": "ESP32 Setup"
        }, 
        {
            "location": "/matrix-voice/esp32/#step-1-raspberry-pi-setup", 
            "text": "Run the following commands inside your Raspberry Pi terminal to install the MATRIX Voice Software. This will keep the FPGA firmware updated and install few tools to flash the ESP-WROOM-32.  Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages. sudo apt-get update\nsudo apt-get upgrade  Install the MATRIX init package. sudo apt install matrixio-creator-init  Reboot your Raspberry Pi. sudo reboot", 
            "title": "Step 1: Raspberry Pi Setup"
        }, 
        {
            "location": "/matrix-voice/esp32/#step-2-personal-computer-setup", 
            "text": "Here we're installing the requirements needed to allow your pc to develop and compile ESP32 projects.  Install Git:   https://git-scm.com/downloads   Install ESP32 toolchain:   Linux:  https://esp-idf.readthedocs.io/en/latest/get-started/linux-setup.html  Mac:  https://esp-idf.readthedocs.io/en/latest/get-started/macos-setup.html  Windows:  https://esp-idf.readthedocs.io/en/latest/get-started/windows-setup.html  Stop Following when you reach \"Next Steps\"   Setup ESP-IDF development framework:   Download ESP-IDF:  https://esp-idf.readthedocs.io/en/latest/get-started/index.html#get-esp-idf  Set ESP-IDF Path:  https://esp-idf.readthedocs.io/en/latest/get-started/add-idf_path-to-profile.html   Clone MATRIX Voice ESP32 repository  This repository contains the necessary libraries to control the MATRIX Voice's components. # windows must be using MINGw32 terminal from toolchain step \ngit clone https://github.com/matrix-io/matrixio_hal_esp32.git", 
            "title": "Step 2: Personal Computer Setup"
        }, 
        {
            "location": "/matrix-voice/esp32/#step-3-build-and-deploy", 
            "text": "Here we will be deploying and running one of the example apps in the Repository we just downloaded.  Configuring IDF (one time setup):  cd  matrixio_hal_esp32/examples/mic_energy/\nmake menuconfig   You will now be taken to the IDF Configuration screen, as shown above. Once there, select the   option to save default configuration.  Running example project:  To finish running the example, all that's left is to make and deploy the code to the Raspberry Pi. This requires the Pi's IP address and you will be prompted to insert the Pi's password as well. export   RPI_HOST = pi@RASPBERRY_IP_ADDRESS\nmake deploy", 
            "title": "Step 3: Build and Deploy"
        }, 
        {
            "location": "/matrix-voice/esp32/#step-4-finishing-up", 
            "text": "Your MATRIX Voice ESP32 should now be running the deployed example. With the program properly flashed in the ESP32, the Voice can now run without the Pi if you choose to do so. Ensure the MATRIX Voice and Pi are not powered before connecting or disconnecting.", 
            "title": "Step 4: Finishing Up"
        }, 
        {
            "location": "/matrix-voice/resources/overview/", 
            "text": "Resources\n\n\nPinout\n\n\n\nLists and labels of the MATRIX Voice's Pinouts\n\n\nMicrophones\n\n\n\nMicrophone drivers, sample rate, and board position\n\n\nReference Models\n\n\n\nDownload or view the Matrix Voice's 3D models\n\n\nSystem Architecture\n\n\n\nView a technical diagram of the MATRIX Voice architecture\n\n\nTechnical Datasheets\n\n\n\nPDFs of MATRIX Creator Components\n\n\nFPGA\n\n\n\nFPGA source and flashing guide", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-voice/resources/overview/#resources", 
            "text": "", 
            "title": "Resources"
        }, 
        {
            "location": "/matrix-voice/resources/pinout/", 
            "text": "Expansion GPIO\n\n\n\n\nRaspberry Pi GPIO\n\n\n\n\nGPIO Locations", 
            "title": "Pinout"
        }, 
        {
            "location": "/matrix-voice/resources/pinout/#expansion-gpio", 
            "text": "", 
            "title": "Expansion GPIO"
        }, 
        {
            "location": "/matrix-voice/resources/pinout/#raspberry-pi-gpio", 
            "text": "", 
            "title": "Raspberry Pi GPIO"
        }, 
        {
            "location": "/matrix-voice/resources/pinout/#gpio-locations", 
            "text": "", 
            "title": "GPIO Locations"
        }, 
        {
            "location": "/matrix-voice/resources/microphone/", 
            "text": "Microphone Array on MATRIX Voice\n\n\n\n\nUsage\n\n\nDriver installation\n\nFollow the instructions below for allowing your MATRIX Voice to register as a microphone for your Raspberry Pi.\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\nsudo apt-get update\nsudo apt-get upgrade\n\n\nA reboot will be required after the MATRIX packages above are installed.\n\nsudo reboot\n\n\nThe next commands will install the MATRIX kernel modules, overriding the stock Raspbian kernel.\n\nsudo apt install matrixio-kernel-modules\n\n\nA second reboot will be required.\n\nsudo reboot\n\n\n\nCheck If Everything Works\n\nYour Raspberry Pi should now treat your MATRIX Voice as a regular microphone. You can test this by using the following commands to record and play a 5 second long audio file on your Raspberry Pi.\n\n\n\n\nBe sure to have something connected to the Raspberry Pi's audio output.\n\narecord recording.wav -f S16_LE -r \n16000\n -d \n5\n\naplay recording.wav\n\n\n\n\n\nALSA Configuration\n\n\n\nThe microphones can be grabbed using ALSA. Multiple libraries that support ALSA use these configurations to read microphone data with ALSA.\n\n\nDevice name - \nhw:2,0\n\n\nRates(Hz) - \n8000\n \n12000\n \n16000\n \n22050\n \n24000\n \n32000\n \n44100\n \n48000\n\n\nChannels for each microphone - \n1\n \n2\n \n3\n \n4\n \n5\n \n6\n \n7\n \n8\n\n\nAudio specs\n\n\nSample Rate:\n 8 to 96 kHz\n\n\nBit Depth:\n Signed 16 bit\n\n\nPosition [x,y] of each mic in the array (mm)\n\n\n\n\n\n\n\n\n\nMic\n\n\nX\n\n\nY\n\n\n\n\n\n\n\n\n\n\nM1\n\n\n00.00\n\n\n0.00\n\n\n\n\n\n\nM2\n\n\n-38.13\n\n\n3.58\n\n\n\n\n\n\nM3\n\n\n-20.98\n\n\n32.04\n\n\n\n\n\n\nM4\n\n\n11.97\n\n\n36.38\n\n\n\n\n\n\nM5\n\n\n35.91\n\n\n13.32\n\n\n\n\n\n\nM6\n\n\n32.81\n\n\n-19.77\n\n\n\n\n\n\nM7\n\n\n5.00\n\n\n-37.97\n\n\n\n\n\n\nM8\n\n\n-26.57\n\n\n-27.58\n\n\n\n\n\n\n\n\nConnection to the FPGA\n\n\n\n\n\n\n\n\n\nMic\n\n\nFPGA pin\n\n\nPDM_Data\n\n\n\n\n\n\n\n\n\n\nM1\n\n\nE6\n\n\npdm_data\n0\n\n\n\n\n\n\nM2\n\n\nB8\n\n\npdm_data\n1\n\n\n\n\n\n\nM3\n\n\nA8\n\n\npdm_data\n2\n\n\n\n\n\n\nM4\n\n\nC7\n\n\npdm_data\n3\n\n\n\n\n\n\nM5\n\n\nA7\n\n\npdm_data\n4\n\n\n\n\n\n\nM6\n\n\nA6\n\n\npdm_data\n5\n\n\n\n\n\n\nM7\n\n\nB6\n\n\npdm_data\n6\n\n\n\n\n\n\nM8\n\n\nA5\n\n\npdm_data\n7\n\n\n\n\n\n\nCLK\n\n\nB5\n\n\npdm_clk", 
            "title": "Microphones"
        }, 
        {
            "location": "/matrix-voice/resources/microphone/#microphone-array-on-matrix-voice", 
            "text": "", 
            "title": "Microphone Array on MATRIX Voice"
        }, 
        {
            "location": "/matrix-voice/resources/microphone/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/matrix-voice/resources/microphone/#audio-specs", 
            "text": "Sample Rate:  8 to 96 kHz  Bit Depth:  Signed 16 bit", 
            "title": "Audio specs"
        }, 
        {
            "location": "/matrix-voice/resources/reference-models/", 
            "text": "Board Model\n\n\nTop View\n\n\n\n\nBottom View\n\n\n\n\n\nModel Download\n\n\n\nAccess to 3D models \nhere\n. Also, you can take a look online \n\nhere\n.", 
            "title": "Reference Models"
        }, 
        {
            "location": "/matrix-voice/resources/reference-models/#board-model", 
            "text": "", 
            "title": "Board Model"
        }, 
        {
            "location": "/matrix-voice/resources/system-architecture/", 
            "text": "System Architecture", 
            "title": "System Architecture"
        }, 
        {
            "location": "/matrix-voice/resources/system-architecture/#system-architecture", 
            "text": "", 
            "title": "System Architecture"
        }, 
        {
            "location": "/matrix-voice/resources/technical-datasheets/", 
            "text": "Datasheets:\n\n\n\n\n\n\nXilinx Spartan 6 FPGA - XC6SLX9-2FTG256C\n\n\n\n\n\n\n8 MEMS audio sensor digital microphones - MP34DB02\n\n\n\n\n\n\nSerial Flash 64MBIT - MX25L6406E\n\n\n\n\n\n\nDDR2 SDRAM 512MBIT - MT47H32M16\n\n\n\n\n\n\n3W Stereo Class-D Audio Amplifier and Class-AB Headphone Driver - PAM8019\n\n\n\n\n\n\nRGBW LED - SK6812RGBW\n\n\n\n\n\n\nESP32-WROOM", 
            "title": "Technical Datasheets"
        }, 
        {
            "location": "/matrix-voice/resources/technical-datasheets/#datasheets", 
            "text": "Xilinx Spartan 6 FPGA - XC6SLX9-2FTG256C    8 MEMS audio sensor digital microphones - MP34DB02    Serial Flash 64MBIT - MX25L6406E    DDR2 SDRAM 512MBIT - MT47H32M16    3W Stereo Class-D Audio Amplifier and Class-AB Headphone Driver - PAM8019    RGBW LED - SK6812RGBW    ESP32-WROOM", 
            "title": "Datasheets:"
        }, 
        {
            "location": "/matrix-voice/resources/fpga/", 
            "text": "FPGA\n\n\n\nFlashing Guide\n\n\n\n\n\n\u26a0\ufe0fModifying FPGA source may have unintended consequences\u26a0\ufe0f\n\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe FPGA handles:\n\n\n\n\nGPIO output\n\n\nConnections between board components\n\n\nMicrophone processing (not provided in source code)\n\n\n\n\nFPGA Source\n\n\n\n\n\u26a0\ufe0fFPGA source does not contain audio processing code\u26a0\ufe0f\n\n\n\n\nFPGA source code is located \nhere\n.\n\n\nFPGA Flashing\n\n\nBelow is a guide on how to flash a premade user-provided FPGA bitstream onto the Xilinx Spartan-6 FPGA for the MATRIX Voice.\n\n\nWe first need to install a few prerequisites.\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the required packages.\n\n\nsudo apt-get install matrixio-creator-init\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\nBackup the stock \nsystem_voice.bit\n file.\n\n\nsudo mv /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit /usr/share/matrixlabs/matrixio-devices/blob/system_voice_stock.bit\n\n\n\n\nCopy your built \nsystem_voice.bit\n FPGA bitstream file to the blob folder.\n\n\nsudo cp /path/to/your/file /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit\n\n\n\n\nNow you can flash the FPGA.\n\n\nReset the FPGA.\n\n\necho\n \n26\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio26/direction  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n0\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value\n\n\n\n\nFlash the SPI Flash bootloader onto FPGA.\n\n\nxc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit\n\n\n\n\nYou should receive the following (may vary due to user-provided file).\n\n\nXC3SPROG \n(\nc\n)\n \n2004\n-2011 xc3sprog project \n$Rev\n: \n774\n $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id\n=\n170565\n\nCheck Sourceforge \nfor\n updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0xf9d61a1ecbb64401\n\n\n\n\nFlash the SPI Flash.\n\n\nxc3sprog -c matrix_voice -I blob/system_voice.bit\n\n\n\n\nYou should receive the following (may vary due to user-provided file).\n\n\nXC3SPROG \n(\nc\n)\n \n2004\n-2011 xc3sprog project \n$Rev\n: \n774\n $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id\n=\n170565\n\nCheck Sourceforge \nfor\n updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nJEDEC: c2 \n20\n 0x17 0xc2\nFound Macronix MX25L Device, Device ID 0x2017\n\n256\n bytes/page, \n262144\n \npages\n \n=\n \n67108864\n bytes total\nVerify: Success!\n\n\n\n\nReset the FPGA.\n\n\necho\n \n26\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio26/direction  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n0\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value\n\n\n\n\nIn order to maintain compatibility with the \nmatrixio-creator-init\n package, you'll need to backup the original \nvoice.version\n file, and create your own.\n\n\ncd\n /usr/share/matrixlabs/matrixio-devices/\nsudo mv /usr/share/matrixlabs/matrixio-devices/voice.version /usr/share/matrixlabs/matrixio-devices/voice_stock.version\n\n(\n./fpga_info \n|\n grep FPGA\n)\n \n|\n sudo tee voice.version\n\n\n\n\nUpdating the \nmatrixio-creator-init\n package will cause the stock FPGA bitstream to be flashed upon next boot.\n\n\nYou can stop \nsudo apt-get upgrade\n from automatically updating the \nmatrixio-creator-init\n package with the following command.\n\n\nsudo apt-mark hold matrixio-creator-init\n\n\n\n\nPower off your device.\n\n\nsudo poweroff\n\n\n\n\nWait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.\n\n\nPlug the power cable back into your Raspberry Pi.\n\n\nRestore Original Firmware\n\n\nTo restore the original firmware, restore the stock \nsystem_voice.bit\n file in the blob folder.\n\n\nsudo rm /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit\nsudo cp /usr/share/matrixlabs/matrixio-devices/blob/system_voice_stock.bit /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit\n\n\n\n\nNow you can flash the FPGA.\n\n\nReset the FPGA.\n\n\necho\n \n26\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio26/direction  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n0\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value\n\n\n\n\nFlash the SPI Flash bootloader onto FPGA.\n\n\nxc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit\n\n\n\n\nYou should receive the following.\n\n\nXC3SPROG \n(\nc\n)\n \n2004\n-2011 xc3sprog project \n$Rev\n: \n774\n $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id\n=\n170565\n\nCheck Sourceforge \nfor\n updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0xf9d61a1ecbb64401\n\n\n\n\nFlash the SPI Flash.\n\n\nxc3sprog -c matrix_voice -I blob/system_voice.bit\n\n\n\n\nYou should receive the following.\n\n\nXC3SPROG \n(\nc\n)\n \n2004\n-2011 xc3sprog project \n$Rev\n: \n774\n $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id\n=\n170565\n\nCheck Sourceforge \nfor\n updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nJEDEC: c2 \n20\n 0x17 0xc2\nFound Macronix MX25L Device, Device ID 0x2017\n\n256\n bytes/page, \n262144\n \npages\n \n=\n \n67108864\n bytes total\nVerify: Success!\n\n\n\n\nReset the FPGA.\n\n\necho\n \n26\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio26/direction  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n0\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value\n\n\n\n\nRestore the stock \nvoice.version\n file.\n\n\nsudo rm /usr/share/matrixlabs/matrixio-devices/voice.version\nsudo cp /usr/share/matrixlabs/matrixio-devices/voice_stock.version /usr/share/matrixlabs/matrixio-devices/voice.version\n\n\n\n\nAllow \nsudo apt-get upgrade\n to update the \nmatrixio-creator-init\n package.\n\n\nsudo apt-mark unhold matrixio-creator-init\n\n\n\n\nPower off your device.\n\n\nsudo poweroff\n\n\n\n\nWait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.\n\n\nPlug the power cable back into your Raspberry Pi.", 
            "title": "FPGA"
        }, 
        {
            "location": "/matrix-voice/resources/fpga/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-voice/resources/fpga/#overview", 
            "text": "The FPGA handles:   GPIO output  Connections between board components  Microphone processing (not provided in source code)", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-voice/resources/fpga/#fpga-source", 
            "text": "\u26a0\ufe0fFPGA source does not contain audio processing code\u26a0\ufe0f   FPGA source code is located  here .", 
            "title": "FPGA Source"
        }, 
        {
            "location": "/matrix-voice/resources/fpga/#fpga-flashing", 
            "text": "Below is a guide on how to flash a premade user-provided FPGA bitstream onto the Xilinx Spartan-6 FPGA for the MATRIX Voice.  We first need to install a few prerequisites.  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the required packages.  sudo apt-get install matrixio-creator-init  Reboot your device.  sudo reboot \nBackup the stock  system_voice.bit  file.  sudo mv /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit /usr/share/matrixlabs/matrixio-devices/blob/system_voice_stock.bit  Copy your built  system_voice.bit  FPGA bitstream file to the blob folder.  sudo cp /path/to/your/file /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit  Now you can flash the FPGA.  Reset the FPGA.  echo   26    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio26/direction   echo   1    /sys/class/gpio/gpio26/value   echo   0    /sys/class/gpio/gpio26/value   echo   1    /sys/class/gpio/gpio26/value  Flash the SPI Flash bootloader onto FPGA.  xc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit  You should receive the following (may vary due to user-provided file).  XC3SPROG  ( c )   2004 -2011 xc3sprog project  $Rev :  774  $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id = 170565 \nCheck Sourceforge  for  updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0xf9d61a1ecbb64401  Flash the SPI Flash.  xc3sprog -c matrix_voice -I blob/system_voice.bit  You should receive the following (may vary due to user-provided file).  XC3SPROG  ( c )   2004 -2011 xc3sprog project  $Rev :  774  $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id = 170565 \nCheck Sourceforge  for  updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nJEDEC: c2  20  0x17 0xc2\nFound Macronix MX25L Device, Device ID 0x2017 256  bytes/page,  262144   pages   =   67108864  bytes total\nVerify: Success!  Reset the FPGA.  echo   26    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio26/direction   echo   1    /sys/class/gpio/gpio26/value   echo   0    /sys/class/gpio/gpio26/value   echo   1    /sys/class/gpio/gpio26/value  In order to maintain compatibility with the  matrixio-creator-init  package, you'll need to backup the original  voice.version  file, and create your own.  cd  /usr/share/matrixlabs/matrixio-devices/\nsudo mv /usr/share/matrixlabs/matrixio-devices/voice.version /usr/share/matrixlabs/matrixio-devices/voice_stock.version ( ./fpga_info  |  grep FPGA )   |  sudo tee voice.version  Updating the  matrixio-creator-init  package will cause the stock FPGA bitstream to be flashed upon next boot.  You can stop  sudo apt-get upgrade  from automatically updating the  matrixio-creator-init  package with the following command.  sudo apt-mark hold matrixio-creator-init  Power off your device.  sudo poweroff  Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.  Plug the power cable back into your Raspberry Pi.", 
            "title": "FPGA Flashing"
        }, 
        {
            "location": "/matrix-voice/resources/fpga/#restore-original-firmware", 
            "text": "To restore the original firmware, restore the stock  system_voice.bit  file in the blob folder.  sudo rm /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit\nsudo cp /usr/share/matrixlabs/matrixio-devices/blob/system_voice_stock.bit /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit  Now you can flash the FPGA.  Reset the FPGA.  echo   26    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio26/direction   echo   1    /sys/class/gpio/gpio26/value   echo   0    /sys/class/gpio/gpio26/value   echo   1    /sys/class/gpio/gpio26/value  Flash the SPI Flash bootloader onto FPGA.  xc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit  You should receive the following.  XC3SPROG  ( c )   2004 -2011 xc3sprog project  $Rev :  774  $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id = 170565 \nCheck Sourceforge  for  updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0xf9d61a1ecbb64401  Flash the SPI Flash.  xc3sprog -c matrix_voice -I blob/system_voice.bit  You should receive the following.  XC3SPROG  ( c )   2004 -2011 xc3sprog project  $Rev :  774  $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id = 170565 \nCheck Sourceforge  for  updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nJEDEC: c2  20  0x17 0xc2\nFound Macronix MX25L Device, Device ID 0x2017 256  bytes/page,  262144   pages   =   67108864  bytes total\nVerify: Success!  Reset the FPGA.  echo   26    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio26/direction   echo   1    /sys/class/gpio/gpio26/value   echo   0    /sys/class/gpio/gpio26/value   echo   1    /sys/class/gpio/gpio26/value  Restore the stock  voice.version  file.  sudo rm /usr/share/matrixlabs/matrixio-devices/voice.version\nsudo cp /usr/share/matrixlabs/matrixio-devices/voice_stock.version /usr/share/matrixlabs/matrixio-devices/voice.version  Allow  sudo apt-get upgrade  to update the  matrixio-creator-init  package.  sudo apt-mark unhold matrixio-creator-init  Power off your device.  sudo poweroff  Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.  Plug the power cable back into your Raspberry Pi.", 
            "title": "Restore Original Firmware"
        }, 
        {
            "location": "/matrix-voice/troubleshooting/", 
            "text": "Community\n\n\nPlease visit our community support forums at\n\ncommunity.matrix.one\n\n\nReinstall MATRIX Init Package and Reflash FPGA\n\n\nIf you experience strange behavior, reinstall the MATRIX init package and reflash FPGA.\n\n\nUninstall the \nmatrixio-creator-init\n package.\n\n\nsudo apt-get --purge remove matrixio-creator-init\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the \nmatrixio-creator-init\n package.\n\n\nsudo apt-get install matrixio-creator-init\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\n\n\nFPGA will be reflashed with stock firmware.\n\n\n\n\nNow you can flash the FPGA.\n\n\nReset the FPGA.\n\n\necho\n \n26\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio26/direction  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n0\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value\n\n\n\n\nFlash the SPI Flash bootloader onto FPGA.\n\n\nxc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit\n\n\n\n\nYou should receive the following.\n\n\nXC3SPROG \n(\nc\n)\n \n2004\n-2011 xc3sprog project \n$Rev\n: \n774\n $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id\n=\n170565\n\nCheck Sourceforge \nfor\n updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0xf9d61a1ecbb64401\n\n\n\n\nFlash the SPI Flash.\n\n\nxc3sprog -c matrix_voice -I blob/system_voice.bit\n\n\n\n\nYou should receive the following.\n\n\nXC3SPROG \n(\nc\n)\n \n2004\n-2011 xc3sprog project \n$Rev\n: \n774\n $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id\n=\n170565\n\nCheck Sourceforge \nfor\n updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nJEDEC: c2 \n20\n 0x17 0xc2\nFound Macronix MX25L Device, Device ID 0x2017\n\n256\n bytes/page, \n262144\n \npages\n \n=\n \n67108864\n bytes total\nVerify: Success!\n\n\n\n\nReset the FPGA.\n\n\necho\n \n26\n \n /sys/class/gpio/export \n2\n/dev/null\n\necho\n out \n /sys/class/gpio/gpio26/direction  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n0\n \n /sys/class/gpio/gpio26/value  \n\necho\n \n1\n \n /sys/class/gpio/gpio26/value\n\n\n\n\nPower off your device.\n\n\nsudo poweroff\n\n\n\n\nWait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.\n\n\nPlug the power cable back into your Raspberry Pi.\n\n\nReinstall MATRIX Kernel Modules\n\n\nIf you experience strange behavior, reinstall the MATRIX kernel modules.\n\n\nUninstall the \nmatrixio-kernel-modules\n package.\n\n\nsudo apt-get --purge remove matrixio-kernel-modules\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the \nmatrixio-kernel-modules\n package.\n\n\nsudo apt-get install matrixio-kernel-modules\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nCheck Raspberry Pi GPIO\n\n\nIf you experience strange behavior, check the Raspberry Pi GPIO.\n\n\nsudo cat /sys/kernel/debug/gpio\n\n\n\n\nYou should receive the following.\n\n\ngpiochip0: GPIOs \n0\n-53, parent: platform/3f200000.gpio, pinctrl-bcm2835:\n gpio-18  \n(\n                    \n|\nsysfs               \n)\n out hi\n gpio-24  \n(\n                    \n|\nsysfs               \n)\n out hi\n gpio-25  \n(\n                    \n|\nsysfs               \n)\n out hi\n gpio-26  \n(\n                    \n|\nsysfs               \n)\n out hi\n\n\n\n\nIf \nsysfs\n above is replaced with \nw1\n, use raspi-config to disable the 1-Wire interface.\n\n\nsudo raspi-config\n\n\n\n\nInside raspi-config, navigate to \nInterfacing Options\n \n \n1-Wire\n \n \nNO\n.\n\n\nHardware Tests\n\n\nThese tests will check if your MATRIX Voice is functioning properly.\n\n\nWe first need to install matrixio-creator-init, which handles the flashing of FPGA.\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the MATRIX init package.\n\n\nsudo apt-get install matrixio-creator-init\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nMatrix Init Script\n\n\nAfter the reboot, run the matrix init script manually.\n\n\nsudo /usr/share/matrixlabs/matrixio-devices/matrix-init.bash\n\n\n\n\nYou should receive the following.\n\n\n*** MATRIX Voice has a updated firmware\n*** MATRIX Voice initial process has been launched\n\n\n\n\nFPGA Info\n\n\nThis program checks the fpga info.\n\n\nsudo /usr/share/matrixlabs/matrixio-devices/fpga_info\n\n\n\n\nYou should receive the following.\n\n\nINFO: \n[\n/dev/spidev0.0\n]\n was opened\nFPGA \nIDENTIFY\n \n=\n 6032bad2\nFPGA \nVERSION\n \n=\n 1000a\n\n\n\n\nIf you have the matrixio-kernel-modules installed, you should receive this instead.\n\n\nINFO: \n[\n/dev/matrixio_regmap\n]\n was opened\nFPGA \nIDENTIFY\n \n=\n 6032bad2\nFPGA \nVERSION\n \n=\n 1000a\n\n\n\n\nFPGA Flash\n\n\nIf you don\u2019t get the proper FPGA info you will need to run the FPGA flashing process.\n\n\ncd\n /usr/share/matrixlabs/matrixio-devices/\nsudo ./fpga-program.bash\n\n\n\n\nYou should receive the following.\n\n\n*** MATRIX Voice has a updated firmware\n\n\n\n\nIf you get \n**** Could not program FPGA\n, please \ncontact us\n.\n\n\nTest Other Components\n\n\nInstall MATRIX HAL\n and test other components such as the microphone array using the \nMATRIX HAL examples\n.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-voice/troubleshooting/#community", 
            "text": "Please visit our community support forums at community.matrix.one", 
            "title": "Community"
        }, 
        {
            "location": "/matrix-voice/troubleshooting/#reinstall-matrix-init-package-and-reflash-fpga", 
            "text": "If you experience strange behavior, reinstall the MATRIX init package and reflash FPGA.  Uninstall the  matrixio-creator-init  package.  sudo apt-get --purge remove matrixio-creator-init  Reboot your device.  sudo reboot  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the  matrixio-creator-init  package.  sudo apt-get install matrixio-creator-init  Reboot your device.  sudo reboot   FPGA will be reflashed with stock firmware.   Now you can flash the FPGA.  Reset the FPGA.  echo   26    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio26/direction   echo   1    /sys/class/gpio/gpio26/value   echo   0    /sys/class/gpio/gpio26/value   echo   1    /sys/class/gpio/gpio26/value  Flash the SPI Flash bootloader onto FPGA.  xc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit  You should receive the following.  XC3SPROG  ( c )   2004 -2011 xc3sprog project  $Rev :  774  $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id = 170565 \nCheck Sourceforge  for  updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0xf9d61a1ecbb64401  Flash the SPI Flash.  xc3sprog -c matrix_voice -I blob/system_voice.bit  You should receive the following.  XC3SPROG  ( c )   2004 -2011 xc3sprog project  $Rev :  774  $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n        http://sourceforge.net/mail/?group_id = 170565 \nCheck Sourceforge  for  updates:\n        http://sourceforge.net/projects/xc3sprog/develop\n\nJEDEC: c2  20  0x17 0xc2\nFound Macronix MX25L Device, Device ID 0x2017 256  bytes/page,  262144   pages   =   67108864  bytes total\nVerify: Success!  Reset the FPGA.  echo   26    /sys/class/gpio/export  2 /dev/null echo  out   /sys/class/gpio/gpio26/direction   echo   1    /sys/class/gpio/gpio26/value   echo   0    /sys/class/gpio/gpio26/value   echo   1    /sys/class/gpio/gpio26/value  Power off your device.  sudo poweroff  Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi.  Plug the power cable back into your Raspberry Pi.", 
            "title": "Reinstall MATRIX Init Package and Reflash FPGA"
        }, 
        {
            "location": "/matrix-voice/troubleshooting/#reinstall-matrix-kernel-modules", 
            "text": "If you experience strange behavior, reinstall the MATRIX kernel modules.  Uninstall the  matrixio-kernel-modules  package.  sudo apt-get --purge remove matrixio-kernel-modules  Reboot your device.  sudo reboot  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the  matrixio-kernel-modules  package.  sudo apt-get install matrixio-kernel-modules  Reboot your device.  sudo reboot", 
            "title": "Reinstall MATRIX Kernel Modules"
        }, 
        {
            "location": "/matrix-voice/troubleshooting/#check-raspberry-pi-gpio", 
            "text": "If you experience strange behavior, check the Raspberry Pi GPIO.  sudo cat /sys/kernel/debug/gpio  You should receive the following.  gpiochip0: GPIOs  0 -53, parent: platform/3f200000.gpio, pinctrl-bcm2835:\n gpio-18   (                      | sysfs                )  out hi\n gpio-24   (                      | sysfs                )  out hi\n gpio-25   (                      | sysfs                )  out hi\n gpio-26   (                      | sysfs                )  out hi  If  sysfs  above is replaced with  w1 , use raspi-config to disable the 1-Wire interface.  sudo raspi-config  Inside raspi-config, navigate to  Interfacing Options     1-Wire     NO .", 
            "title": "Check Raspberry Pi GPIO"
        }, 
        {
            "location": "/matrix-voice/troubleshooting/#hardware-tests", 
            "text": "These tests will check if your MATRIX Voice is functioning properly.  We first need to install matrixio-creator-init, which handles the flashing of FPGA.  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the MATRIX init package.  sudo apt-get install matrixio-creator-init  Reboot your device.  sudo reboot", 
            "title": "Hardware Tests"
        }, 
        {
            "location": "/matrix-voice/troubleshooting/#matrix-init-script", 
            "text": "After the reboot, run the matrix init script manually.  sudo /usr/share/matrixlabs/matrixio-devices/matrix-init.bash  You should receive the following.  *** MATRIX Voice has a updated firmware\n*** MATRIX Voice initial process has been launched", 
            "title": "Matrix Init Script"
        }, 
        {
            "location": "/matrix-voice/troubleshooting/#fpga-info", 
            "text": "This program checks the fpga info.  sudo /usr/share/matrixlabs/matrixio-devices/fpga_info  You should receive the following.  INFO:  [ /dev/spidev0.0 ]  was opened\nFPGA  IDENTIFY   =  6032bad2\nFPGA  VERSION   =  1000a  If you have the matrixio-kernel-modules installed, you should receive this instead.  INFO:  [ /dev/matrixio_regmap ]  was opened\nFPGA  IDENTIFY   =  6032bad2\nFPGA  VERSION   =  1000a", 
            "title": "FPGA Info"
        }, 
        {
            "location": "/matrix-voice/troubleshooting/#fpga-flash", 
            "text": "If you don\u2019t get the proper FPGA info you will need to run the FPGA flashing process.  cd  /usr/share/matrixlabs/matrixio-devices/\nsudo ./fpga-program.bash  You should receive the following.  *** MATRIX Voice has a updated firmware  If you get  **** Could not program FPGA , please  contact us .", 
            "title": "FPGA Flash"
        }, 
        {
            "location": "/matrix-voice/troubleshooting/#test-other-components", 
            "text": "Install MATRIX HAL  and test other components such as the microphone array using the  MATRIX HAL examples .", 
            "title": "Test Other Components"
        }, 
        {
            "location": "/matrix-lite/overview/", 
            "text": "MATRIX Lite\n\n\n\nMATRIX Lite is a series of libraries for exposing \nMATRIX HAL\n to other languages. These libraries are built with a native C/C++ extension or a \n\nSWIG interface\n. We currently support JavaScript, Python, Go, and Ruby.\n\n\nGetting Started\n\n\nLearn how to install MATRIX Lite with either JavaScript, Python or Golang.\n\n\nReference\n\n\nLook over the MATRIX Lite functions to learn how to program with your MATRIX device.\n\n\n\n\nJavaScript Reference\n\n\nPython Reference\n\n\nGo Reference\n\n\nRuby Reference\n \n[Under Development]\n\n\n\n\nContributing\n\n\nHelp improve our libraries by submitting issues \n pull requests to our GitHub repositories.\n\n\n\n\n\n\nmatrix-lite-js\n: Node.js addon for calling MATRIX HAL.\n\n\n\n\n\n\nmatrix-lite-go\n: Go package for calling MATRIX HAL.\n\n\n\n\n\n\nmatrix-hal-swig\n: A \nSWIG\n interface to expose MATRIX HAL for multiple languages.\n\n\n\n\n\n\nmatrix-lite-py\n: SWIG implementation compiled and abstracted for Python. \n\n\n\n\n\n\nmatrix-lite-rb\n: SWIG implementation compiled for Ruby.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/overview/#getting-started", 
            "text": "Learn how to install MATRIX Lite with either JavaScript, Python or Golang.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/matrix-lite/overview/#reference", 
            "text": "Look over the MATRIX Lite functions to learn how to program with your MATRIX device.   JavaScript Reference  Python Reference  Go Reference  Ruby Reference   [Under Development]", 
            "title": "Reference"
        }, 
        {
            "location": "/matrix-lite/overview/#contributing", 
            "text": "Help improve our libraries by submitting issues   pull requests to our GitHub repositories.    matrix-lite-js : Node.js addon for calling MATRIX HAL.    matrix-lite-go : Go package for calling MATRIX HAL.    matrix-hal-swig : A  SWIG  interface to expose MATRIX HAL for multiple languages.    matrix-lite-py : SWIG implementation compiled and abstracted for Python.     matrix-lite-rb : SWIG implementation compiled for Ruby.", 
            "title": "Contributing"
        }, 
        {
            "location": "/matrix-lite/getting-started/", 
            "text": "Programming Languages\n\n\nJavaScript Setup\n\n\n\nLearn how to install and setup Node.js with MATRIX Lite.\n\n\nPython Setup\n\n\n\nLearn how to install and setup Python 3 with MATRIX Lite.\n\n\nGo Setup\n\n\n\nLearn how to install and setup Go with MATRIX Lite.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-lite/getting-started/#programming-languages", 
            "text": "", 
            "title": "Programming Languages"
        }, 
        {
            "location": "/matrix-lite/getting-started/javascript/", 
            "text": "Prerequisite MATRIX HAL\n\n\n\n\n\n\n\n\nMake sure you have installed \nMATRIX HAL\n, before continuing.\n\n\n\n\nJavaScript Setup\n\n\nInstall Node.js\n\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh \n|\n bash\n. ~/.bashrc\nnvm install node\n\n\n\nCreate a project folder.\n\nmkdir lite_js\n\ncd\n lite_js\nnpm init -y\ntouch index.js\n\n\n\nDownload the matrix-lite-js package.\n\nnpm install @matrix-io/matrix-lite --save\n\n\n\nCreating An Application\n\n\nCopy our Hello World example below into \nindex.js\n to test your installation.\n\n\nconst\n \nmatrix\n \n=\n \nrequire\n(\n@matrix-io/matrix-lite\n)\n\n\n\nlet\n \neverloop\n \n=\n \nnew\n \nArray\n(\nmatrix\n.\nled\n.\nlength\n);\n\n\n\nlet\n \nledAdjust\n \n=\n \n0.0\n;\n\n\nif\n \n(\neverloop\n.\nlength\n \n==\n \n35\n)\n \n{\n\n    \nledAdjust\n \n=\n \n0.51\n;\n \n// MATRIX Creator\n\n\n}\n \nelse\n \n{\n\n    \nledAdjust\n \n=\n \n1.01\n;\n \n// MATRIX Voice\n\n\n}\n\n\n\nlet\n \nfrequency\n \n=\n \n0.375\n;\n\n\nlet\n \ncounter\n \n=\n \n0.0\n;\n\n\nlet\n \ntick\n \n=\n \neverloop\n.\nlength\n \n-\n \n1\n;\n\n\n\nsetInterval\n(()=\n{\n\n    \n// Create rainbow\n\n    \nfor\n(\ni\n \n=\n \n0\n;\n \ni\n \n \neverloop\n.\nlength\n;\n \ni\n++\n)\n \n{\n\n        \nlet\n \nled\n \n=\n \n{};\n\n        \nled\n.\nr\n \n=\n \nMath\n.\nround\n(\nMath\n.\nmax\n(\n0\n,\n \n(\nMath\n.\nsin\n(\nfrequency\n*\ncounter\n+\n(\nMath\n.\nPI\n/\n180\n*\n240\n))\n*\n155\n+\n100\n)\n/\n10\n));\n\n        \nled\n.\ng\n \n=\n \nMath\n.\nround\n(\nMath\n.\nmax\n(\n0\n,\n \n(\nMath\n.\nsin\n(\nfrequency\n*\ncounter\n+\n(\nMath\n.\nPI\n/\n180\n*\n120\n))\n*\n155\n+\n100\n)\n/\n10\n));\n\n        \nled\n.\nb\n \n=\n \nMath\n.\nround\n(\nMath\n.\nmax\n(\n0\n,\n \n(\nMath\n.\nsin\n(\nfrequency\n*\ncounter\n)\n*\n155\n+\n100\n)\n/\n10\n));\n\n\n        \ncounter\n \n+=\n \nledAdjust\n;\n\n\n        \neverloop\n[\ni\n]\n \n=\n \nled\n;\n\n    \n};\n\n\n    \n// Slowly show rainbow\n\n    \nif\n \n(\ntick\n \n!=\n \n0\n)\n \n{\n\n        \nfor\n \n(\ni\n \n=\n \ntick\n;\n \ni\n \n \n0\n;\n \ni\n--\n)\n \n{\n\n            \neverloop\n[\ni\n]\n \n=\n \n{};\n\n        \n}\n\n        \ntick\n--\n;\n\n    \n}\n\n\n    \nmatrix\n.\nled\n.\nset\n(\neverloop\n);\n\n\n\n},\n35\n);\n\n\n\n\n\nRunning index.js\n\n\n\nOnce you have \nindex.js\n ready, use the following command to run our rainbow Hello World. \n\nnode index.js\n\n\n\nResult\n\n\n\n\n\n\n\nNext Steps\n\n\nWith your device now setup, you can visit our \nReference\n page to get started with MATRIX Lite.", 
            "title": "Javascript Setup"
        }, 
        {
            "location": "/matrix-lite/getting-started/javascript/#javascript-setup", 
            "text": "Install Node.js curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh  |  bash\n. ~/.bashrc\nnvm install node  Create a project folder. mkdir lite_js cd  lite_js\nnpm init -y\ntouch index.js  Download the matrix-lite-js package. npm install @matrix-io/matrix-lite --save", 
            "title": "JavaScript Setup"
        }, 
        {
            "location": "/matrix-lite/getting-started/javascript/#creating-an-application", 
            "text": "Copy our Hello World example below into  index.js  to test your installation.  const   matrix   =   require ( @matrix-io/matrix-lite )  let   everloop   =   new   Array ( matrix . led . length );  let   ledAdjust   =   0.0 ;  if   ( everloop . length   ==   35 )   { \n     ledAdjust   =   0.51 ;   // MATRIX Creator  }   else   { \n     ledAdjust   =   1.01 ;   // MATRIX Voice  }  let   frequency   =   0.375 ;  let   counter   =   0.0 ;  let   tick   =   everloop . length   -   1 ;  setInterval (()= { \n     // Create rainbow \n     for ( i   =   0 ;   i     everloop . length ;   i ++ )   { \n         let   led   =   {}; \n         led . r   =   Math . round ( Math . max ( 0 ,   ( Math . sin ( frequency * counter + ( Math . PI / 180 * 240 )) * 155 + 100 ) / 10 )); \n         led . g   =   Math . round ( Math . max ( 0 ,   ( Math . sin ( frequency * counter + ( Math . PI / 180 * 120 )) * 155 + 100 ) / 10 )); \n         led . b   =   Math . round ( Math . max ( 0 ,   ( Math . sin ( frequency * counter ) * 155 + 100 ) / 10 )); \n\n         counter   +=   ledAdjust ; \n\n         everloop [ i ]   =   led ; \n     }; \n\n     // Slowly show rainbow \n     if   ( tick   !=   0 )   { \n         for   ( i   =   tick ;   i     0 ;   i -- )   { \n             everloop [ i ]   =   {}; \n         } \n         tick -- ; \n     } \n\n     matrix . led . set ( everloop );  }, 35 );", 
            "title": "Creating An Application"
        }, 
        {
            "location": "/matrix-lite/getting-started/javascript/#next-steps", 
            "text": "With your device now setup, you can visit our  Reference  page to get started with MATRIX Lite.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-lite/getting-started/python/", 
            "text": "Prerequisite MATRIX HAL\n\n\n\n\n\n\n\n\nMake sure you have installed \nMATRIX HAL\n, before continuing.\n\n\n\n\nPython Setup\n\n\nInstall the PIP3 package manager.\n\nsudo apt-get install python3-pip\n\n\n\nUpgrade PIP3.\n\npython3\n \n-\nm\n \npip\n \ninstall\n \n--upgrade pip\n\n\n\n\nCreate a project folder.\n\nmkdir lite_py\n\ncd\n lite_py\ntouch app.py\n\n\n\nDownload the matrix-lite-py package. Note that the module to import is called \nmatrix_lite\n.\n\nsudo python3 -m pip install matrix-lite\n\n\n\nCreating An Application\n\n\nCopy our Hello World example below into \napp.py\n to test your installation.\n\n\nfrom\n \nmatrix_lite\n \nimport\n \nled\n\n\nfrom\n \ntime\n \nimport\n \nsleep\n\n\nfrom\n \nmath\n \nimport\n \npi\n,\n \nsin\n\n\n\neverloop\n \n=\n \n[\nblack\n]\n \n*\n \nled\n.\nlength\n\n\n\nledAdjust\n \n=\n \n0.0\n\n\nif\n \nlen\n(\neverloop\n)\n \n==\n \n35\n:\n\n    \nledAdjust\n \n=\n \n0.51\n \n# MATRIX Creator\n\n\nelse\n:\n\n    \nledAdjust\n \n=\n \n1.01\n \n# MATRIX Voice\n\n\n\nfrequency\n \n=\n \n0.375\n\n\ncounter\n \n=\n \n0.0\n\n\ntick\n \n=\n \nlen\n(\neverloop\n)\n \n-\n \n1\n\n\n\nwhile\n \nTrue\n:\n\n    \n# Create rainbow\n\n    \nfor\n \ni\n \nin\n \nrange\n(\nlen\n(\neverloop\n)):\n\n        \nr\n \n=\n \nround\n(\nmax\n(\n0\n,\n \n(\nsin\n(\nfrequency\n*\ncounter\n+\n(\npi\n/\n180\n*\n240\n))\n*\n155\n+\n100\n)\n/\n10\n))\n\n        \ng\n \n=\n \nround\n(\nmax\n(\n0\n,\n \n(\nsin\n(\nfrequency\n*\ncounter\n+\n(\npi\n/\n180\n*\n120\n))\n*\n155\n+\n100\n)\n/\n10\n))\n\n        \nb\n \n=\n \nround\n(\nmax\n(\n0\n,\n \n(\nsin\n(\nfrequency\n*\ncounter\n)\n*\n155\n+\n100\n)\n/\n10\n))\n\n\n        \ncounter\n \n+=\n \nledAdjust\n\n\n        \neverloop\n[\ni\n]\n \n=\n \n{\nr\n:\nr\n,\n \ng\n:\ng\n,\n \nb\n:\nb\n}\n\n\n    \n# Slowly show rainbow\n\n    \nif\n \ntick\n \n!=\n \n0\n:\n\n        \nfor\n \ni\n \nin\n \nreversed\n(\nrange\n(\ntick\n)):\n\n            \neverloop\n[\ni\n]\n \n=\n \n{}\n\n        \ntick\n \n-=\n \n1\n\n\n    \nled\n.\nset\n(\neverloop\n)\n\n\n    \nsleep\n(\n.\n035\n)\n\n\n\n\n\nRunning app.py\n\n\n\nOnce you have \napp.py\n ready, use the following command to run our rainbow Hello World. \n\npython3 app.py\n\n\n\nResult\n\n\n\n\n\n\n\nNext Steps\n\n\nWith your device now setup, you can visit our \nReference\n page to get started with MATRIX Lite.", 
            "title": "Python Setup"
        }, 
        {
            "location": "/matrix-lite/getting-started/python/#python-setup", 
            "text": "Install the PIP3 package manager. sudo apt-get install python3-pip  Upgrade PIP3. python3   - m   pip   install   --upgrade pip   Create a project folder. mkdir lite_py cd  lite_py\ntouch app.py  Download the matrix-lite-py package. Note that the module to import is called  matrix_lite . sudo python3 -m pip install matrix-lite", 
            "title": "Python Setup"
        }, 
        {
            "location": "/matrix-lite/getting-started/python/#creating-an-application", 
            "text": "Copy our Hello World example below into  app.py  to test your installation.  from   matrix_lite   import   led  from   time   import   sleep  from   math   import   pi ,   sin  everloop   =   [ black ]   *   led . length  ledAdjust   =   0.0  if   len ( everloop )   ==   35 : \n     ledAdjust   =   0.51   # MATRIX Creator  else : \n     ledAdjust   =   1.01   # MATRIX Voice  frequency   =   0.375  counter   =   0.0  tick   =   len ( everloop )   -   1  while   True : \n     # Create rainbow \n     for   i   in   range ( len ( everloop )): \n         r   =   round ( max ( 0 ,   ( sin ( frequency * counter + ( pi / 180 * 240 )) * 155 + 100 ) / 10 )) \n         g   =   round ( max ( 0 ,   ( sin ( frequency * counter + ( pi / 180 * 120 )) * 155 + 100 ) / 10 )) \n         b   =   round ( max ( 0 ,   ( sin ( frequency * counter ) * 155 + 100 ) / 10 )) \n\n         counter   +=   ledAdjust \n\n         everloop [ i ]   =   { r : r ,   g : g ,   b : b } \n\n     # Slowly show rainbow \n     if   tick   !=   0 : \n         for   i   in   reversed ( range ( tick )): \n             everloop [ i ]   =   {} \n         tick   -=   1 \n\n     led . set ( everloop ) \n\n     sleep ( . 035 )", 
            "title": "Creating An Application"
        }, 
        {
            "location": "/matrix-lite/getting-started/python/#next-steps", 
            "text": "With your device now setup, you can visit our  Reference  page to get started with MATRIX Lite.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-lite/getting-started/go/", 
            "text": "Prerequisite MATRIX HAL\n\n\n\n\n\nMake sure you have installed \nMATRIX HAL\n, before continuing.\n\n\n\n\nGo Setup\n\n\nInstall Go.\n\nsudo apt-get install golang\n\n\n\nCreate a project folder.\n\nmkdir\n \nlite_go\n\n\ncd\n \nlite_go\n\n\ngo\n \nmod\n \ninit\n \nmyapp\n\n\ntouch\n \nmain\n.\ngo\n\n\n\n\nDownload the matrix-lite-go package.\n\ngo get -u github.com/matrix-io/matrix-lite-go\n\n\n\nCreating An Application\n\n\nCopy our Hello World example below into \nmain.go\n to test your installation.\n\n\npackage\n \nmain\n\n\n\nimport\n \n(\n\n    \nmath\n\n    \ntime\n\n\n    \ngithub.com/matrix-io/matrix-lite-go\n\n\n)\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nm\n \n:=\n \nmatrix\n.\nInit\n()\n\n    \neverloop\n \n:=\n \nmake\n([]\nmatrix\n.\nRGBW\n,\n \nm\n.\nLed\n.\nLength\n)\n\n\n    \nledAdjust\n \n:=\n \n0.0\n\n    \nif\n \nlen\n(\neverloop\n)\n \n==\n \n35\n \n{\n\n        \nledAdjust\n \n=\n \n0.51\n \n// MATRIX Creator\n\n    \n}\n \nelse\n \n{\n\n        \nledAdjust\n \n=\n \n1.01\n \n// MATRIX Voice\n\n    \n}\n\n\n    \nfrequency\n \n:=\n \n0.375\n\n    \ncounter\n \n:=\n \n0.0\n\n    \ntick\n \n:=\n \nlen\n(\neverloop\n)\n \n-\n \n1\n\n\n    \nfor\n \n{\n\n\n        \n// Create rainbow\n\n        \nfor\n \ni\n,\n \nled\n \n:=\n \nrange\n \neverloop\n \n{\n\n            \nled\n.\nR\n \n=\n \nuint8\n(\nmath\n.\nMax\n(\n0\n,\n \n(\nmath\n.\nSin\n(\nfrequency\n*\ncounter\n+\n(\nmath\n.\nPi\n/\n180\n*\n240\n))\n*\n155\n+\n100\n)\n/\n10\n))\n\n            \nled\n.\nG\n \n=\n \nuint8\n(\nmath\n.\nMax\n(\n0\n,\n \n(\nmath\n.\nSin\n(\nfrequency\n*\ncounter\n+\n(\nmath\n.\nPi\n/\n180\n*\n120\n))\n*\n155\n+\n100\n)\n/\n10\n))\n\n            \nled\n.\nB\n \n=\n \nuint8\n(\nmath\n.\nMax\n(\n0\n,\n \n(\nmath\n.\nSin\n(\nfrequency\n*\ncounter\n)\n*\n155\n+\n100\n)\n/\n10\n))\n\n\n            \ncounter\n \n+=\n \nledAdjust\n\n\n            \neverloop\n[\ni\n]\n \n=\n \nled\n\n        \n}\n\n\n        \n// Slowly show rainbow\n\n        \nif\n \ntick\n \n!=\n \n0\n \n{\n\n            \nfor\n \ni\n \n:=\n \ntick\n;\n \ni\n \n \n0\n;\n \ni\n--\n \n{\n\n                \neverloop\n[\ni\n]\n \n=\n \nmatrix\n.\nRGBW\n{}\n\n            \n}\n\n            \ntick\n--\n\n        \n}\n\n\n        \nm\n.\nLed\n.\nSet\n(\neverloop\n)\n\n        \ntime\n.\nSleep\n(\n35\n \n*\n \ntime\n.\nMillisecond\n)\n\n\n    \n}\n\n\n}\n\n\n\n\n\nRunning main.go\n\n\n\nOnce you have \nmain.go\n ready, use the following command to run our rainbow Hello World. \n\ngo\n \nrun\n \nmain\n.\ngo\n\n\n\n\nResult\n\n\n\n\n\n\n\nNext Steps\n\n\nWith your device now setup, you can visit our \nReference\n page to get started with MATRIX Lite.", 
            "title": "Go Setup"
        }, 
        {
            "location": "/matrix-lite/getting-started/go/#go-setup", 
            "text": "Install Go. sudo apt-get install golang  Create a project folder. mkdir   lite_go  cd   lite_go  go   mod   init   myapp  touch   main . go   Download the matrix-lite-go package. go get -u github.com/matrix-io/matrix-lite-go", 
            "title": "Go Setup"
        }, 
        {
            "location": "/matrix-lite/getting-started/go/#creating-an-application", 
            "text": "Copy our Hello World example below into  main.go  to test your installation.  package   main  import   ( \n     math \n     time \n\n     github.com/matrix-io/matrix-lite-go  )  func   main ()   { \n     m   :=   matrix . Init () \n     everloop   :=   make ([] matrix . RGBW ,   m . Led . Length ) \n\n     ledAdjust   :=   0.0 \n     if   len ( everloop )   ==   35   { \n         ledAdjust   =   0.51   // MATRIX Creator \n     }   else   { \n         ledAdjust   =   1.01   // MATRIX Voice \n     } \n\n     frequency   :=   0.375 \n     counter   :=   0.0 \n     tick   :=   len ( everloop )   -   1 \n\n     for   { \n\n         // Create rainbow \n         for   i ,   led   :=   range   everloop   { \n             led . R   =   uint8 ( math . Max ( 0 ,   ( math . Sin ( frequency * counter + ( math . Pi / 180 * 240 )) * 155 + 100 ) / 10 )) \n             led . G   =   uint8 ( math . Max ( 0 ,   ( math . Sin ( frequency * counter + ( math . Pi / 180 * 120 )) * 155 + 100 ) / 10 )) \n             led . B   =   uint8 ( math . Max ( 0 ,   ( math . Sin ( frequency * counter ) * 155 + 100 ) / 10 )) \n\n             counter   +=   ledAdjust \n\n             everloop [ i ]   =   led \n         } \n\n         // Slowly show rainbow \n         if   tick   !=   0   { \n             for   i   :=   tick ;   i     0 ;   i --   { \n                 everloop [ i ]   =   matrix . RGBW {} \n             } \n             tick -- \n         } \n\n         m . Led . Set ( everloop ) \n         time . Sleep ( 35   *   time . Millisecond ) \n\n     }  }", 
            "title": "Creating An Application"
        }, 
        {
            "location": "/matrix-lite/getting-started/go/#next-steps", 
            "text": "With your device now setup, you can visit our  Reference  page to get started with MATRIX Lite.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-lite/js-reference/", 
            "text": "JavaScript Reference\n\n\nEverloop\n\nInterface for the LED array.\n\n\nSensors\n\n\n\nReading data from the IMU, humidity, UV, and pressure sensors.\n\n\nGPIO\n\n\n\nGeneral Purpose Input/Output.\n\n\nALSA\n\n\n\nAudio management through the use of ALSA.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-lite/js-reference/#javascript-reference", 
            "text": "", 
            "title": "JavaScript Reference"
        }, 
        {
            "location": "/matrix-lite/js-reference/everloop/", 
            "text": "Everloop\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe following sections below will go over how to control the LED array on your MATRIX Device.\n\n\nImport Statement\n\n\nconst\n \nmatrix\n \n=\n \nrequire\n(\n@matrix-io/matrix-lite\n);\n\n\n\n\n\n.length\n\n\nReturns the size of the LED array on your MATRIX device.\n\nmatrix\n.\nled\n.\nlength\n;\n\n\n\n\n.set()\n\n\nAllows you to set the colors of each LED. A \nstring\n, \nobject\n, \narray\n, or an \nundefined\n value can be given to this function.\n\n\nString input\n\n\n// Valid ways to turn LEDs blue\n\n\nmatrix\n.\nled\n.\nset\n(\nblue\n);\n \n// color name\n\n\nmatrix\n.\nled\n.\nset\n(\nrgb(0,0,255)\n);\n \n// RGB values\n\n\nmatrix\n.\nled\n.\nset\n(\n#0000ff\n);\n \n// Hex values\n\n\n\n// Valid ways to turn off LEDs\n\n\nmatrix\n.\nled\n.\nset\n(\nblack\n);\n \n// color name\n\n\nmatrix\n.\nled\n.\nset\n(\nrgb(0,0,0)\n);\n \n// RGB values\n\n\nmatrix\n.\nled\n.\nset\n(\n#000000\n);\n \n// Hex values\n\n\n\n\nObject input\n\n\n// Turn LEDs blue\n\n\nmatrix\n.\nled\n.\nset\n({\n\n  \nr\n:\n0\n,\n\n  \ng\n:\n0\n,\n\n  \nb\n:\n255\n,\n\n  \nw\n:\n0\n\n\n});\n\n\n\n// Turn off LEDs \n\n\nmatrix\n.\nled\n.\nset\n({})\n \n// unspecified values are set to 0\n\n\n\n\nArray Input\n\n\nPassing in an array allows you to set each individual LED color. However, passing an array that's larger than \nled.length\n will result in an error.\n\n// Basic array example\n\n\nmatrix\n.\nled\n.\nset\n([\nred\n,\n \ngold\n,\n \npurple\n,\n \n{},\n \n,\n \n#6F41C1\n,\n \nrgb(0,0,255)\n,\n \n{\ng\n:\n255\n}]);", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-lite/js-reference/everloop/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-lite/js-reference/everloop/#overview", 
            "text": "The following sections below will go over how to control the LED array on your MATRIX Device.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/js-reference/everloop/#import-statement", 
            "text": "const   matrix   =   require ( @matrix-io/matrix-lite );", 
            "title": "Import Statement"
        }, 
        {
            "location": "/matrix-lite/js-reference/everloop/#length", 
            "text": "Returns the size of the LED array on your MATRIX device. matrix . led . length ;", 
            "title": ".length"
        }, 
        {
            "location": "/matrix-lite/js-reference/everloop/#set", 
            "text": "Allows you to set the colors of each LED. A  string ,  object ,  array , or an  undefined  value can be given to this function.  String input  // Valid ways to turn LEDs blue  matrix . led . set ( blue );   // color name  matrix . led . set ( rgb(0,0,255) );   // RGB values  matrix . led . set ( #0000ff );   // Hex values  // Valid ways to turn off LEDs  matrix . led . set ( black );   // color name  matrix . led . set ( rgb(0,0,0) );   // RGB values  matrix . led . set ( #000000 );   // Hex values   Object input  // Turn LEDs blue  matrix . led . set ({ \n   r : 0 , \n   g : 0 , \n   b : 255 , \n   w : 0  });  // Turn off LEDs   matrix . led . set ({})   // unspecified values are set to 0   Array Input  Passing in an array allows you to set each individual LED color. However, passing an array that's larger than  led.length  will result in an error. // Basic array example  matrix . led . set ([ red ,   gold ,   purple ,   {},   ,   #6F41C1 ,   rgb(0,0,255) ,   { g : 255 }]);", 
            "title": ".set()"
        }, 
        {
            "location": "/matrix-lite/js-reference/sensors/", 
            "text": "Sensors\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe following sections below will go over how to read \n what to expect from each sensor on the MATRIX Creator.\n\n\nImport Statement\n\n\nconst\n \nmatrix\n \n=\n \nrequire\n(\n@matrix-io/matrix-lite\n);\n\n\n\n\n\n\nReading Sensor Data\n\n\nSensor data can be read by calling \n.read()\n on a sensor object. This returns an object with the current sensor's values. Below are examples on how to call each sensor and what information to expect.\n\n\n\n\n\n\nIMU\n\n\nmatrix\n.\nimu\n.\nread\n();\n\n\n\n// Example imu.read() output //\n\n\n{\n \n  \naccel_x\n:\n \n0.0020000000949949026\n,\n\n  \naccel_y\n:\n \n0.004999999888241291\n,\n\n  \naccel_z\n:\n \n0.9819999933242798\n,\n\n  \ngyro_x\n:\n  \n0.7770000100135803\n,\n\n  \ngyro_y\n:\n  \n-\n0.2460000067949295\n,\n\n  \ngyro_z\n:\n  \n0.7250000238418579\n,\n\n  \nyaw\n:\n     \n-\n177.40724182128906\n,\n\n  \npitch\n:\n   \n-\n0.11669033765792847\n,\n\n  \nroll\n:\n    \n0.2917275130748749\n,\n\n  \nmag_x\n:\n   \n0.5299999713897705\n,\n\n  \nmag_y\n:\n   \n-\n0.024000000208616257\n,\n\n  \nmag_z\n:\n   \n-\n0.05999999865889549\n \n\n}\n\n\n\n\n\n\nUV\n\n\nmatrix\n.\nuv\n.\nread\n();\n\n\n\n// Example uv.read() output //\n\n\n{\n\n  \nuv\n:\n \n0.013000000268220901\n \n\n}\n\n\n\n\n\n\nHumidity\n\n\nmatrix\n.\nhumidity\n.\nread\n();\n\n\n\n// Example humidity.read() output //\n\n\n{\n \n  \nhumidity\n:\n    \n29.04400062561035\n,\n \n  \ntemperature\n:\n \n33.279998779296875\n \n\n}\n\n\n\n\n\n\nPressure\n\n\nmatrix\n.\npressure\n.\nread\n();\n\n\n\n// Example pressure.read() output //\n\n\n{\n \n  \naltitude\n:\n    \n-\n47.4370002746582\n,\n\n  \npressure\n:\n    \n101896\n,\n\n  \ntemperature\n:\n \n32.9370002746582\n \n\n}", 
            "title": "Sensors"
        }, 
        {
            "location": "/matrix-lite/js-reference/sensors/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-lite/js-reference/sensors/#overview", 
            "text": "The following sections below will go over how to read   what to expect from each sensor on the MATRIX Creator.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/js-reference/sensors/#import-statement", 
            "text": "const   matrix   =   require ( @matrix-io/matrix-lite );", 
            "title": "Import Statement"
        }, 
        {
            "location": "/matrix-lite/js-reference/sensors/#reading-sensor-data", 
            "text": "Sensor data can be read by calling  .read()  on a sensor object. This returns an object with the current sensor's values. Below are examples on how to call each sensor and what information to expect.    IMU  matrix . imu . read ();  // Example imu.read() output //  {  \n   accel_x :   0.0020000000949949026 , \n   accel_y :   0.004999999888241291 , \n   accel_z :   0.9819999933242798 , \n   gyro_x :    0.7770000100135803 , \n   gyro_y :    - 0.2460000067949295 , \n   gyro_z :    0.7250000238418579 , \n   yaw :       - 177.40724182128906 , \n   pitch :     - 0.11669033765792847 , \n   roll :      0.2917275130748749 , \n   mag_x :     0.5299999713897705 , \n   mag_y :     - 0.024000000208616257 , \n   mag_z :     - 0.05999999865889549   }    UV  matrix . uv . read ();  // Example uv.read() output //  { \n   uv :   0.013000000268220901   }    Humidity  matrix . humidity . read ();  // Example humidity.read() output //  {  \n   humidity :      29.04400062561035 ,  \n   temperature :   33.279998779296875   }    Pressure  matrix . pressure . read ();  // Example pressure.read() output //  {  \n   altitude :      - 47.4370002746582 , \n   pressure :      101896 , \n   temperature :   32.9370002746582   }", 
            "title": "Reading Sensor Data"
        }, 
        {
            "location": "/matrix-lite/js-reference/gpio/", 
            "text": "GPIO\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe following sections below will go over how to utilize the GPIO on your MATRIX Device.\n\n\nImport Statement\n\n\nconst\n \nmatrix\n \n=\n \nrequire\n(\n@matrix-io/matrix-lite\n);\n\n\n\n\n\n.setFunction()\n\n\nSpecify if a GPIO pin is being used for \nDIGITAL\n or \nPWM\n.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\nfunction\n: Can be \n0\n,\n1\n or \n\"DIGITAL\"\n, \n\"PWM\"\n respectively.\n\n\n\n\n// Valid ways of setting pin 0 as a digital pin\n\n\nmatrix\n.\ngpio\n.\nsetFunction\n(\n0\n,\n \nDIGITAL\n);\n\n\nmatrix\n.\ngpio\n.\nsetFunction\n(\n0\n,\n \n0\n);\n\n\n\n// Valid ways of setting pin 1 as a PWM pin\n\n\nmatrix\n.\ngpio\n.\nsetFunction\n(\n1\n,\n \nPWM\n);\n\n\nmatrix\n.\ngpio\n.\nsetFunction\n(\n1\n,\n \n1\n);\n\n\n\n\n\n.setMode()\n\n\nSpecify if a GPIO pin is being used for \ninput\n or \noutput\n.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\nmode\n: Can be \n0\n,\n1\n or \n\"input\"\n, \n\"output\"\n respectively.\n\n// Valid ways of setting pin 0 to receive input\n\n\nmatrix\n.\ngpio\n.\nsetMode\n(\n0\n,\n \ninput\n);\n\n\nmatrix\n.\ngpio\n.\nsetMode\n(\n0\n,\n \n0\n);\n\n\n\n// Valid ways of setting pin 1 to allow output\n\n\nmatrix\n.\ngpio\n.\nsetMode\n(\n1\n,\n \noutput\n);\n\n\nmatrix\n.\ngpio\n.\nsetMode\n(\n1\n,\n \n1\n);\n\n\n\n\n\n\n.getDigital()\n\n\nRetrieve the current digital signal of a GPIO pin.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\n\n\nReturn Value:\n\n\n\n\nvalue\n: \n0\n or \n1\n representing ON/OFF respectively\n\n\n\n\n// Return the current ON/OFF state of pin 0\n\n\nmatrix\n.\ngpio\n.\ngetDigital\n(\n0\n);\n\n\n\n\n\n.setDigital()\n\n\nSet the current digital signal of a GPIO pin.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\nvalue\n: Can be \n0\n,\n1\n or \n\"OFF\"\n, \n\"ON\"\n respectively\n\n\n\n\n// Valid ways of setting pin 0 to OFF\n\n\nmatrix\n.\ngpio\n.\nsetDigital\n(\n0\n,\nOFF\n);\n\n\nmatrix\n.\ngpio\n.\nsetDigital\n(\n0\n,\n0\n);\n\n\n\n// Valid ways of setting pin 1 to ON\n\n\nmatrix\n.\ngpio\n.\nsetDigital\n(\n1\n,\nON\n);\n\n\nmatrix\n.\ngpio\n.\nsetDigital\n(\n1\n,\n1\n);\n\n\n\n\n\n.setPWM()\n\n\nSet the current PWM signal of a GPIO pin.\n\n\nParameters:\n\n\n\n\nconfig: \nobject\n\n\npin\n: Any number from 0 to 15.\n\n\npercentage\n: Any number from 0 to 100.\n\n\nfrequency\n: Any number from 36 to \nmax value not tested\n.\n\n// Set PWM for pin 0\n\n\nmatrix\n.\ngpio\n.\nsetPWM\n({\n\n  \npin\n:\n \n0\n,\n\n  \npercentage\n:\n \n25\n,\n\n  \nfrequency\n:\n \n50\n\n\n});\n\n\n\n\n\n\n\n\n\n\n.setServoAngle()\n\n\nUse a GPIO pin to control a servo. This function requires the pin to be set to \n\"PWM\"\n mode.\n\n\nParameters:\n\n\n\n\nconfig: \nobject\n\n\npin\n: Any number from 0 to 15.\n\n\nangle\n: Positive number of degrees.\n\n\nmin_pulse_ms\n: Generally numbers between 0 and 2.\n\n\nminimum pulse width for a PWM wave in milliseconds\n\n// Sets Servo to 90 Degrees with pin 0\n\n\nmatrix\n.\ngpio\n.\nsetServoAngle\n({\n\n  \npin\n:\n \n0\n,\n\n  \nangle\n:\n \n90\n,\n\n  \nmin_pulse_ms\n:\n \n0.8\n\n\n});", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-lite/js-reference/gpio/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-lite/js-reference/gpio/#overview", 
            "text": "The following sections below will go over how to utilize the GPIO on your MATRIX Device.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/js-reference/gpio/#import-statement", 
            "text": "const   matrix   =   require ( @matrix-io/matrix-lite );", 
            "title": "Import Statement"
        }, 
        {
            "location": "/matrix-lite/js-reference/gpio/#setfunction", 
            "text": "Specify if a GPIO pin is being used for  DIGITAL  or  PWM .  Parameters:   pin : Any number from 0 to 15.  function : Can be  0 , 1  or  \"DIGITAL\" ,  \"PWM\"  respectively.   // Valid ways of setting pin 0 as a digital pin  matrix . gpio . setFunction ( 0 ,   DIGITAL );  matrix . gpio . setFunction ( 0 ,   0 );  // Valid ways of setting pin 1 as a PWM pin  matrix . gpio . setFunction ( 1 ,   PWM );  matrix . gpio . setFunction ( 1 ,   1 );", 
            "title": ".setFunction()"
        }, 
        {
            "location": "/matrix-lite/js-reference/gpio/#setmode", 
            "text": "Specify if a GPIO pin is being used for  input  or  output .  Parameters:   pin : Any number from 0 to 15.  mode : Can be  0 , 1  or  \"input\" ,  \"output\"  respectively. // Valid ways of setting pin 0 to receive input  matrix . gpio . setMode ( 0 ,   input );  matrix . gpio . setMode ( 0 ,   0 );  // Valid ways of setting pin 1 to allow output  matrix . gpio . setMode ( 1 ,   output );  matrix . gpio . setMode ( 1 ,   1 );", 
            "title": ".setMode()"
        }, 
        {
            "location": "/matrix-lite/js-reference/gpio/#getdigital", 
            "text": "Retrieve the current digital signal of a GPIO pin.  Parameters:   pin : Any number from 0 to 15.   Return Value:   value :  0  or  1  representing ON/OFF respectively   // Return the current ON/OFF state of pin 0  matrix . gpio . getDigital ( 0 );", 
            "title": ".getDigital()"
        }, 
        {
            "location": "/matrix-lite/js-reference/gpio/#setdigital", 
            "text": "Set the current digital signal of a GPIO pin.  Parameters:   pin : Any number from 0 to 15.  value : Can be  0 , 1  or  \"OFF\" ,  \"ON\"  respectively   // Valid ways of setting pin 0 to OFF  matrix . gpio . setDigital ( 0 , OFF );  matrix . gpio . setDigital ( 0 , 0 );  // Valid ways of setting pin 1 to ON  matrix . gpio . setDigital ( 1 , ON );  matrix . gpio . setDigital ( 1 , 1 );", 
            "title": ".setDigital()"
        }, 
        {
            "location": "/matrix-lite/js-reference/gpio/#setpwm", 
            "text": "Set the current PWM signal of a GPIO pin.  Parameters:   config:  object  pin : Any number from 0 to 15.  percentage : Any number from 0 to 100.  frequency : Any number from 36 to  max value not tested . // Set PWM for pin 0  matrix . gpio . setPWM ({ \n   pin :   0 , \n   percentage :   25 , \n   frequency :   50  });", 
            "title": ".setPWM()"
        }, 
        {
            "location": "/matrix-lite/js-reference/gpio/#setservoangle", 
            "text": "Use a GPIO pin to control a servo. This function requires the pin to be set to  \"PWM\"  mode.  Parameters:   config:  object  pin : Any number from 0 to 15.  angle : Positive number of degrees.  min_pulse_ms : Generally numbers between 0 and 2.  minimum pulse width for a PWM wave in milliseconds // Sets Servo to 90 Degrees with pin 0  matrix . gpio . setServoAngle ({ \n   pin :   0 , \n   angle :   90 , \n   min_pulse_ms :   0.8  });", 
            "title": ".setServoAngle()"
        }, 
        {
            "location": "/matrix-lite/js-reference/alsa/", 
            "text": "ALSA\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\n\n\nRequires you to have the \nMATRIX Kernel Modules\n installed.\n\n\n\n\nThe following sections below will go over how to retrieve microphone input through ALSA.\n\n\nImport Statement\n\n\nconst\n \nmatrix\n \n=\n \nrequire\n(\n@matrix-io/matrix-lite\n);\n\n\n\n\n\n\n.mic\n\n\nThis function will allow you to configure your MATRIX microphone settings. Default values will be used if no configuration was given. \n\n\n\n\nconfig: \nobject\n\n\nrate\n: Any number from 0 to 15.\n\n\ndebug\n: true or false.\n\n\nexitOnSilence\n: number of seconds.\n\n\nchannels\n: Any number from 1 to 8.\n\n\n\n\n\n\n\n\nvar\n \nmic\n \n=\n \nmatrix\n.\nalsa\n.\nmic\n();\n\n\n// or\n\n\nvar\n \nmic\n \n=\n \nmatrix\n.\nalsa\n.\nmic\n({\n\n  \nrate\n:\n \n16000\n,\n\n  \ndebug\n:\n \ntrue\n,\n\n  \nexitOnSilence\n:\n \n6\n,\n\n  \nchannels\n:\n \n1\n\n\n});\n\n\n\n\n\nOnce the microphone is setup, visit \nnpm mic page\n to see what functions \n event listeners are available. This package is included in MATRIX Lite.", 
            "title": "ALSA"
        }, 
        {
            "location": "/matrix-lite/js-reference/alsa/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-lite/js-reference/alsa/#overview", 
            "text": "Requires you to have the  MATRIX Kernel Modules  installed.   The following sections below will go over how to retrieve microphone input through ALSA.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/js-reference/alsa/#import-statement", 
            "text": "const   matrix   =   require ( @matrix-io/matrix-lite );", 
            "title": "Import Statement"
        }, 
        {
            "location": "/matrix-lite/js-reference/alsa/#mic", 
            "text": "This function will allow you to configure your MATRIX microphone settings. Default values will be used if no configuration was given.    config:  object  rate : Any number from 0 to 15.  debug : true or false.  exitOnSilence : number of seconds.  channels : Any number from 1 to 8.     var   mic   =   matrix . alsa . mic ();  // or  var   mic   =   matrix . alsa . mic ({ \n   rate :   16000 , \n   debug :   true , \n   exitOnSilence :   6 , \n   channels :   1  });   Once the microphone is setup, visit  npm mic page  to see what functions   event listeners are available. This package is included in MATRIX Lite.", 
            "title": ".mic"
        }, 
        {
            "location": "/matrix-lite/py-reference/", 
            "text": "Python Reference\n\n\nEverloop\n\nInterface for the LED array.\n\n\nSensors\n\n\n\nReading data from the IMU, humidity, UV, and pressure sensors.\n\n\nGPIO\n\n\n\nGeneral Purpose Input/Output.\n\n\nALSA Microphones\n\n\n\nReading microphone data through ALSA.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-lite/py-reference/#python-reference", 
            "text": "", 
            "title": "Python Reference"
        }, 
        {
            "location": "/matrix-lite/py-reference/everloop/", 
            "text": "Everloop\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe following sections below will go over how to control the LED array on your MATRIX Device.\n\n\nImport Statement\n\n\nfrom\n \nmatrix_lite\n \nimport\n \nled\n\n\n\n\n\n.length\n\n\nReturns the size of the LED array on your MATRIX device.\n\nled\n.\nlength\n\n\n\n\n.set()\n\n\nAllows you to set the colors of each LED. A \nstring\n, \nobject\n, \ntuple\n, or \narray\n can be given to this function.\n\n\nString input\n\n\n# Sets each LED to blue\n\n\nled\n.\nset\n(\nblue\n)\n# color name\n\n\nled\n.\nset\n(\n#0000ff\n)\n# Hex values\n\n\n\n# Turns off each LED\n\n\nled\n.\nset\n(\nblack\n)\n \n# color name\n\n\nled\n.\nset\n(\n#000000\n)\n \n# Hex values\n\n\n\n\nObject input\n\n\n# Sets each LED to blue\n\n\nled\n.\nset\n({\nr\n:\n \n0\n,\n \ng\n:\n \n0\n,\n \nb\n:\n \n255\n,\n \nw\n:\n \n0\n})\n\n\nled\n.\nset\n({\nb\n:\n \n255\n})\n\n\n\n# Turns off each LED\n\n\nled\n.\nset\n({})\n\n\n\n\nTuple input\n\n\n# Sets each LED to blue\n\n\nled\n.\nset\n((\n0\n,\n0\n,\n255\n,\n0\n))\n \n# Each RGBW value in a tuple must be defined\n\n\n\n# Turns off each LED\n\n\nled\n.\nset\n((\n0\n,\n0\n,\n0\n,\n0\n))\n\n\n\n\nArray Input\n\n\nPassing in an array allows you to set each individual LED color. However, passing an array that's larger than \nled.length\n will result in an error.\n\n# Basic array example\n\n\nled\n.\nset\n([\nred\n,\n \ngold\n,\n \n(\n255\n,\n0\n,\n255\n,\n0\n),\n \n{},\n \nblack\n,\n \n#6F41C1\n,\n \nblue\n,\n \n{\ng\n:\n255\n}])", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-lite/py-reference/everloop/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-lite/py-reference/everloop/#overview", 
            "text": "The following sections below will go over how to control the LED array on your MATRIX Device.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/py-reference/everloop/#import-statement", 
            "text": "from   matrix_lite   import   led", 
            "title": "Import Statement"
        }, 
        {
            "location": "/matrix-lite/py-reference/everloop/#length", 
            "text": "Returns the size of the LED array on your MATRIX device. led . length", 
            "title": ".length"
        }, 
        {
            "location": "/matrix-lite/py-reference/everloop/#set", 
            "text": "Allows you to set the colors of each LED. A  string ,  object ,  tuple , or  array  can be given to this function.  String input  # Sets each LED to blue  led . set ( blue ) # color name  led . set ( #0000ff ) # Hex values  # Turns off each LED  led . set ( black )   # color name  led . set ( #000000 )   # Hex values   Object input  # Sets each LED to blue  led . set ({ r :   0 ,   g :   0 ,   b :   255 ,   w :   0 })  led . set ({ b :   255 })  # Turns off each LED  led . set ({})   Tuple input  # Sets each LED to blue  led . set (( 0 , 0 , 255 , 0 ))   # Each RGBW value in a tuple must be defined  # Turns off each LED  led . set (( 0 , 0 , 0 , 0 ))   Array Input  Passing in an array allows you to set each individual LED color. However, passing an array that's larger than  led.length  will result in an error. # Basic array example  led . set ([ red ,   gold ,   ( 255 , 0 , 255 , 0 ),   {},   black ,   #6F41C1 ,   blue ,   { g : 255 }])", 
            "title": ".set()"
        }, 
        {
            "location": "/matrix-lite/py-reference/sensors/", 
            "text": "Sensors\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe following sections below will go over how to read \n what to expect from each sensor on the MATRIX Creator.\n\n\nImport Statement\n\n\nfrom\n \nmatrix_lite\n \nimport\n \nsensors\n\n\n\n\n\n\nReading Sensor Data\n\n\nSensor data can be read by calling \n.read()\n on a sensor object. This returns an object with the current sensor's values. Below are examples on how to call each sensor and what information to expect.\n\n\n\n\n\n\nIMU\n\n\nsensors\n.\nimu\n.\nread\n()\n\n\n\n## Example imu.read() output ##\n\n\n{\n \n  \naccel_x\n:\n \n0.0020000000949949026\n,\n\n  \naccel_y\n:\n \n0.004999999888241291\n,\n\n  \naccel_z\n:\n \n0.9819999933242798\n,\n\n  \ngyro_x\n:\n  \n0.7770000100135803\n,\n\n  \ngyro_y\n:\n  \n-\n0.2460000067949295\n,\n\n  \ngyro_z\n:\n  \n0.7250000238418579\n,\n\n  \nyaw\n:\n     \n-\n177.40724182128906\n,\n\n  \npitch\n:\n   \n-\n0.11669033765792847\n,\n\n  \nroll\n:\n    \n0.2917275130748749\n,\n\n  \nmag_x\n:\n   \n0.5299999713897705\n,\n\n  \nmag_y\n:\n   \n-\n0.024000000208616257\n,\n\n  \nmag_z\n:\n   \n-\n0.05999999865889549\n \n\n}\n\n\n\n\n\n\nUV\n\n\nsensors\n.\nuv\n.\nread\n()\n\n\n\n## Example uv.read() output ##\n\n\n{\n \n  \nuv\n:\n \n0.013000000268220901\n \n\n}\n\n\n\n\n\n\nHumidity\n\n\nsensors\n.\nhumidity\n.\nread\n()\n\n\n\n## Example humidity.read() output ##\n\n\n{\n \n  \nhumidity\n:\n    \n29.04400062561035\n,\n \n  \ntemperature\n:\n \n33.279998779296875\n \n\n}\n\n\n\n\n\n\nPressure\n\n\nsensors\n.\npressure\n.\nread\n()\n\n\n\n## Example pressure.read() output ##\n\n\n{\n \n  \naltitude\n:\n    \n-\n47.4370002746582\n,\n\n  \npressure\n:\n    \n101896\n,\n\n  \ntemperature\n:\n \n32.9370002746582\n \n\n}", 
            "title": "Sensors"
        }, 
        {
            "location": "/matrix-lite/py-reference/sensors/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-lite/py-reference/sensors/#overview", 
            "text": "The following sections below will go over how to read   what to expect from each sensor on the MATRIX Creator.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/py-reference/sensors/#import-statement", 
            "text": "from   matrix_lite   import   sensors", 
            "title": "Import Statement"
        }, 
        {
            "location": "/matrix-lite/py-reference/sensors/#reading-sensor-data", 
            "text": "Sensor data can be read by calling  .read()  on a sensor object. This returns an object with the current sensor's values. Below are examples on how to call each sensor and what information to expect.    IMU  sensors . imu . read ()  ## Example imu.read() output ##  {  \n   accel_x :   0.0020000000949949026 , \n   accel_y :   0.004999999888241291 , \n   accel_z :   0.9819999933242798 , \n   gyro_x :    0.7770000100135803 , \n   gyro_y :    - 0.2460000067949295 , \n   gyro_z :    0.7250000238418579 , \n   yaw :       - 177.40724182128906 , \n   pitch :     - 0.11669033765792847 , \n   roll :      0.2917275130748749 , \n   mag_x :     0.5299999713897705 , \n   mag_y :     - 0.024000000208616257 , \n   mag_z :     - 0.05999999865889549   }    UV  sensors . uv . read ()  ## Example uv.read() output ##  {  \n   uv :   0.013000000268220901   }    Humidity  sensors . humidity . read ()  ## Example humidity.read() output ##  {  \n   humidity :      29.04400062561035 ,  \n   temperature :   33.279998779296875   }    Pressure  sensors . pressure . read ()  ## Example pressure.read() output ##  {  \n   altitude :      - 47.4370002746582 , \n   pressure :      101896 , \n   temperature :   32.9370002746582   }", 
            "title": "Reading Sensor Data"
        }, 
        {
            "location": "/matrix-lite/py-reference/gpio/", 
            "text": "GPIO\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe following sections below will go over how to utilize the GPIO on your MATRIX Device.\n\n\nImport Statement\n\n\nfrom\n \nmatrix_lite\n \nimport\n \ngpio\n\n\n\n\n\n.setFunction()\n\n\nSpecify if a GPIO pin is being used for \nDIGITAL\n or \nPWM\n.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\nfunction\n: Can be \n0\n,\n1\n or \n\"DIGITAL\"\n, \n\"PWM\"\n respectively.\n\n\n\n\n# Valid ways of setting pin 0 as a digital pin\n\n\ngpio\n.\nsetFunction\n(\n0\n,\n \nDIGITAL\n)\n\n\ngpio\n.\nsetFunction\n(\n0\n,\n \n0\n)\n\n\n\n# Valid ways of setting pin 1 as a PWM pin\n\n\ngpio\n.\nsetFunction\n(\n1\n,\n \nPWM\n)\n\n\ngpio\n.\nsetFunction\n(\n1\n,\n \n1\n)\n\n\n\n\n\n.setMode()\n\n\nSpecify if a GPIO pin is being used for \ninput\n or \noutput\n.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\nmode\n: Can be \n0\n,\n1\n or \n\"input\"\n, \n\"output\"\n respectively.\n\n# Valid ways of setting pin 0 to receive input\n\n\ngpio\n.\nsetMode\n(\n0\n,\n \ninput\n)\n\n\ngpio\n.\nsetMode\n(\n0\n,\n \n0\n)\n\n\n\n# Valid ways of setting pin 1 to allow output\n\n\ngpio\n.\nsetMode\n(\n1\n,\n \noutput\n)\n\n\ngpio\n.\nsetMode\n(\n1\n,\n \n1\n)\n\n\n\n\n\n\n.getDigital()\n\n\nRetrieve the current digital signal of a GPIO pin.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\n\n\nReturn Value:\n\n\n\n\nvalue\n: \n0\n or \n1\n representing ON/OFF respectively\n\n\n\n\n# Return the current ON/OFF state of pin 0\n\n\ngpio\n.\ngetDigital\n(\n0\n)\n\n\n\n\n\n.setDigital()\n\n\nSet the current digital signal of a GPIO pin.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\nvalue\n: Can be \n0\n,\n1\n or \n\"OFF\"\n, \n\"ON\"\n respectively\n\n\n\n\n# Valid ways of setting pin 0 to OFF\n\n\ngpio\n.\nsetDigital\n(\n0\n,\nOFF\n)\n\n\ngpio\n.\nsetDigital\n(\n0\n,\n0\n)\n\n\n\n# Valid ways of setting pin 1 to ON\n\n\ngpio\n.\nsetDigital\n(\n1\n,\nON\n)\n\n\ngpio\n.\nsetDigital\n(\n1\n,\n1\n)\n\n\n\n\n\n.setPWM()\n\n\nSet the current PWM signal of a GPIO pin.\n\n\nParameters:\n\n\n\n\nconfig: \nobject\n\n\npin\n: Any number from 0 to 15.\n\n\npercentage\n: Any number from 0 to 100.\n\n\nfrequency\n: Any number from 36 to \nmax value not tested\n.\n\n# Set PWM for pin 0\n\n\ngpio\n.\nsetPWM\n({\n\n  \npin\n:\n \n0\n,\n\n  \npercentage\n:\n \n25\n,\n\n  \nfrequency\n:\n \n50\n,\n \n# min 36\n\n\n})\n\n\n\n\n\n\n\n\n\n\n.setServoAngle()\n\n\nUse a GPIO pin to control a servo. This function requires the pin to be set to \n\"PWM\"\n mode.\n\n\nParameters:\n\n\n\n\nconfig: \nobject\n\n\npin\n: Any number from 0 to 15.\n\n\nangle\n: Positive number of degrees.\n\n\nmin_pulse_ms\n: Generally numbers between 0 and 2.\n\n\nminimum pulse width for a PWM wave in milliseconds\n\n# Sets Servo to 90 Degrees with pin 0\n\n\ngpio\n.\nsetServoAngle\n({\n\n    \npin\n:\n \n0\n,\n\n    \nangle\n:\n \n90\n,\n\n    \nmin_pulse_ms\n:\n \n0.8\n,\n\n\n})", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-lite/py-reference/gpio/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-lite/py-reference/gpio/#overview", 
            "text": "The following sections below will go over how to utilize the GPIO on your MATRIX Device.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/py-reference/gpio/#import-statement", 
            "text": "from   matrix_lite   import   gpio", 
            "title": "Import Statement"
        }, 
        {
            "location": "/matrix-lite/py-reference/gpio/#setfunction", 
            "text": "Specify if a GPIO pin is being used for  DIGITAL  or  PWM .  Parameters:   pin : Any number from 0 to 15.  function : Can be  0 , 1  or  \"DIGITAL\" ,  \"PWM\"  respectively.   # Valid ways of setting pin 0 as a digital pin  gpio . setFunction ( 0 ,   DIGITAL )  gpio . setFunction ( 0 ,   0 )  # Valid ways of setting pin 1 as a PWM pin  gpio . setFunction ( 1 ,   PWM )  gpio . setFunction ( 1 ,   1 )", 
            "title": ".setFunction()"
        }, 
        {
            "location": "/matrix-lite/py-reference/gpio/#setmode", 
            "text": "Specify if a GPIO pin is being used for  input  or  output .  Parameters:   pin : Any number from 0 to 15.  mode : Can be  0 , 1  or  \"input\" ,  \"output\"  respectively. # Valid ways of setting pin 0 to receive input  gpio . setMode ( 0 ,   input )  gpio . setMode ( 0 ,   0 )  # Valid ways of setting pin 1 to allow output  gpio . setMode ( 1 ,   output )  gpio . setMode ( 1 ,   1 )", 
            "title": ".setMode()"
        }, 
        {
            "location": "/matrix-lite/py-reference/gpio/#getdigital", 
            "text": "Retrieve the current digital signal of a GPIO pin.  Parameters:   pin : Any number from 0 to 15.   Return Value:   value :  0  or  1  representing ON/OFF respectively   # Return the current ON/OFF state of pin 0  gpio . getDigital ( 0 )", 
            "title": ".getDigital()"
        }, 
        {
            "location": "/matrix-lite/py-reference/gpio/#setdigital", 
            "text": "Set the current digital signal of a GPIO pin.  Parameters:   pin : Any number from 0 to 15.  value : Can be  0 , 1  or  \"OFF\" ,  \"ON\"  respectively   # Valid ways of setting pin 0 to OFF  gpio . setDigital ( 0 , OFF )  gpio . setDigital ( 0 , 0 )  # Valid ways of setting pin 1 to ON  gpio . setDigital ( 1 , ON )  gpio . setDigital ( 1 , 1 )", 
            "title": ".setDigital()"
        }, 
        {
            "location": "/matrix-lite/py-reference/gpio/#setpwm", 
            "text": "Set the current PWM signal of a GPIO pin.  Parameters:   config:  object  pin : Any number from 0 to 15.  percentage : Any number from 0 to 100.  frequency : Any number from 36 to  max value not tested . # Set PWM for pin 0  gpio . setPWM ({ \n   pin :   0 , \n   percentage :   25 , \n   frequency :   50 ,   # min 36  })", 
            "title": ".setPWM()"
        }, 
        {
            "location": "/matrix-lite/py-reference/gpio/#setservoangle", 
            "text": "Use a GPIO pin to control a servo. This function requires the pin to be set to  \"PWM\"  mode.  Parameters:   config:  object  pin : Any number from 0 to 15.  angle : Positive number of degrees.  min_pulse_ms : Generally numbers between 0 and 2.  minimum pulse width for a PWM wave in milliseconds # Sets Servo to 90 Degrees with pin 0  gpio . setServoAngle ({ \n     pin :   0 , \n     angle :   90 , \n     min_pulse_ms :   0.8 ,  })", 
            "title": ".setServoAngle()"
        }, 
        {
            "location": "/matrix-lite/py-reference/alsa-mics/", 
            "text": "ALSA Microphones\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe following sections will go over how to read microphone data from your MATRIX device. Note the code below isn't actually part of MATRIX Lite, but a downloadable library that allows us to easily access ALSA microphones.\n\n\nDependencies\n\n\nInstall the MATRIX Kernel Modules.\n\n\n\n\nFollow \nOption1\n or \nOption2\n: \nhttps://github.com/matrix-io/matrixio-kernel-modules\n.\n\n\n\n\nInstall portaudio.\n\nsudo apt install portaudio19-dev \n\n\n\nInstall pyaudio.\n\nsudo python3 -m pip install pyaudio\n\n\n\nConfigure your Pi's asound.conf file.\n\n\n\n\nDue to the linux kernel being recently updated, the playback rate for the Raspberry Pi must be set to \n16000\n. Add the following \nhighlighted\n line to \n/etc/asound.conf\n\n\npcm.speaker \n{\n\n  \ntype\n plug\n  slave \n{\n\n    pcm \nhw:0,0\n\n\n    rate \n16000\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nRecording Example\n\n\nBelow is a simple example that shows you how to create an audio recording with pyaudio.\nVisit the \npyaudio documentation\n for a complete overview.\n\n\n\n\nrecordFile.py\n\n\nBe sure to run the example with \npython3\n\n\nimport\n \npyaudio\n\n\nimport\n \nwave\n\n\n\n# recording configs\n\n\nCHUNK\n \n=\n \n2048\n\n\nFORMAT\n \n=\n \npyaudio\n.\npaInt16\n\n\nCHANNELS\n \n=\n \n8\n\n\nRATE\n \n=\n \n96000\n\n\nRECORD_SECONDS\n \n=\n \n5\n\n\nWAVE_OUTPUT_FILENAME\n \n=\n \noutput.wav\n\n\n\n# create \n configure microphone\n\n\nmic\n \n=\n \npyaudio\n.\nPyAudio\n()\n\n\nstream\n \n=\n \nmic\n.\nopen\n(\nformat\n=\nFORMAT\n,\n\n                \nchannels\n=\nCHANNELS\n,\n\n                \nrate\n=\nRATE\n,\n\n                \ninput\n=\nTrue\n,\n\n                \nframes_per_buffer\n=\nCHUNK\n)\n\n\n\nprint\n(\n* recording\n)\n\n\n\n# read \n store microphone data per frame read\n\n\nframes\n \n=\n \n[]\n\n\nfor\n \ni\n \nin\n \nrange\n(\n0\n,\n \nint\n(\nRATE\n \n/\n \nCHUNK\n \n*\n \nRECORD_SECONDS\n)):\n\n    \ndata\n \n=\n \nstream\n.\nread\n(\nCHUNK\n)\n\n    \nframes\n.\nappend\n(\ndata\n)\n\n\n\nprint\n(\n* done recording\n)\n\n\n\n# kill the mic and recording\n\n\nstream\n.\nstop_stream\n()\n\n\nstream\n.\nclose\n()\n\n\nmic\n.\nterminate\n()\n\n\n\n# combine \n store all microphone data to output.wav file\n\n\noutputFile\n \n=\n \nwave\n.\nopen\n(\nWAVE_OUTPUT_FILENAME\n,\n \nwb\n)\n\n\noutputFile\n.\nsetnchannels\n(\nCHANNELS\n)\n\n\noutputFile\n.\nsetsampwidth\n(\nmic\n.\nget_sample_size\n(\nFORMAT\n))\n\n\noutputFile\n.\nsetframerate\n(\nRATE\n)\n\n\noutputFile\n.\nwriteframes\n(\nb\n.\njoin\n(\nframes\n))\n\n\noutputFile\n.\nclose\n()\n\n\n\n\n\nOnce recorded, you can play the audio through the Pi's audio jack with:\n\n# raise the output volume to max\n\namixer \nset\n PCM \n100\n%\n\n\n# play the file\n\naplay output.wav", 
            "title": "ALSA Mics"
        }, 
        {
            "location": "/matrix-lite/py-reference/alsa-mics/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-lite/py-reference/alsa-mics/#overview", 
            "text": "The following sections will go over how to read microphone data from your MATRIX device. Note the code below isn't actually part of MATRIX Lite, but a downloadable library that allows us to easily access ALSA microphones.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/py-reference/alsa-mics/#dependencies", 
            "text": "Install the MATRIX Kernel Modules.   Follow  Option1  or  Option2 :  https://github.com/matrix-io/matrixio-kernel-modules .   Install portaudio. sudo apt install portaudio19-dev   Install pyaudio. sudo python3 -m pip install pyaudio  Configure your Pi's asound.conf file.   Due to the linux kernel being recently updated, the playback rate for the Raspberry Pi must be set to  16000 . Add the following  highlighted  line to  /etc/asound.conf  pcm.speaker  { \n   type  plug\n  slave  { \n    pcm  hw:0,0      rate  16000     }  }", 
            "title": "Dependencies"
        }, 
        {
            "location": "/matrix-lite/py-reference/alsa-mics/#recording-example", 
            "text": "Below is a simple example that shows you how to create an audio recording with pyaudio.\nVisit the  pyaudio documentation  for a complete overview.   recordFile.py  Be sure to run the example with  python3  import   pyaudio  import   wave  # recording configs  CHUNK   =   2048  FORMAT   =   pyaudio . paInt16  CHANNELS   =   8  RATE   =   96000  RECORD_SECONDS   =   5  WAVE_OUTPUT_FILENAME   =   output.wav  # create   configure microphone  mic   =   pyaudio . PyAudio ()  stream   =   mic . open ( format = FORMAT , \n                 channels = CHANNELS , \n                 rate = RATE , \n                 input = True , \n                 frames_per_buffer = CHUNK )  print ( * recording )  # read   store microphone data per frame read  frames   =   []  for   i   in   range ( 0 ,   int ( RATE   /   CHUNK   *   RECORD_SECONDS )): \n     data   =   stream . read ( CHUNK ) \n     frames . append ( data )  print ( * done recording )  # kill the mic and recording  stream . stop_stream ()  stream . close ()  mic . terminate ()  # combine   store all microphone data to output.wav file  outputFile   =   wave . open ( WAVE_OUTPUT_FILENAME ,   wb )  outputFile . setnchannels ( CHANNELS )  outputFile . setsampwidth ( mic . get_sample_size ( FORMAT ))  outputFile . setframerate ( RATE )  outputFile . writeframes ( b . join ( frames ))  outputFile . close ()   Once recorded, you can play the audio through the Pi's audio jack with: # raise the output volume to max \namixer  set  PCM  100 % # play the file \naplay output.wav", 
            "title": "Recording Example"
        }, 
        {
            "location": "/matrix-lite/go-reference/", 
            "text": "Go Reference\n\n\nGoDoc\n\n\n\nAuto-generated documentation.\n\n\nEverloop\n\n\n\nInterface for the LED array.\n\n\nSensors\n\n\n\nReading data from the IMU, humidity, UV, and pressure sensors.\n\n\nGPIO\n\n\n\nGeneral Purpose Input/Output.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-lite/go-reference/#go-reference", 
            "text": "", 
            "title": "Go Reference"
        }, 
        {
            "location": "/matrix-lite/go-reference/everloop/", 
            "text": "Everloop\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe following sections below will go over how to control the LED array on your MATRIX Device.\n\n\nImport Statement\n\n\nimport\n \n(\ngithub.com/matrix-io/matrix-lite-go\n)\n\n\n\n\n\n\n\nMATRIX Initialization\n\n\n.Init\n will contain an \nLed\n struct to call the functions below\n\nm\n \n:=\n \nmatrix\n.\nInit\n()\n\n\n\n\n\n\n.Length\n\n\nReturns the size of the LED array on your MATRIX device.\n\nm\n.\nLed\n.\nLength\n\n\n\n\n.Set()\n\n\nAllows you to set the colors of each LED. A \nstring\n, \nRGBW struct\n, \nslice\n or \narray\n can be given to this function.\n\n\nString input\n\n\n// Turn LEDs blue\n\n\nm\n.\nLed\n.\nSet\n(\nblue\n)\n\n\n\n// Valid ways to turn LEDs off\n\n\nm\n.\nLed\n.\nSet\n(\nblack\n)\n\n\nm\n.\nLed\n.\nSet\n(\n)\n\n\nm\n.\nLed\n.\nSet\n(\ninvalid color names will default to black\n)\n\n\n\n\nRGBW Struct input\n\n\n// Turn LEDs blue\n\n\nm\n.\nLed\n.\nSet\n(\nmatrix\n.\nRGBW\n{\n0\n,\n \n0\n,\n \n10\n,\n \n0\n})\n\n\n\n// Turn LEDs off\n\n\nm\n.\nLed\n.\nSet\n(\nmatrix\n.\nRGBW\n{})\n\n\n\n\nSlice \n Array Input\n\n\nPassing in an a slice or array allows you to set each individual LED color. However, passing anything that's larger than \nLed.Length\n will result in an error. It's recommended to use slices so that \nLed.Length\n can be used as the size.\n\n// Slice\n\n\nm\n.\nLed\n.\nSet\n([]\nstring\n{\nred\n,\n \ngold\n,\n \nblack\n,\n \npurple\n})\n\n\n\n// Slice with different data types\n\n\nm\n.\nLed\n.\nSet\n([]\ninterface\n{}{\nred\n,\n \n,\n \nmatrix\n.\nRGBW\n{},\n \nblack\n,\n \nmatrix\n.\nRGBW\n{\nG\n:\n \n255\n}})\n\n\n\n// Array\n\n\nm\n.\nLed\n.\nSet\n([\n5\n]\nstring\n{\nred\n,\n \ngold\n,\n \nblack\n,\n \npurple\n})", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-lite/go-reference/everloop/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-lite/go-reference/everloop/#overview", 
            "text": "The following sections below will go over how to control the LED array on your MATRIX Device.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/go-reference/everloop/#import-statement", 
            "text": "import   ( github.com/matrix-io/matrix-lite-go )    MATRIX Initialization  .Init  will contain an  Led  struct to call the functions below m   :=   matrix . Init ()", 
            "title": "Import Statement"
        }, 
        {
            "location": "/matrix-lite/go-reference/everloop/#length", 
            "text": "Returns the size of the LED array on your MATRIX device. m . Led . Length", 
            "title": ".Length"
        }, 
        {
            "location": "/matrix-lite/go-reference/everloop/#set", 
            "text": "Allows you to set the colors of each LED. A  string ,  RGBW struct ,  slice  or  array  can be given to this function.  String input  // Turn LEDs blue  m . Led . Set ( blue )  // Valid ways to turn LEDs off  m . Led . Set ( black )  m . Led . Set ( )  m . Led . Set ( invalid color names will default to black )   RGBW Struct input  // Turn LEDs blue  m . Led . Set ( matrix . RGBW { 0 ,   0 ,   10 ,   0 })  // Turn LEDs off  m . Led . Set ( matrix . RGBW {})   Slice   Array Input  Passing in an a slice or array allows you to set each individual LED color. However, passing anything that's larger than  Led.Length  will result in an error. It's recommended to use slices so that  Led.Length  can be used as the size. // Slice  m . Led . Set ([] string { red ,   gold ,   black ,   purple })  // Slice with different data types  m . Led . Set ([] interface {}{ red ,   ,   matrix . RGBW {},   black ,   matrix . RGBW { G :   255 }})  // Array  m . Led . Set ([ 5 ] string { red ,   gold ,   black ,   purple })", 
            "title": ".Set()"
        }, 
        {
            "location": "/matrix-lite/go-reference/sensors/", 
            "text": "Sensors\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe following sections below will go over how to read \n what to expect from each sensor on the MATRIX Creator.\n\n\nImport Statement\n\n\nimport\n \n(\ngithub.com/matrix-io/matrix-lite-go\n)\n\n\n\n\n\n\n\nMATRIX Initialization\n\n\n.Init\n will contain a \nSensors\n struct to call the functions below\n\nm\n \n:=\n \nmatrix\n.\nInit\n()\n\n\n\n\n\n\nReading Sensor Data\n\n\nSensor data can be read by calling \n.Read()\n on a sensor struct. This updates the existing sensor's values. Below are examples on how to call each sensor and what information to expect.\n\n\n\n\n\n\nIMU\n\n\nm\n.\nImu\n.\nRead\n()\n\n\n\n// Imu properties\n\n\nm\n.\nImu\n.\nAccelX\n \nfloat32\n\n\nm\n.\nImu\n.\nAccelY\n \nfloat32\n\n\nm\n.\nImu\n.\nAccelZ\n \nfloat32\n\n\nm\n.\nImu\n.\nGyroX\n  \nfloat32\n\n\nm\n.\nImu\n.\nGyroY\n  \nfloat32\n\n\nm\n.\nImu\n.\nGyroZ\n  \nfloat32\n\n\nm\n.\nImu\n.\nYaw\n    \nfloat32\n\n\nm\n.\nImu\n.\nPitch\n  \nfloat32\n\n\nm\n.\nImu\n.\nRoll\n   \nfloat32\n\n\nm\n.\nImu\n.\nMagX\n   \nfloat32\n\n\nm\n.\nImu\n.\nMagY\n   \nfloat32\n\n\nm\n.\nImu\n.\nMagZ\n   \nfloat32\n \n\n\n\n\n\nUV\n\n\nm\n.\nUv\n.\nRead\n()\n\n\n\n// Uv properties\n\n\nm\n.\nUv\n.\nUv\n \nfloat32\n \n\n\n\n\n\nHumidity\n\n\nm\n.\nHumidity\n.\nRead\n()\n\n\n\n// Humidity properties\n\n \nm\n.\nHumidity\n.\nHumidity\n    \nfloat32\n \n \nm\n.\nHumidity\n.\nTemperature\n \nfloat32\n\n\n\n\n\n\nPressure\n\n\nm\n.\nPressure\n.\nRead\n()\n\n\n\n// Pressure properties\n\n \nm\n.\nPressure\n.\nAltitude\n    \nfloat32\n\n \nm\n.\nPressure\n.\nPressure\n    \nfloat32\n\n \nm\n.\nPressure\n.\nTemperature\n \nfloat32", 
            "title": "Sensors"
        }, 
        {
            "location": "/matrix-lite/go-reference/sensors/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-lite/go-reference/sensors/#overview", 
            "text": "The following sections below will go over how to read   what to expect from each sensor on the MATRIX Creator.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/go-reference/sensors/#import-statement", 
            "text": "import   ( github.com/matrix-io/matrix-lite-go )    MATRIX Initialization  .Init  will contain a  Sensors  struct to call the functions below m   :=   matrix . Init ()", 
            "title": "Import Statement"
        }, 
        {
            "location": "/matrix-lite/go-reference/sensors/#reading-sensor-data", 
            "text": "Sensor data can be read by calling  .Read()  on a sensor struct. This updates the existing sensor's values. Below are examples on how to call each sensor and what information to expect.    IMU  m . Imu . Read ()  // Imu properties  m . Imu . AccelX   float32  m . Imu . AccelY   float32  m . Imu . AccelZ   float32  m . Imu . GyroX    float32  m . Imu . GyroY    float32  m . Imu . GyroZ    float32  m . Imu . Yaw      float32  m . Imu . Pitch    float32  m . Imu . Roll     float32  m . Imu . MagX     float32  m . Imu . MagY     float32  m . Imu . MagZ     float32     UV  m . Uv . Read ()  // Uv properties  m . Uv . Uv   float32     Humidity  m . Humidity . Read ()  // Humidity properties \n  m . Humidity . Humidity      float32  \n  m . Humidity . Temperature   float32    Pressure  m . Pressure . Read ()  // Pressure properties \n  m . Pressure . Altitude      float32 \n  m . Pressure . Pressure      float32 \n  m . Pressure . Temperature   float32", 
            "title": "Reading Sensor Data"
        }, 
        {
            "location": "/matrix-lite/go-reference/gpio/", 
            "text": "GPIO\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe following sections below will go over how to utilize the GPIO on your MATRIX Device.\n\n\nImport Statement\n\n\nimport\n \n(\ngithub.com/matrix-io/matrix-lite-go\n)\n\n\n\n\n\n\n\nMATRIX Initialization\n\n\n.Init\n will contain a \nGpio\n struct to call the functions below\n\nm\n \n:=\n \nmatrix\n.\nInit\n()\n\n\n\n\n\n\n.SetFunction()\n\n\nSpecify if a GPIO pin is being used for \nDIGITAL\n or \nPWM\n.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\nfunction\n: \n\"DIGITAL\"\n or \n\"PWM\"\n\n\n\n\n// Set pin 0 as a Digital pin\n\n\nm\n.\nGpio\n.\nSetFunction\n(\n0\n,\n \nDIGITAL\n)\n\n\n\n// Set pin 1 as a PWM pin\n\n\nm\n.\nGpio\n.\nSetFunction\n(\n1\n,\n \nPWM\n);\n\n\n\n\n\n.SetMode()\n\n\nSpecify if a GPIO pin is being used for \ninput\n or \noutput\n.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\nmode\n: \n\"input\"\n or \n\"output\"\n\n\n\n\n// Set pin 0 to receive input\n\n\nm\n.\nGpio\n.\nSetMode\n(\n0\n,\n \ninput\n)\n\n\n\n// Set pin 1 to output\n\n\nm\n.\nGpio\n.\nSetMode\n(\n0\n,\n \noutput\n)\n\n\n\n\n\n.GetDigital()\n\n\nRetrieve the current digital signal of a GPIO pin.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\n\n\nReturn Value:\n\n\n\n\nvalue\n: \n0\n or \n1\n representing ON/OFF respectively\n\n\n\n\n// Return the current ON/OFF state of pin 0\n\n\nm\n.\nGpio\n.\nGetDigital\n(\n0\n)\n\n\n\n\n\n.SetDigital()\n\n\nSet the current digital signal of a GPIO pin.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\nvalue\n: \n\"ON\"\n or \n\"OFF\"\n\n\n\n\n// Set pin 0 to OFF\n\n\nm\n.\nGpio\n.\nSetDigital\n(\n0\n,\n \nON\n)\n\n\n\n// Set pin 1 to ON\n\n\nm\n.\nGpio\n.\nSetDigital\n(\n1\n,\n \nON\n)\n\n\n\n\n\n.SetPWM()\n\n\nSet the current PWM signal of a GPIO pin.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\npercentage\n: Any number from 0 to 100.\n\n\nfrequency\n: Any number from 36 to \nmax value not tested\n.\n\n\n\n\n// Set PWM for pin 0\n\n\nm\n.\nGpio\n.\nSetPWM\n(\n0\n,\n \n25\n,\n \n50\n);\n\n\n\n\n\n.SetServoAngle()\n\n\nUse a GPIO pin to control a servo. This function requires the pin to be set to \n\"PWM\"\n mode.\n\n\nParameters:\n\n\n\n\npin\n: Any number from 0 to 15.\n\n\nangle\n: Positive number of degrees.\n\n\nmin_pulse_ms\n: Generally numbers between 0 and 2.\n\n\nminimum pulse width for a PWM wave in milliseconds\n\n\n\n\n\n\n\n\n// Sets Servo to 90 Degrees with pin 0\n\n\nm\n.\nGpio\n.\nSetServoAngle\n(\n0\n,\n \n90\n,\n \n0.8\n)", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-lite/go-reference/gpio/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-lite/go-reference/gpio/#overview", 
            "text": "The following sections below will go over how to utilize the GPIO on your MATRIX Device.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-lite/go-reference/gpio/#import-statement", 
            "text": "import   ( github.com/matrix-io/matrix-lite-go )    MATRIX Initialization  .Init  will contain a  Gpio  struct to call the functions below m   :=   matrix . Init ()", 
            "title": "Import Statement"
        }, 
        {
            "location": "/matrix-lite/go-reference/gpio/#setfunction", 
            "text": "Specify if a GPIO pin is being used for  DIGITAL  or  PWM .  Parameters:   pin : Any number from 0 to 15.  function :  \"DIGITAL\"  or  \"PWM\"   // Set pin 0 as a Digital pin  m . Gpio . SetFunction ( 0 ,   DIGITAL )  // Set pin 1 as a PWM pin  m . Gpio . SetFunction ( 1 ,   PWM );", 
            "title": ".SetFunction()"
        }, 
        {
            "location": "/matrix-lite/go-reference/gpio/#setmode", 
            "text": "Specify if a GPIO pin is being used for  input  or  output .  Parameters:   pin : Any number from 0 to 15.  mode :  \"input\"  or  \"output\"   // Set pin 0 to receive input  m . Gpio . SetMode ( 0 ,   input )  // Set pin 1 to output  m . Gpio . SetMode ( 0 ,   output )", 
            "title": ".SetMode()"
        }, 
        {
            "location": "/matrix-lite/go-reference/gpio/#getdigital", 
            "text": "Retrieve the current digital signal of a GPIO pin.  Parameters:   pin : Any number from 0 to 15.   Return Value:   value :  0  or  1  representing ON/OFF respectively   // Return the current ON/OFF state of pin 0  m . Gpio . GetDigital ( 0 )", 
            "title": ".GetDigital()"
        }, 
        {
            "location": "/matrix-lite/go-reference/gpio/#setdigital", 
            "text": "Set the current digital signal of a GPIO pin.  Parameters:   pin : Any number from 0 to 15.  value :  \"ON\"  or  \"OFF\"   // Set pin 0 to OFF  m . Gpio . SetDigital ( 0 ,   ON )  // Set pin 1 to ON  m . Gpio . SetDigital ( 1 ,   ON )", 
            "title": ".SetDigital()"
        }, 
        {
            "location": "/matrix-lite/go-reference/gpio/#setpwm", 
            "text": "Set the current PWM signal of a GPIO pin.  Parameters:   pin : Any number from 0 to 15.  percentage : Any number from 0 to 100.  frequency : Any number from 36 to  max value not tested .   // Set PWM for pin 0  m . Gpio . SetPWM ( 0 ,   25 ,   50 );", 
            "title": ".SetPWM()"
        }, 
        {
            "location": "/matrix-lite/go-reference/gpio/#setservoangle", 
            "text": "Use a GPIO pin to control a servo. This function requires the pin to be set to  \"PWM\"  mode.  Parameters:   pin : Any number from 0 to 15.  angle : Positive number of degrees.  min_pulse_ms : Generally numbers between 0 and 2.  minimum pulse width for a PWM wave in milliseconds     // Sets Servo to 90 Degrees with pin 0  m . Gpio . SetServoAngle ( 0 ,   90 ,   0.8 )", 
            "title": ".SetServoAngle()"
        }, 
        {
            "location": "/matrix-hal/overview/", 
            "text": "MATRIX Hardware Abstraction Layer\n\n\n\nMATRIX Hardware Abstraction Layer (HAL) is an open source library for directly interfacing with the MATRIX device. MATRIX HAL consists of driver files written in C++ which enable the user to write low level programs in C++.\n\n\nGetting Started\n\n\nLearn how to install MATRIX HAL and create programs on your MATRIX device.\n\n\nReference\n\n\nLook over the MATRIX HAL functions for interacting with your MATRIX device.\n\n\nExamples\n\n\nView our MATRIX HAL code examples.\n\n\nTroubleshooting\n\n\nLook at common debugging solutions for any issues you encounter.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/overview/#getting-started", 
            "text": "Learn how to install MATRIX HAL and create programs on your MATRIX device.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/matrix-hal/overview/#reference", 
            "text": "Look over the MATRIX HAL functions for interacting with your MATRIX device.", 
            "title": "Reference"
        }, 
        {
            "location": "/matrix-hal/overview/#examples", 
            "text": "View our MATRIX HAL code examples.", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-hal/overview/#troubleshooting", 
            "text": "Look at common debugging solutions for any issues you encounter.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-hal/getting-started/", 
            "text": "Getting Started\n\n\n\n\n\n\n\nWe recommend beginners install MATRIX HAL from package.\n\n\n\n\nInstallation From Package\n\n\n\n\n\nLearn how to install MATRIX HAL from package.\n\n\nInstallation From Source\n\n\n\n\n\nLearn how to install MATRIX HAL from source.\n\n\nCompiling Your Program\n\n\n\n\n\nCreate and compile a sample program for your MATRIX device.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-hal/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation-package/", 
            "text": "Installing MATRIX HAL From Package\n\n\n\n\nMake sure you have setup your\n\nMATRIX Creator\n or\n\nMATRIX Voice\n before continuing.\n\n\n\n\nBefore starting, ensure you have access to the terminal of your Raspberry Pi via an \nSSH-session\n or connect a screen, mouse, and keyboard. Once you've opened the terminal, insert and run the following commands.\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the the MATRIX HAL packages.\n\n\nsudo apt-get install matrixio-creator-init libmatrixio-creator-hal libmatrixio-creator-hal-dev\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nHelpful Information\n\n\nMATRIX HAL header files are installed in \n/usr/include/matrix_hal\n. \n\n\nThe compiled MATRIX HAL library file is installed in \n/usr/lib/libmatrix_creator_hal.so\n.\n\n\nNext Steps\n\n\nNow that MATRIX HAL is properly installed, learn how to create and compile your own MATRIX programs \nhere\n.", 
            "title": "Installation From Package"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation-package/#installing-matrix-hal-from-package", 
            "text": "Make sure you have setup your MATRIX Creator  or MATRIX Voice  before continuing.   Before starting, ensure you have access to the terminal of your Raspberry Pi via an  SSH-session  or connect a screen, mouse, and keyboard. Once you've opened the terminal, insert and run the following commands.  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the the MATRIX HAL packages.  sudo apt-get install matrixio-creator-init libmatrixio-creator-hal libmatrixio-creator-hal-dev  Reboot your device.  sudo reboot", 
            "title": "Installing MATRIX HAL From Package"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation-package/#helpful-information", 
            "text": "MATRIX HAL header files are installed in  /usr/include/matrix_hal .   The compiled MATRIX HAL library file is installed in  /usr/lib/libmatrix_creator_hal.so .", 
            "title": "Helpful Information"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation-package/#next-steps", 
            "text": "Now that MATRIX HAL is properly installed, learn how to create and compile your own MATRIX programs  here .", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation-source/", 
            "text": "Installing MATRIX HAL From Source\n\n\n\n\nMake sure you have setup your\n\nMATRIX Creator\n or\n\nMATRIX Voice\n before continuing.\n\n\n\n\nBefore starting, ensure you have access to the terminal of your Raspberry Pi via an \nSSH-session\n or connect a screen, mouse, and keyboard. Once you've opened the terminal, insert and run the following commands.\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the MATRIX init package and tools needed to build MATRIX HAL.\n\n\nsudo apt-get install cmake g++ git libfftw3-dev wiringpi libgflags-dev matrixio-creator-init\n\n\n\n\nClone, build, and install MATRIX HAL.\n\n\ncd\n ~/\ngit clone https://github.com/matrix-io/matrix-creator-hal.git\n\ncd\n matrix-creator-hal\nmkdir build\n\ncd\n build\ncmake ..\nmake -j4 \n sudo make install\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nHelpful Information\n\n\nMATRIX HAL header files are installed in \n/usr/local/include/matrix_hal\n. \n\n\nThe compiled MATRIX HAL library file is installed in \n/usr/local/lib/libmatrix_creator_hal.so\n.\n\n\nNext Steps\n\n\nNow that MATRIX HAL is properly installed, learn how to create and compile your own MATRIX programs \nhere\n.", 
            "title": "Installation From Source"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation-source/#installing-matrix-hal-from-source", 
            "text": "Make sure you have setup your MATRIX Creator  or MATRIX Voice  before continuing.   Before starting, ensure you have access to the terminal of your Raspberry Pi via an  SSH-session  or connect a screen, mouse, and keyboard. Once you've opened the terminal, insert and run the following commands.  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the MATRIX init package and tools needed to build MATRIX HAL.  sudo apt-get install cmake g++ git libfftw3-dev wiringpi libgflags-dev matrixio-creator-init  Clone, build, and install MATRIX HAL.  cd  ~/\ngit clone https://github.com/matrix-io/matrix-creator-hal.git cd  matrix-creator-hal\nmkdir build cd  build\ncmake ..\nmake -j4   sudo make install  Reboot your device.  sudo reboot", 
            "title": "Installing MATRIX HAL From Source"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation-source/#helpful-information", 
            "text": "MATRIX HAL header files are installed in  /usr/local/include/matrix_hal .   The compiled MATRIX HAL library file is installed in  /usr/local/lib/libmatrix_creator_hal.so .", 
            "title": "Helpful Information"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation-source/#next-steps", 
            "text": "Now that MATRIX HAL is properly installed, learn how to create and compile your own MATRIX programs  here .", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-hal/getting-started/programs/", 
            "text": "Introduction\n\n\n\nPrograms created with MATRIX HAL allow you to directly access sensors and components on the MATRIX device through C++. This guide will show you how to create and run an LED demo in MATRIX HAL. The final result being a rainbow LED sequence.\n\n\nCreating A Program\n\n\nMaking Your Project Directory\n\n\n\nUse the following commands to create a folder to hold your MATRIX HAL projects, in the home directory \n~/\n of your MATRIX device.\n\ncd\n ~/\nmkdir matrix-hal-project\n\ncd\n matrix-hal-project\n\n\n\nCreate a file called \napp.cpp\n in your project folder, and paste the code below.\n\n\nThe following code turns the Everloop rainbow for 10 seconds.\n\n\n/*\n\n\n * Everloop rainbow example\n\n\n */\n\n\n\n/////////////////////////\n\n\n// INCLUDE STATEMENTS //\n\n\n///////////////////////\n\n\n\n// System calls\n\n\n#include\n \nunistd.h\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n// Included for sin() function.\n\n\n#include\n \ncmath\n\n\n\n// Interfaces with Everloop\n\n\n#include\n \nmatrix_hal/everloop.h\n\n\n// Holds data for Everloop\n\n\n#include\n \nmatrix_hal/everloop_image.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\nint\n \nmain\n()\n \n{\n\n  \n////////////////////\n\n  \n// INITIAL SETUP //\n\n  \n//////////////////\n\n\n  \n// Create MatrixIOBus object for hardware communication\n\n  \nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n  \n// Initialize bus and exit program if error occurs\n\n  \nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n  \n/////////////////\n\n  \n// MAIN SETUP //\n\n  \n///////////////\n\n\n  \n// Holds the number of LEDs on MATRIX device\n\n  \nint\n \nledCount\n \n=\n \nbus\n.\nMatrixLeds\n();\n\n  \n// Create EverloopImage object, with size of ledCount\n\n  \nmatrix_hal\n::\nEverloopImage\n \neverloop_image\n(\nledCount\n);\n\n  \n// Create Everloop object\n\n  \nmatrix_hal\n::\nEverloop\n \neverloop\n;\n\n  \n// Set everloop to use MatrixIOBus bus\n\n  \neverloop\n.\nSetup\n(\nbus\n);\n\n\n  \n// Variables used for sine wave rainbow logic\n\n  \nfloat\n \ncounter\n \n=\n \n0\n;\n\n  \nconst\n \nfloat\n \nfreq\n \n=\n \n0.375\n;\n\n\n  \n// 10 sec loop for rainbow effect 250*40000 microsec = 10 sec\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n=\n \n250\n;\n \ni\n++\n)\n \n{\n\n    \n// For each led in everloop_image.leds, set led value\n\n    \nfor\n \n(\nmatrix_hal\n::\nLedValue\n \nled\n \n:\n \neverloop_image\n.\nleds\n)\n \n{\n\n      \n// Sine waves 120 degrees out of phase for rainbow\n\n      \nled\n.\nred\n \n=\n\n          \n(\nstd\n::\nsin\n(\nfreq\n \n*\n \ncounter\n \n+\n \n(\nM_PI\n \n/\n \n180\n \n*\n \n240\n))\n \n*\n \n155\n \n+\n \n100\n)\n \n/\n \n10\n;\n\n      \nled\n.\ngreen\n \n=\n\n          \n(\nstd\n::\nsin\n(\nfreq\n \n*\n \ncounter\n \n+\n \n(\nM_PI\n \n/\n \n180\n \n*\n \n120\n))\n \n*\n \n155\n \n+\n \n100\n)\n \n/\n \n10\n;\n\n      \nled\n.\nblue\n \n=\n \n(\nstd\n::\nsin\n(\nfreq\n \n*\n \ncounter\n \n+\n \n0\n)\n \n*\n \n155\n \n+\n \n100\n)\n \n/\n \n10\n;\n\n      \n// If MATRIX Creator, increment by 0.51\n\n      \nif\n \n(\nledCount\n \n==\n \n35\n)\n \n{\n\n        \ncounter\n \n=\n \ncounter\n \n+\n \n0.51\n;\n\n      \n}\n\n      \n// If MATRIX Voice, increment by 1.01\n\n      \nif\n \n(\nledCount\n \n==\n \n18\n)\n \n{\n\n        \ncounter\n \n=\n \ncounter\n \n+\n \n1.01\n;\n\n      \n}\n\n    \n}\n\n\n    \n// Updates the LEDs\n\n    \neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n    \n// If i is 0 (first run)\n\n    \nif\n \n(\ni\n \n==\n \n0\n)\n \n{\n\n      \n// Output everloop status to console\n\n      \nstd\n::\ncout\n \n \nEverloop set to rainbow for 10 seconds.\n \n \nstd\n::\nendl\n;\n\n    \n}\n\n    \n// If i is cleanly divisible by 25\n\n    \nif\n \n((\ni\n \n%\n \n25\n)\n \n==\n \n0\n)\n \n{\n\n      \nstd\n::\ncout\n \n \nTime remaining (s) : \n \n \n10\n \n-\n \n(\ni\n \n/\n \n25\n)\n \n \nstd\n::\nendl\n;\n\n    \n}\n\n\n    \n// Sleep for 40000 microseconds\n\n    \nusleep\n(\n40000\n);\n\n  \n}\n\n\n  \n// Updates the Everloop on the MATRIX device\n\n  \neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n  \n// For each led in everloop_image.leds, set led value to 0\n\n  \nfor\n \n(\nmatrix_hal\n::\nLedValue\n \nled\n \n:\n \neverloop_image\n.\nleds\n)\n \n{\n\n    \n// Turn off Everloop\n\n    \nled\n.\nred\n \n=\n \n0\n;\n\n    \nled\n.\ngreen\n \n=\n \n0\n;\n\n    \nled\n.\nblue\n \n=\n \n0\n;\n\n    \nled\n.\nwhite\n \n=\n \n0\n;\n\n  \n}\n\n\n  \n// Updates the Everloop on the MATRIX device\n\n  \neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\nCompiling your Program\n\n\nThe command below will use g++ to link the \nlibmatrix_creator_hal.so\n library file when compiling your program.\n\n\ng++ -o app app.cpp -std\n=\nc++11 -lmatrix_creator_hal\n\n\n\n\nRunning your Program\n\n\nRun the following command to start the demo program.\n\n\ncd\n ~/matrix-hal-project\n./app\n\n\n\n\nResult\n\n\n\n\n\nNext Steps\n\n\nNow that everything is properly installed, view our function \nreferences\n to see what you can do with MATRIX HAL, or view the code \nexamples\n.", 
            "title": "Compiling Programs"
        }, 
        {
            "location": "/matrix-hal/getting-started/programs/#creating-a-program", 
            "text": "", 
            "title": "Creating A Program"
        }, 
        {
            "location": "/matrix-hal/getting-started/programs/#compiling-your-program", 
            "text": "The command below will use g++ to link the  libmatrix_creator_hal.so  library file when compiling your program.  g++ -o app app.cpp -std = c++11 -lmatrix_creator_hal", 
            "title": "Compiling your Program"
        }, 
        {
            "location": "/matrix-hal/getting-started/programs/#running-your-program", 
            "text": "Run the following command to start the demo program.  cd  ~/matrix-hal-project\n./app", 
            "title": "Running your Program"
        }, 
        {
            "location": "/matrix-hal/getting-started/programs/#next-steps", 
            "text": "Now that everything is properly installed, view our function  references  to see what you can do with MATRIX HAL, or view the code  examples .", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-hal/reference/", 
            "text": "MATRIX HAL References\n\n\nEverloop\n\n\n\nLED interface.\n\n\nHumidity\n\n\n\nHumidity and temperature measurement.\n\n\nIMU\n\n\n\nInertial Measurement Unit.\n\n\nPressure\n\n\n\nPressure, altitude and temperature measurement.\n\n\nUV\n\n\n\nUltraviolet light sensor.\n\n\nGPIO\n\n\n\nGeneral Purpose Input/Output.\n\n\nMicrophone\n\n\n\nMicrophone Array.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-hal/reference/#matrix-hal-references", 
            "text": "", 
            "title": "MATRIX HAL References"
        }, 
        {
            "location": "/matrix-hal/reference/everloop/", 
            "text": "Everloop\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe Everloop interface supports:\n\n\n\n\nSetting the RGBW colors for each individual LED.\n\n\n\n\nReferences\n\n\nBelow is the overview of the Everloop implementation. Code examples can be found \nhere\n.\n\n\nThese header files are required to use the Everloop.\n\n\n// Interfaces with Everloop\n\n\n#include\n \nmatrix_hal/everloop.h\n\n\n// Holds data for Everloop\n\n\n#include\n \nmatrix_hal/everloop_image.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\nEverloopImage\nEverloopImage\n is a required \nobject\n that contains an array of \nLedValue\n objects.\nThe \nEverloopImage\n constructor takes in an integer representing the amount of RGBW leds your MATRIX device has.\n\n\nThe MatrixIOBus function \nbus.MatrixLeds\n outputs the number of leds on your creator.\n\n\n// Holds the number of LEDs on MATRIX device\n\n\nint\n \nledCount\n \n=\n \nbus\n.\nMatrixLeds\n();\n\n\n// Create EverloopImage object, with size of ledCount\n\n\nmatrix_hal\n::\nEverloopImage\n \neverloop_image\n(\nledCount\n);\n\n\n\n\n\nEverloopImage\n holds an array full of \nLedValue\n objects. The \nLedValue\n object contains the properties \nred\n, \ngreen\n, \nblue\n, \nwhite\n. These color properties accept an RGBW integer between 0-255.\n\n\nThe following code shows how to set each led in everloop_image to green.\n\n\n// For each led, set RGBW colors\n\n\n// This sets all leds to green\n\n\nfor\n \n(\nmatrix_hal\n::\nLedValue\n \nled\n \n:\n \neverloop_image\n.\nleds\n)\n \n{\n\n  \nled\n.\nred\n \n=\n \n0\n;\n\n  \nled\n.\ngreen\n \n=\n \n100\n;\n\n  \nled\n.\nblue\n \n=\n \n0\n;\n\n  \nled\n.\nwhite\n \n=\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nEverloop\nEverloop\n is a required \nobject\n that contains functions to interface with the Everloop on the MATRIX device.\n\n\n// Create Everloop object\n\n\nmatrix_hal\n::\nEverloop\n \neverloop\n;\n\n\n\n\n\nThe functions below are part of \nEverloop\n.\n\n\n.Setup\nSetup\n is a \nfunction\n that takes \nMatrixIOBus\n object as parameter and sets that object as the bus to use for communicating with MATRIX device.\n\n\n// Function declaration in header file\n\n\nvoid\n \nSetup\n(\nMatrixIOBus\n \n*\nbus\n);\n\n\n\n\n\n// Set everloop to use MatrixIOBus bus\n\n\neverloop\n.\nSetup\n(\nbus\n);\n\n\n\n\n\n\n\n.Write\nWrite\n is a \nfunction\n that takes an \nEverloopImage\n object as a parameter and updates the Everloop on the MATRIX device.\n\n\n// Function declaration in header file\n\n\nbool\n \nWrite\n(\nEverloopImage\n \n*\neverloop_image\n;\n\n\n\n\n\n// Updates the Everloop on the MATRIX device\n\n\neverloop\n.\nWrite\n(\neverloop_image\n);", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-hal/reference/everloop/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/reference/everloop/#overview", 
            "text": "The Everloop interface supports:   Setting the RGBW colors for each individual LED.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/reference/everloop/#references", 
            "text": "Below is the overview of the Everloop implementation. Code examples can be found  here .  These header files are required to use the Everloop.  // Interfaces with Everloop  #include   matrix_hal/everloop.h  // Holds data for Everloop  #include   matrix_hal/everloop_image.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h   EverloopImage EverloopImage  is a required  object  that contains an array of  LedValue  objects.\nThe  EverloopImage  constructor takes in an integer representing the amount of RGBW leds your MATRIX device has.  The MatrixIOBus function  bus.MatrixLeds  outputs the number of leds on your creator.  // Holds the number of LEDs on MATRIX device  int   ledCount   =   bus . MatrixLeds ();  // Create EverloopImage object, with size of ledCount  matrix_hal :: EverloopImage   everloop_image ( ledCount );   EverloopImage  holds an array full of  LedValue  objects. The  LedValue  object contains the properties  red ,  green ,  blue ,  white . These color properties accept an RGBW integer between 0-255.  The following code shows how to set each led in everloop_image to green.  // For each led, set RGBW colors  // This sets all leds to green  for   ( matrix_hal :: LedValue   led   :   everloop_image . leds )   { \n   led . red   =   0 ; \n   led . green   =   100 ; \n   led . blue   =   0 ; \n   led . white   =   0 ;  }    Everloop Everloop  is a required  object  that contains functions to interface with the Everloop on the MATRIX device.  // Create Everloop object  matrix_hal :: Everloop   everloop ;   The functions below are part of  Everloop .  .Setup Setup  is a  function  that takes  MatrixIOBus  object as parameter and sets that object as the bus to use for communicating with MATRIX device.  // Function declaration in header file  void   Setup ( MatrixIOBus   * bus );   // Set everloop to use MatrixIOBus bus  everloop . Setup ( bus );    .Write Write  is a  function  that takes an  EverloopImage  object as a parameter and updates the Everloop on the MATRIX device.  // Function declaration in header file  bool   Write ( EverloopImage   * everloop_image ;   // Updates the Everloop on the MATRIX device  everloop . Write ( everloop_image );", 
            "title": "References"
        }, 
        {
            "location": "/matrix-hal/reference/humidity/", 
            "text": "Humidity\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe humidity sensor reports values for:\n\n\n\n\nHumidity\n\n\nTemperature\n\n\n\n\nReferences\n\n\nBelow is the overview of the humidity sensor implementation. Code example can be found \nhere\n.\n\n\nThese header files are required to use the humidity sensor.\n\n\n// Interfaces with humidity sensor\n\n\n#include\n \nmatrix_hal/humidity_sensor.h\n\n\n// Holds data from humidity sensor\n\n\n#include\n \nmatrix_hal/humidity_data.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\nHumidityData\nHumidityData\n is a required \nobject\n that contains the humidity sensor's supported data parameters.\n\n\n// Create HumidityData object\n\n\nmatrix_hal\n::\nHumidityData\n \nhumidity_data\n;\n\n\n\n\n\nThe following code accesses the parameters of \nHumidityData\n.\n\n\n// Output is represented in %\n\n\nfloat\n \nhumidity\n \n=\n \nhumidity_data\n.\nhumidity\n;\n \n\n// Output is represented in Celsius\n\n\nfloat\n \ntemperature\n \n=\n \nhumidity_data\n.\ntemperature\n;\n \n\n\n\n\n\n\nHumiditySensor\nHumiditySensor\n is a required \nobject\n that contains functions to interface with the humidity sensor.\n\n\n// Create HumiditySensor object\n\n\nmatrix_hal\n::\nHumiditySensor\n \nhumidity_sensor\n;\n\n\n\nThe functions below are part of \nHumiditySensor\n.\n\n\nSetup\nSetup\n is a \nfunction\n that takes a \nMatrixIOBus\n object as a parameter and sets that object as the bus to use for communicating with MATRIX device.\n\n\n// Function declaration in header file\n\n\nvoid\n \nSetup\n(\nMatrixIOBus\n \n*\nbus\n);\n\n\n\n\n\n// Set humidity_sensor to use MatrixIOBus bus\n\n\nhumidity_sensor\n.\nSetup\n(\nbus\n);\n\n\n\n\n\n\n\n.Read\nRead\n is a \nfunction\n that takes a \nHumidityData\n object as a parameter and writes the current humidity sensor data into the \nHumidityData\n object.\n\n\n// Function declaration in header file\n\n\nbool\n \nRead\n(\nHumidityData\n \n*\ndata\n);\n\n\n\n\n\n// Overwrites humidity_data with new data from humidity sensor\n\n\nhumidity_sensor\n.\nRead\n(\nhumidity_data\n);", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-hal/reference/humidity/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/reference/humidity/#overview", 
            "text": "The humidity sensor reports values for:   Humidity  Temperature", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/reference/humidity/#references", 
            "text": "Below is the overview of the humidity sensor implementation. Code example can be found  here .  These header files are required to use the humidity sensor.  // Interfaces with humidity sensor  #include   matrix_hal/humidity_sensor.h  // Holds data from humidity sensor  #include   matrix_hal/humidity_data.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h   HumidityData HumidityData  is a required  object  that contains the humidity sensor's supported data parameters.  // Create HumidityData object  matrix_hal :: HumidityData   humidity_data ;   The following code accesses the parameters of  HumidityData .  // Output is represented in %  float   humidity   =   humidity_data . humidity ;   // Output is represented in Celsius  float   temperature   =   humidity_data . temperature ;     HumiditySensor HumiditySensor  is a required  object  that contains functions to interface with the humidity sensor.  // Create HumiditySensor object  matrix_hal :: HumiditySensor   humidity_sensor ;  \nThe functions below are part of  HumiditySensor .  Setup Setup  is a  function  that takes a  MatrixIOBus  object as a parameter and sets that object as the bus to use for communicating with MATRIX device.  // Function declaration in header file  void   Setup ( MatrixIOBus   * bus );   // Set humidity_sensor to use MatrixIOBus bus  humidity_sensor . Setup ( bus );    .Read Read  is a  function  that takes a  HumidityData  object as a parameter and writes the current humidity sensor data into the  HumidityData  object.  // Function declaration in header file  bool   Read ( HumidityData   * data );   // Overwrites humidity_data with new data from humidity sensor  humidity_sensor . Read ( humidity_data );", 
            "title": "References"
        }, 
        {
            "location": "/matrix-hal/reference/imu/", 
            "text": "Inertial Measurement Unit (IMU)\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe IMU sensor reports values for:\n\n\n\n\nYaw, Pitch, and Roll\n\n\nAcceleration for \nx\n, \ny\n, \nz\n axes\n\n\nGyroscope for \nx\n, \ny\n, \nz\n axes\n\n\nMagnetometer for \nx\n, \ny\n, \nz\n axes\n\n\n\n\nReferences\n\n\nBelow is the overview of the IMU sensor implementation. Code example can be found \nhere\n.\n\n\nThese header files are required to use the IMU sensor.\n\n\n// Interfaces with IMU sensor\n\n\n#include\n \nmatrix_hal/imu_sensor.h\n\n\n// Holds data from IMU sensor\n\n\n#include\n \nmatrix_hal/imu_data.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\nIMUData\nIMUData\n is a required \nobject\n that contains the IMU sensor's supported data parameters.\n\n\n// Create IMUData object\n\n\nmatrix_hal\n::\nIMUData\n \nimu_data\n;\n\n\n\n\n\nThe following code accesses the parameters of \nIMUData\n.\n\n\n// Accelerometer\n\n\nfloat\n \naccel_X\n \n=\n \nimu_data\n.\naccel_x\n;\n\n\nfloat\n \naccel_Y\n \n=\n \nimu_data\n.\naccel_y\n;\n\n\nfloat\n \naccel_Z\n \n=\n \nimu_data\n.\naccel_z\n;\n\n\n// Gyroscope\n\n\nfloat\n \ngyro_X\n \n=\n \nimu_data\n.\ngyro_x\n;\n\n\nfloat\n \ngyro_Y\n \n=\n \nimu_data\n.\ngyro_y\n;\n\n\nfloat\n \ngyro_Z\n \n=\n \nimu_data\n.\ngyro_z\n;\n\n\n// Yaw, Pitch, Roll Output\n\n\nfloat\n \nyaw\n \n=\n \nimu_data\n.\nyaw\n;\n\n\nfloat\n \npitch\n \n=\n \nimu_data\n.\npitch\n;\n\n\nfloat\n \nroll\n \n=\n \nimu_data\n.\nroll\n;\n\n\n// Magnetometer\n\n\nfloat\n \nmag_X\n \n=\n \nimu_data\n.\nmag_x\n;\n\n\nfloat\n \nmag_Y\n \n=\n \nimu_data\n.\nmag_y\n;\n\n\nfloat\n \nmag_Z\n \n=\n \nimu_data\n.\nmag_z\n;\n \n// Z-axis points upward\n\n\n\n\n\n\n\nIMUSensor\nIMUSensor\n is a required \nobject\n that contains functions to interface with the IMU sensor.\n\n\n// Create IMUSensor object\n\n\nmatrix_hal\n::\nIMUSensor\n \nimu_sensor\n;\n\n\n\n\n\nThe functions below are part of \nIMUSensor\n.\n\n\n.Setup\nSetup\n is a \nfunction\n that takes a \nMatrixIOBus\n object as a parameter and sets that object as the bus to use for communicating with MATRIX device.\n\n\n// Function declaration in header file\n\n\nvoid\n \nSetup\n(\nMatrixIOBus\n \n*\nbus\n);\n\n\n\n\n\n// Set imu_sensor to use MatrixIOBus bus\n\n\nimu_sensor\n.\nSetup\n(\nbus\n);\n\n\n\n\n\n\n\n.Read\nRead\n is a \nfunction\n that takes an \nIMUData\n object as a parameter and writes the current IMU sensor data into the \nIMUData\n object.\n\n\n// Function declaration in header file\n\n\nbool\n \nRead\n(\nIMUData\n \n*\ndata\n);\n\n\n\n\n\n// Overwrites imu_data with new data from IMU sensor\n\n\nimu_sensor\n.\nRead\n(\nimu_data\n);", 
            "title": "IMU"
        }, 
        {
            "location": "/matrix-hal/reference/imu/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/reference/imu/#overview", 
            "text": "The IMU sensor reports values for:   Yaw, Pitch, and Roll  Acceleration for  x ,  y ,  z  axes  Gyroscope for  x ,  y ,  z  axes  Magnetometer for  x ,  y ,  z  axes", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/reference/imu/#references", 
            "text": "Below is the overview of the IMU sensor implementation. Code example can be found  here .  These header files are required to use the IMU sensor.  // Interfaces with IMU sensor  #include   matrix_hal/imu_sensor.h  // Holds data from IMU sensor  #include   matrix_hal/imu_data.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h   IMUData IMUData  is a required  object  that contains the IMU sensor's supported data parameters.  // Create IMUData object  matrix_hal :: IMUData   imu_data ;   The following code accesses the parameters of  IMUData .  // Accelerometer  float   accel_X   =   imu_data . accel_x ;  float   accel_Y   =   imu_data . accel_y ;  float   accel_Z   =   imu_data . accel_z ;  // Gyroscope  float   gyro_X   =   imu_data . gyro_x ;  float   gyro_Y   =   imu_data . gyro_y ;  float   gyro_Z   =   imu_data . gyro_z ;  // Yaw, Pitch, Roll Output  float   yaw   =   imu_data . yaw ;  float   pitch   =   imu_data . pitch ;  float   roll   =   imu_data . roll ;  // Magnetometer  float   mag_X   =   imu_data . mag_x ;  float   mag_Y   =   imu_data . mag_y ;  float   mag_Z   =   imu_data . mag_z ;   // Z-axis points upward    IMUSensor IMUSensor  is a required  object  that contains functions to interface with the IMU sensor.  // Create IMUSensor object  matrix_hal :: IMUSensor   imu_sensor ;   The functions below are part of  IMUSensor .  .Setup Setup  is a  function  that takes a  MatrixIOBus  object as a parameter and sets that object as the bus to use for communicating with MATRIX device.  // Function declaration in header file  void   Setup ( MatrixIOBus   * bus );   // Set imu_sensor to use MatrixIOBus bus  imu_sensor . Setup ( bus );    .Read Read  is a  function  that takes an  IMUData  object as a parameter and writes the current IMU sensor data into the  IMUData  object.  // Function declaration in header file  bool   Read ( IMUData   * data );   // Overwrites imu_data with new data from IMU sensor  imu_sensor . Read ( imu_data );", 
            "title": "References"
        }, 
        {
            "location": "/matrix-hal/reference/pressure/", 
            "text": "Pressure\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe pressure sensor reports values for:\n\n\n\n\nPressure\n\n\nAltitude\n\n\nTemperature\n\n\n\n\n\n\nBased on component location, the temperature values from the \nhumidity sensor\n are recommended over the pressure sensor.\n\n\n\n\nReferences\n\n\nBelow is the overview of the pressure sensor implementation. Code example can be found \nhere\n.\n\n\nThese header files are required to use the pressure sensor.\n\n\n// Interfaces with pressure sensor\n\n\n#include\n \nmatrix_hal/pressure_sensor.h\n\n\n// Holds data from pressure sensor\n\n\n#include\n \nmatrix_hal/pressure_data.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\nPressureData\nPressureData\n is a required \nobject\n that contains the pressure sensor's supported data parameters.\n\n\n// Create PressureData object\n\n\nmatrix_hal\n::\nPressureData\n \npressure_data\n;\n\n\n\n\n\nThe following code accesses the parameters of \nPressureData\n.\n\n\n// Output is represented in meters\n\n\nfloat\n \naltitude\n \n=\n \npressure_data\n.\naltitude\n;\n\n\n// Output is represented in Pa\n\n\nfloat\n \npressure\n \n=\n \npressure_data\n.\npressure\n;\n\n\n// Output is represented in Celsius\n\n\nfloat\n \ntemperature\n \n=\n \npressure_data\n.\ntemperature\n;\n\n\n\n\n\n\n\nPressureSensor\nPressureSensor\n is a required \nobject\n that contains functions to interface with the pressure sensor.\n\n\n// Create PressureSensor object\n\n\nmatrix_hal\n::\nPressureSensor\n \npressure_sensor\n;\n\n\n\nThe functions below are part of \nPressureSensor\n.\n\n\n.Setup\nSetup\n is a \nfunction\n that takes a \nMatrixIOBus\n object as a parameter and sets that object as the bus to use for communicating with MATRIX device.\n\n\n// Function declaration in header file\n\n\nvoid\n \nSetup\n(\nMatrixIOBus\n \n*\nbus\n);\n\n\n\n\n\n// Set pressure_sensor to use MatrixIOBus bus\n\n\npressure_sensor\n.\nSetup\n(\nbus\n);\n\n\n\n\n\n\n\n.Read\nRead\n is a \nfunction\n that takes a \nPressureData\n object as a parameter and writes the current pressure sensor data into the \nPressureData\n object.\n\n\n// Function declaration in header file\n\n\nbool\n \nRead\n(\nPressureData\n \n*\ndata\n);\n\n\n\n\n\n// Overwrites pressure_data with new data from pressure sensor\n\n\npressure_sensor\n.\nRead\n(\npressure_data\n);", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-hal/reference/pressure/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/reference/pressure/#overview", 
            "text": "The pressure sensor reports values for:   Pressure  Altitude  Temperature    Based on component location, the temperature values from the  humidity sensor  are recommended over the pressure sensor.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/reference/pressure/#references", 
            "text": "Below is the overview of the pressure sensor implementation. Code example can be found  here .  These header files are required to use the pressure sensor.  // Interfaces with pressure sensor  #include   matrix_hal/pressure_sensor.h  // Holds data from pressure sensor  #include   matrix_hal/pressure_data.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h   PressureData PressureData  is a required  object  that contains the pressure sensor's supported data parameters.  // Create PressureData object  matrix_hal :: PressureData   pressure_data ;   The following code accesses the parameters of  PressureData .  // Output is represented in meters  float   altitude   =   pressure_data . altitude ;  // Output is represented in Pa  float   pressure   =   pressure_data . pressure ;  // Output is represented in Celsius  float   temperature   =   pressure_data . temperature ;    PressureSensor PressureSensor  is a required  object  that contains functions to interface with the pressure sensor.  // Create PressureSensor object  matrix_hal :: PressureSensor   pressure_sensor ;  \nThe functions below are part of  PressureSensor .  .Setup Setup  is a  function  that takes a  MatrixIOBus  object as a parameter and sets that object as the bus to use for communicating with MATRIX device.  // Function declaration in header file  void   Setup ( MatrixIOBus   * bus );   // Set pressure_sensor to use MatrixIOBus bus  pressure_sensor . Setup ( bus );    .Read Read  is a  function  that takes a  PressureData  object as a parameter and writes the current pressure sensor data into the  PressureData  object.  // Function declaration in header file  bool   Read ( PressureData   * data );   // Overwrites pressure_data with new data from pressure sensor  pressure_sensor . Read ( pressure_data );", 
            "title": "References"
        }, 
        {
            "location": "/matrix-hal/reference/uv/", 
            "text": "UV\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe UV sensor reports values for:\n\n\n\n\nUV Index scale used in the United States, conforms with international guidelines for UVI reporting established by the World Health Organization.  From \nUV Index Scale\n\n\n\n\nReferences\n\n\nBelow is the overview of the UV sensor implementation. Code example can be found \nhere\n.\n\n\nThese header files are required to use the UV sensor.\n\n\n// Interfaces with UV sensor\n\n\n#include\n \nmatrix_hal/uv_sensor.h\n\n\n// Holds data from UV sensor\n\n\n#include\n \nmatrix_hal/uv_data.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\nUVData\nUVData\n is a required \nobject\n that contains the UV sensor's supported data parameters.\n\n\n// Create UVData object\n\n\nmatrix_hal\n::\nUVData\n \nuv_data\n;\n\n\n\n\n\nThe following code accesses the parameters of \nUVData\n.\n\n\n// Output is represented in UV Index\n\n\nfloat\n \nUV\n \n=\n \nuv_data\n.\nuv\n;\n\n\n\n\n\n\n\nUVSensor\nUVSensor\n is a required \nobject\n that contains functions to interface with the UV sensor.\n\n\n// Create UVSensor object\n\n\nmatrix_hal\n::\nUVSensor\n \nuv_sensor\n;\n\n\n\nThe functions below are part of \nUVSensor\n.\n\n\n.Setup\nSetup\n is a \nfunction\n that takes a \nMatrixIOBus\n object as a parameter and sets that object as the bus to use for communicating with MATRIX device.\n\n\n// Function declaration in header file\n\n\nvoid\n \nSetup\n(\nMatrixIOBus\n \n*\nbus\n);\n\n\n\n\n\n// Set uv_sensor to use MatrixIOBus bus\n\n\nuv_sensor\n.\nSetup\n(\nbus\n);\n\n\n\n\n\n\n\n.Read\nRead\n is a \nfunction\n that takes a \nUVData\n object as a parameter and writes the current humidity sensor data into the \nUVData\n object.\n\n\n// Function declaration in header file\n\n\nbool\n \nRead\n(\nUVData\n \n*\ndata\n);\n\n\n\n\n\n// Overwrites uv_data with new data from UV sensor\n\n\nuv_sensor\n.\nRead\n(\nuv_data\n);", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-hal/reference/uv/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/reference/uv/#overview", 
            "text": "The UV sensor reports values for:   UV Index scale used in the United States, conforms with international guidelines for UVI reporting established by the World Health Organization.  From  UV Index Scale", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/reference/uv/#references", 
            "text": "Below is the overview of the UV sensor implementation. Code example can be found  here .  These header files are required to use the UV sensor.  // Interfaces with UV sensor  #include   matrix_hal/uv_sensor.h  // Holds data from UV sensor  #include   matrix_hal/uv_data.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h   UVData UVData  is a required  object  that contains the UV sensor's supported data parameters.  // Create UVData object  matrix_hal :: UVData   uv_data ;   The following code accesses the parameters of  UVData .  // Output is represented in UV Index  float   UV   =   uv_data . uv ;    UVSensor UVSensor  is a required  object  that contains functions to interface with the UV sensor.  // Create UVSensor object  matrix_hal :: UVSensor   uv_sensor ;  \nThe functions below are part of  UVSensor .  .Setup Setup  is a  function  that takes a  MatrixIOBus  object as a parameter and sets that object as the bus to use for communicating with MATRIX device.  // Function declaration in header file  void   Setup ( MatrixIOBus   * bus );   // Set uv_sensor to use MatrixIOBus bus  uv_sensor . Setup ( bus );    .Read Read  is a  function  that takes a  UVData  object as a parameter and writes the current humidity sensor data into the  UVData  object.  // Function declaration in header file  bool   Read ( UVData   * data );   // Overwrites uv_data with new data from UV sensor  uv_sensor . Read ( uv_data );", 
            "title": "References"
        }, 
        {
            "location": "/matrix-hal/reference/gpio/", 
            "text": "General Purpose Input Output (GPIO)\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe GPIO interface supports:\n\n\n\n\nPin I/O input\n\n\nPin I/O output\n\n\nPin PWM output\n\n\n\n\nDevice Pinouts\n:\n\n\n\n\nMATRIX Creator\n\n\nMATRIX Voice\n\n\n\n\nReferences\n\n\nBelow is the overview of the GPIO implementation. Code examples can be found \nhere\n.\n\n\nThese header files are required to use GPIO.\n\n\n// Interfaces with GPIO\n\n\n#include\n \nmatrix_hal/gpio_control.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\nGPIOControl\nGPIOControl\n is a required \nobject\n that contains functions to interface with GPIO.\n\n\n// Create GPIOControl object\n\n\nmatrix_hal\n::\nGPIOControl\n \ngpio\n;\n\n\n\n\n\nThe functions below are part of \nGPIOControl\n.\n\n\n.Setup\nSetup\n is a \nfunction\n that takes a \nMatrixIOBus\n object as a parameter and sets that object as the bus to use for communicating with MATRIX device.\n\n\n// Function declaration in header file\n\n\nvoid\n \nSetup\n(\nMatrixIOBus\n \n*\nbus\n);\n\n\n\n\n\n// Set gpio to use MatrixIOBus bus\n\n\ngpio\n.\nSetup\n(\nbus\n);\n\n\n\n\n\n\n\n.Banks\nBanks\n is a \nfunction\n that returns a \nbanks_\n array of \nGPIOBank\n objects.\n\n\n// Function declaration in header file\n\n\nGPIOBank\n \nBank\n(\nuint16_t\n \nbank\n)\n \n{\n \nreturn\n \nbanks_\n[\nbank\n];\n \n}\n\n\n\n\n\n// Returns banks_[index]\n\n\ngpio\n.\nBanks\n(\nindex\n);\n\n\n\n\n\n\n\n.SetMode\nSetMode\n is a \nfunction\n that sets GPIO pin(s) to output or input.\n\nSetMode\n is overloaded, and there are two definitions for the function.\n\n\nFor setting single GPIO pin.\n\n\n// Function declaration in header file\n\n\n// For setting single GPIO pin\n\n\nbool\n \nSetMode\n(\nuint16_t\n \npin\n,\n \nuint16_t\n \nmode\n);\n\n\n\n\n\n// Sets pin 0 to output\n\n\ngpio\n.\nSetMode\n(\n0\n,\n \n1\n);\n\n\n// Sets pin 0 to input\n\n\ngpio\n.\nSetMode\n(\n0\n,\n \n0\n);\n\n\n\n\n\nFor setting multiple GPIO pins.\n\n\n// Function declaration in header file\n\n\n// For setting multiple pins\n\n\nbool\n \nSetMode\n(\nunsigned\n \nchar\n \n*\npinList\n,\n \nint\n \nlength\n,\n \nuint16_t\n \nmode\n);\n\n\n\n\n\nunsigned\n \nchar\n \ninputPinList\n[\n8\n]\n \n=\n \n{\n0\n,\n \n2\n,\n \n4\n,\n \n6\n,\n \n8\n,\n \n10\n,\n \n12\n,\n \n14\n};\n\n\nunsigned\n \nchar\n \noutputPinList\n[\n8\n]\n \n=\n \n{\n1\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n9\n,\n \n11\n,\n \n13\n,\n \n15\n};\n\n\n\n// Sets pins in inputPinList to input\n\n\ngpio\n.\nSetMode\n(\ninputPinList\n,\n \nsizeof\n(\ninputPinList\n),\n \n0\n);\n\n\n// Sets pins in outputPinList to output\n\n\ngpio\n.\nSetMode\n(\noutputPinList\n,\n \nsizeof\n(\noutputPinList\n),\n \n1\n);\n\n\n\n\n\n\n\n.SetFunction\nSetFunction\n is a \nfunction\n that sets a single GPIO pin to I/O or PWM mode.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetFunction\n(\nuint16_t\n \npin\n,\n \nuint16_t\n \nfunction\n);\n\n\n\n\n\n// Sets pin 0 to I/O mode\n\n\ngpio\n.\nSetFunction\n(\n0\n,\n \n0\n);\n\n\n// Sets pin 0 to PWM mode\n\n\ngpio\n.\nSetFunction\n(\n0\n,\n \n1\n);\n\n\n\n\n\n\n\n.GetGPIOValue\nGetGPIOValue\n is a \nfunction\n that returns a GPIO value.\n\n\n// Function declaration in header file\n\n\nuint16_t\n \nGetGPIOValue\n(\nuint16_t\n \npin\n);\n\n\n\n\n\n// Gets value of pin 0\n\n\nbool\n \nvalue\n \n=\n \ngpio\n.\nGetGPIOValue\n(\n0\n);\n\n\n\n\n\n\n\n.GetGPIOValues\nGetGPIOValues\n is a \nfunction\n that returns all GPIO values, each bit of the returned 16bit integer represents a pin.\n\n\n// Function declaration in header file\n\n\nuint16_t\n \nGetGPIOValues\n();\n\n\n\n\n\n// Gets all pin values\n\n\nuint16_t\n \nvalues\n \n=\n \ngpio\n.\nGetGPIOValues\n();\n\n\n\n\n\n\n\n.SetGPIOValue\nSetGPIOValue\n is a \nfunction\n that sets a GPIO value.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetGPIOValue\n(\nuint16_t\n \npin\n,\n \nuint16_t\n \nvalue\n);\n\n\n\n\n\n// Sets pin 0 to on\n\n\ngpio\n.\nSetGPIOValue\n(\n0\n,\n \n1\n);\n\n\n// Sets pin 0 to off\n\n\ngpio\n.\nSetGPIOValue\n(\n0\n,\n \n0\n);\n\n\n\n\n\n\n\n.SetGPIOValues\nSetGPIOValues\n is a \nfunction\n that sets multiple GPIO values.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetGPIOValues\n(\nunsigned\n \nchar\n \n*\npinList\n,\n \nint\n \nlength\n,\n \nuint16_t\n \nvalue\n);\n\n\n\n\n\nunsigned\n \nchar\n \nonPinList\n[\n8\n]\n \n=\n \n{\n0\n,\n \n2\n,\n \n4\n,\n \n6\n,\n \n8\n,\n \n10\n,\n \n12\n,\n \n14\n};\n\n\nunsigned\n \nchar\n \noffPinList\n[\n8\n]\n \n=\n \n{\n1\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n9\n,\n \n11\n,\n \n13\n,\n \n15\n};\n\n\n\n// Sets pins in onPinList to on\n\n\ngpio\n.\nSetGPIOValues\n(\nonPinList\n,\n \nsizeof\n(\nonPinList\n),\n \n1\n);\n\n\n// Sets pins in offPinList to off\n\n\ngpio\n.\nSetGPIOValues\n(\noffPinList\n,\n \nsizeof\n(\noffPinList\n),\n \n0\n);\n\n\n\n\n\n\n\n.SetPrescaler\nSetPrescaler\n is a \nfunction\n that sets the prescaler for the FPGA clock.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetPrescaler\n(\nuint16_t\n \nbank\n,\n \nuint16_t\n \nprescaler\n);\n\n\n\n\n\n// Set prescaler for bank 0 to 32\n\n\n// 2^5 = 32\n\n\ngpio\n.\nSetPrescaler\n(\n0\n,\n \n5\n);\n\n\n\n\n\n\n\n.Set9GServoAngle\nSet9GServoAngle\n is a \nfunction\n that sets a servo angle. It is based on SG90 servo calibration.\n\n\n// Function declaration in header file\n\n\nbool\n \nSet9GServoAngle\n(\nfloat\n \nangle\n,\n \nuint16_t\n \npin\n);\n\n\n\n\n\n// Set servo angle to 70 degrees on pin 0\n\n\ngpio\n.\nSetPrescaler\n(\n70\n,\n \n0\n);\n\n\n\n\n\n\n\n.SetServoAngle\nSetServoAngle\n is a \nfunction\n that sets a servo angle. It is based on the min_pulse_ms entered.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetServoAngle\n(\nfloat\n \nangle\n,\n \nfloat\n \nmin_pulse_ms\n,\n \nuint16_t\n \npin\n);\n\n\n\n\n\n// Set servo angle to 70 degrees on pin 0\n\n\n// For a servo that accepts a minimum pulse of 0.8ms\n\n\ngpio\n.\nSetServoAngle\n(\n70\n,\n \n0.8\n,\n \n0\n);\n\n\n\n\n\n\n\n.SetPWM\nSetPWM\n is a \nfunction\n that sets a PWM output.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetPWM\n(\nfloat\n \nfrequency\n,\n \nfloat\n \npercentage\n,\n \nuint16_t\n \npin\n);\n\n\n\n\n\n// Set PWM output to 50Hz, with a 25% duty cycle on pin 0\n\n\ngpio\n.\nSetPWM\n(\n50\n,\n \n25\n,\n \n0\n);\n\n\n\n\n\n\n\n\n\nGPIOBank\nGPIOBank\n is an \nobject\n that contains functions to interface with GPIO PWM. \nGPIOControl\n contains an array of \nGPIOBank\n objects, called \nbanks\n_\n\n\nPWM Frequency is set by bank. A bank is a set of 4 pins, starting from pin 0 and going in order. Bank 0 is pin 0-3, Bank 1 is pin 4-7 etc.\n\n\nThe functions below are part of \nGPIOBank\n.\n\n\n.SetPeriod\nSetPeriod\n is a \nfunction\n that sets the PWM period.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetPeriod\n(\nuint16_t\n \nperiod\n);\n\n\n\n\n\n// Set PWM period for bank 0 to 50000 FPGA clock ticks\n\n\ngpio\n.\nBanks\n(\n0\n).\nSetPeriod\n(\n50000\n);\n\n\n\n\n\n\n\n.SetDuty\nSetDuty\n is a \nfunction\n that sets the PWM duty.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetDuty\n(\nuint16_t\n \nchannel\n,\n \nuint16_t\n \nduty\n);\n\n\n\n\n\n// Set PWM duty for channel 0 of bank 0 to 10000 FPGA clock ticks\n\n\ngpio\n.\nBanks\n(\n0\n).\nSetDuty\n(\n0\n,\n \n10000\n);\n\n\n\n\n\n\n\n.SetupTimer\n\n\nUnder Maintenance\n\n\n\n\nSetupTimer\n is a \nfunction\n that sets up the timer.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetupTimer\n(\nuint16_t\n \nchannel\n,\n \nuint16_t\n \ninit_event\n,\n \nuint16_t\n \nfinal_event\n);\n\n\n\n\n\n\n\n.GetTimerCounter\n\n\nUnder Maintenance\n\n\n\n\nGetTimerCounter\n is a \nfunction\n that returns the timer counter.\n\n\n// Function declaration in header file\n\n\nuint16_t\n \nGetTimerCounter\n(\nuint16_t\n \nchannel\n);", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-hal/reference/gpio/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/reference/gpio/#overview", 
            "text": "The GPIO interface supports:   Pin I/O input  Pin I/O output  Pin PWM output   Device Pinouts :   MATRIX Creator  MATRIX Voice", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/reference/gpio/#references", 
            "text": "Below is the overview of the GPIO implementation. Code examples can be found  here .  These header files are required to use GPIO.  // Interfaces with GPIO  #include   matrix_hal/gpio_control.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h   GPIOControl GPIOControl  is a required  object  that contains functions to interface with GPIO.  // Create GPIOControl object  matrix_hal :: GPIOControl   gpio ;   The functions below are part of  GPIOControl .  .Setup Setup  is a  function  that takes a  MatrixIOBus  object as a parameter and sets that object as the bus to use for communicating with MATRIX device.  // Function declaration in header file  void   Setup ( MatrixIOBus   * bus );   // Set gpio to use MatrixIOBus bus  gpio . Setup ( bus );    .Banks Banks  is a  function  that returns a  banks_  array of  GPIOBank  objects.  // Function declaration in header file  GPIOBank   Bank ( uint16_t   bank )   {   return   banks_ [ bank ];   }   // Returns banks_[index]  gpio . Banks ( index );    .SetMode SetMode  is a  function  that sets GPIO pin(s) to output or input. SetMode  is overloaded, and there are two definitions for the function.  For setting single GPIO pin.  // Function declaration in header file  // For setting single GPIO pin  bool   SetMode ( uint16_t   pin ,   uint16_t   mode );   // Sets pin 0 to output  gpio . SetMode ( 0 ,   1 );  // Sets pin 0 to input  gpio . SetMode ( 0 ,   0 );   For setting multiple GPIO pins.  // Function declaration in header file  // For setting multiple pins  bool   SetMode ( unsigned   char   * pinList ,   int   length ,   uint16_t   mode );   unsigned   char   inputPinList [ 8 ]   =   { 0 ,   2 ,   4 ,   6 ,   8 ,   10 ,   12 ,   14 };  unsigned   char   outputPinList [ 8 ]   =   { 1 ,   3 ,   5 ,   7 ,   9 ,   11 ,   13 ,   15 };  // Sets pins in inputPinList to input  gpio . SetMode ( inputPinList ,   sizeof ( inputPinList ),   0 );  // Sets pins in outputPinList to output  gpio . SetMode ( outputPinList ,   sizeof ( outputPinList ),   1 );    .SetFunction SetFunction  is a  function  that sets a single GPIO pin to I/O or PWM mode.  // Function declaration in header file  bool   SetFunction ( uint16_t   pin ,   uint16_t   function );   // Sets pin 0 to I/O mode  gpio . SetFunction ( 0 ,   0 );  // Sets pin 0 to PWM mode  gpio . SetFunction ( 0 ,   1 );    .GetGPIOValue GetGPIOValue  is a  function  that returns a GPIO value.  // Function declaration in header file  uint16_t   GetGPIOValue ( uint16_t   pin );   // Gets value of pin 0  bool   value   =   gpio . GetGPIOValue ( 0 );    .GetGPIOValues GetGPIOValues  is a  function  that returns all GPIO values, each bit of the returned 16bit integer represents a pin.  // Function declaration in header file  uint16_t   GetGPIOValues ();   // Gets all pin values  uint16_t   values   =   gpio . GetGPIOValues ();    .SetGPIOValue SetGPIOValue  is a  function  that sets a GPIO value.  // Function declaration in header file  bool   SetGPIOValue ( uint16_t   pin ,   uint16_t   value );   // Sets pin 0 to on  gpio . SetGPIOValue ( 0 ,   1 );  // Sets pin 0 to off  gpio . SetGPIOValue ( 0 ,   0 );    .SetGPIOValues SetGPIOValues  is a  function  that sets multiple GPIO values.  // Function declaration in header file  bool   SetGPIOValues ( unsigned   char   * pinList ,   int   length ,   uint16_t   value );   unsigned   char   onPinList [ 8 ]   =   { 0 ,   2 ,   4 ,   6 ,   8 ,   10 ,   12 ,   14 };  unsigned   char   offPinList [ 8 ]   =   { 1 ,   3 ,   5 ,   7 ,   9 ,   11 ,   13 ,   15 };  // Sets pins in onPinList to on  gpio . SetGPIOValues ( onPinList ,   sizeof ( onPinList ),   1 );  // Sets pins in offPinList to off  gpio . SetGPIOValues ( offPinList ,   sizeof ( offPinList ),   0 );    .SetPrescaler SetPrescaler  is a  function  that sets the prescaler for the FPGA clock.  // Function declaration in header file  bool   SetPrescaler ( uint16_t   bank ,   uint16_t   prescaler );   // Set prescaler for bank 0 to 32  // 2^5 = 32  gpio . SetPrescaler ( 0 ,   5 );    .Set9GServoAngle Set9GServoAngle  is a  function  that sets a servo angle. It is based on SG90 servo calibration.  // Function declaration in header file  bool   Set9GServoAngle ( float   angle ,   uint16_t   pin );   // Set servo angle to 70 degrees on pin 0  gpio . SetPrescaler ( 70 ,   0 );    .SetServoAngle SetServoAngle  is a  function  that sets a servo angle. It is based on the min_pulse_ms entered.  // Function declaration in header file  bool   SetServoAngle ( float   angle ,   float   min_pulse_ms ,   uint16_t   pin );   // Set servo angle to 70 degrees on pin 0  // For a servo that accepts a minimum pulse of 0.8ms  gpio . SetServoAngle ( 70 ,   0.8 ,   0 );    .SetPWM SetPWM  is a  function  that sets a PWM output.  // Function declaration in header file  bool   SetPWM ( float   frequency ,   float   percentage ,   uint16_t   pin );   // Set PWM output to 50Hz, with a 25% duty cycle on pin 0  gpio . SetPWM ( 50 ,   25 ,   0 );     GPIOBank GPIOBank  is an  object  that contains functions to interface with GPIO PWM.  GPIOControl  contains an array of  GPIOBank  objects, called  banks _  PWM Frequency is set by bank. A bank is a set of 4 pins, starting from pin 0 and going in order. Bank 0 is pin 0-3, Bank 1 is pin 4-7 etc.  The functions below are part of  GPIOBank .  .SetPeriod SetPeriod  is a  function  that sets the PWM period.  // Function declaration in header file  bool   SetPeriod ( uint16_t   period );   // Set PWM period for bank 0 to 50000 FPGA clock ticks  gpio . Banks ( 0 ). SetPeriod ( 50000 );    .SetDuty SetDuty  is a  function  that sets the PWM duty.  // Function declaration in header file  bool   SetDuty ( uint16_t   channel ,   uint16_t   duty );   // Set PWM duty for channel 0 of bank 0 to 10000 FPGA clock ticks  gpio . Banks ( 0 ). SetDuty ( 0 ,   10000 );    .SetupTimer  Under Maintenance   SetupTimer  is a  function  that sets up the timer.  // Function declaration in header file  bool   SetupTimer ( uint16_t   channel ,   uint16_t   init_event ,   uint16_t   final_event );    .GetTimerCounter  Under Maintenance   GetTimerCounter  is a  function  that returns the timer counter.  // Function declaration in header file  uint16_t   GetTimerCounter ( uint16_t   channel );", 
            "title": "References"
        }, 
        {
            "location": "/matrix-hal/reference/microphone/", 
            "text": "Microphone Array\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe microphone array interface supports:\n\n\n\n\nAccepting input from individual microphones\n\n\nAccepting input from beamformed microphone\n\n\n\n\nReferences\n\n\nBelow is the overview of the microphone array implementation. Code examples can be found \nhere\n.\n\n\nThese header files are required to use the microphone array.\n\n\n// Interfaces with microphone array\n\n\n#include\n \nmatrix_hal/microphone_array.h\n\n\n// Enables using FIR filter with microphone array\n\n\n#include\n \nmatrix_hal/microphone_core.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\nMicrophoneArray\nMicrophoneArray\n is a required \nobject\n that contains functions to interface with the microphone array.\n\n\n// Create MicrophoneArray object\n\n\nmatrix_hal\n::\nMicrophoneArray\n \nmicrophone_array\n;\n\n\n\n\n\nThe functions below are part of \nMicrophoneArray\n.\n\n\n.Setup\nSetup\n is a \nfunction\n that takes a \nMatrixIOBus\n object as a parameter and sets that object as the bus to use for communicating with MATRIX device.\n\n\n// Function declaration in header file\n\n\nvoid\n \nSetup\n(\nMatrixIOBus\n \n*\nbus\n);\n\n\n\n\n\n// Set microphone_array to use MatrixIOBus bus\n\n\nmicrophone_array\n.\nSetup\n(\nbus\n);\n\n\n\n\n\n\n\n.Read\nRead\n is a \nfunction\n that outputs microphone array data to the \ndelayed_data_\n array and the \nbeamformed_\n array in the \nMicrophoneArray\n object.\n\n\n// Function declaration in header file\n\n\nbool\n \nRead\n();\n\n\n\n\n\n// Reading 8-mics buffer from the FPGA\n\n\nmicrophone_array\n.\nRead\n();\n\n\n\n\n\n\n\n.SamplingRate\nSamplingRate\n is a \nfunction\n that returns the \nsampling_frequency_\n value in the \nMicrophoneArray\n object.\n\n\n// Function declaration in header file\n\n\nuint32_t\n \nSamplingRate\n()\n \n{\n \nreturn\n \nsampling_frequency_\n;\n \n}\n\n\n\n\n\n// Return the stored sampling rate\n\n\nuint32_t\n \nSamplingRate\n \n=\n \nmicrophone_array\n.\nSamplingRate\n();\n\n\n\n\n\n\n\n.Gain\nGain\n is a \nfunction\n that returns the \ngain_\n value in the \nMicrophoneArray\n object.\n\n\n// Function declaration in header file\n\n\nuint16_t\n \nGain\n()\n \n{\n \nreturn\n \ngain_\n;\n \n}\n\n\n\n\n\n// Return the stored gain\n\n\nuint32_t\n \nGain\n \n=\n \nmicrophone_array\n.\nGain\n();\n\n\n\n\n\n\n\n.SetSamplingRate\nSetSamplingRate\n is a \nfunction\n that sets the \nsampling_frequency_\n value in the \nMicrophoneArray\n object and sends it to the microphone array.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetSamplingRate\n(\nuint32_t\n \nsampling_frequency\n);\n\n\n\n\n\n// Set the sampling rate\n\n\nmicrophone_array\n.\nSetSamplingRate\n(\nsampling_rate\n);\n\n\n\n\n\n\n\n.SetGain\nSetGain\n is a \nfunction\n that sets the \ngain_\n value in the \nMicrophoneArray\n object and sends it to the microphone array.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetGain\n(\nuint16_t\n \ngain\n);\n\n\n\n\n\n// Set the gain\n\n\nmicrophone_array\n.\nSetGain\n(\ngain\n);\n\n\n\n\n\n\n\n.GetSamplingRate\nGetSamplingRate\n is a \nfunction\n that gets the sampling rate value from the microphone array and saves it in the \nMicrophoneArray\n object as value \nsampling_frequency_\n.\n\n\n// Function declaration in header file\n\n\nbool\n \nGetSamplingRate\n();\n\n\n\n\n\n// Update sampling_frequency_ from microphone array\n\n\nmicrophone_array\n.\nGetSamplingRate\n();\n\n\n\n\n\n\n\n.GetGain\nGetGain\n is a \nfunction\n that gets the gain value from the microphone array and saves it in the \nMicrophoneArray\n object as value \ngain_\n.\n\n\n// Function declaration in header file\n\n\nbool\n \nGetGain\n();\n\n\n\n\n\n// Update gain_ from microphone array\n\n\nmicrophone_array\n.\nGetGain\n();\n\n\n\n\n\n\n\n.ReadConfValues\nReadConfValues\n is a \nfunction\n that runs both the \nGetGain\n and \nGetSamplingRate\n functions. \nThis updates the \ngain_\n and the \nsampling_frequency_\n values in the \nMicrophoneArray\n object with values from the microphone array.\n\n\n// Function declaration in header file\n\n\nvoid\n \nReadConfValues\n();\n\n\n\n\n\n// Update values from microphone array\n\n\nmicrophone_array\n.\nReadConfValues\n();\n\n\n\n\n\n\n\n.ShowConfiguration\nShowConfiguration\n is a \nfunction\n that outputs the \ngain_\n and \nsampling_frequency_\n values in the \nMicrophoneArray\n object.\n\n\n// Function declaration in header file\n\n\nvoid\n \nShowConfiguration\n();\n\n\n\n\n\n// Output `gain_` and `sampling_frequency_` values\n\n\nmicrophone_array\n.\nvoid\n \nShowConfiguration\n();\n\n\n\n\n\n// Style of output\n\n\nstd\n::\ncout\n \n \nAudio Configuration: \n \n \nstd\n::\nendl\n;\n\n\nstd\n::\ncout\n \n \nSampling Frequency: \n \n \nsampling_frequency_\n \n \nstd\n::\nendl\n;\n\n\nstd\n::\ncout\n \n \nGain : \n \n \ngain_\n \n \nstd\n::\nendl\n;\n\n\n\n\n\n\n\n.Channels\nChannels\n is a \nfunction\n that returns the number of microphone channels.\n\n\n// Function declaration in header file\n\n\nuint16_t\n \nChannels\n()\n \n{\n \nreturn\n \nkMicrophoneChannels\n;\n \n}\n\n\n\n\n\n// Return the number of channels\n\n\nuint16_t\n \nChannels\n \n=\n \nmicrophone_array\n.\nChannels\n();\n\n\n\n\n\n\n\n.NumberOfSamples\nNumberOfSamples\n is a \nfunction\n that returns the number of samples.\n\n\n// Function declaration in header file\n\n\nuint32_t\n \nNumberOfSamples\n()\n \n{\n\n    \nreturn\n \nkMicarrayBufferSize\n \n/\n \nkMicrophoneChannels\n;\n\n\n}\n\n\n\n\n\n// Return the number of samples\n\n\nuint16_t\n \nSampleAmount\n \n=\n \nmicrophone_array\n.\nNumberOfSamples\n();\n\n\n\n\n\n\n\n.At\nAt\n is a \nfunction\n that returns microphone data from the \ndelayed_data_\n array. The \nRead\n function populates the \ndelayed_data_\n array.\n\n\n// Function declaration in header file\n\n\nint16_t\n \nAt\n(\nint16_t\n \nsample\n,\n \nint16_t\n \nchannel\n)\n \n{\n\n    \nreturn\n \ndelayed_data_\n[\nsample\n \n*\n \nkMicrophoneChannels\n \n+\n \nchannel\n];\n\n\n}\n\n\n\n\n\n// Return a single sample\n\n\nint16_t\n \nsample\n \n=\n \nmicrophone_array\n.\nAt\n(\ns\n,\n \nc\n);\n\n\n\n\n\n\n\n.Beam\nBeam\n is a \nfunction\n that returns beamformed microphone data from the \nbeamformed_\n array. The \nRead\n function populates the \nbeamformed_\n array.\n\n\n// Function declaration in header file\n\n\nint16_t\n \nBeam\n(\nint16_t\n \nsample\n)\n \n{\n \nreturn\n \nbeamformed_\n[\nsample\n];\n \n}\n\n\n\n\n\n// Return a single sample\n\n\nint16_t\n \nsample\n \n=\n \nmicrophone_array\n.\nBeam\n(\ns\n);\n\n\n\n\n\n\n\n.CalculateDelays\nCalculateDelays\n is a \nfunction\n that calculates and sets up delays for beamforming.\n\n\n// Function declaration in header file\n\n\nvoid\n \nCalculateDelays\n(\nfloat\n \nazimutal_angle\n,\n \nfloat\n \npolar_angle\n,\n\n                    \nfloat\n \nradial_distance_mm\n \n=\n \n100.0\n,\n\n                    \nfloat\n \nsound_speed_mmseg\n \n=\n \n320\n \n*\n \n1000.0\n);\n\n\n\n\n\n// Calculate and set up beamforming delays\n\n\nmicrophone_array\n.\nCalculateDelays\n(\n0\n,\n \n0\n,\n \n1000\n,\n \n320\n \n*\n \n1000\n);\n\n\n\n\n\n\n\n\n\nMicrophoneCore\nMicrophoneCore\n is an optional \nobject\n that contains functions to enable using a \nFIR\n filter with microphone array. It accepts a \nMicrophoneArray\n object in it's constructor.\n\n\n// Constructor declaration in header file\n\n\nMicrophoneCore\n(\nMicrophoneArray\n \nmicrophone_array\n);\n\n\n\n\n\n\n// Create MicrophoneCore object\n\n\nmatrix_hal\n::\nMicrophoneCore\n \nmicrophone_core\n(\nmicrophone_array\n);\n\n\n\n\nThe functions below are part of \nMicrophoneCore\n.\n\n\n.Setup\nSetup\n is a \nfunction\n that takes a \nMatrixIOBus\n object as a parameter and sets that object as the bus to use for communicating with MATRIX device. It also sets up the FIR filter by calling \nSelectFIRCoeff(\nFIR_default[0])\n.\n\n\n// Function declaration in header file\n\n\nvoid\n \nSetup\n(\nMatrixIOBus\n \n*\nbus\n);\n\n\n\n\n\n// Set microphone_core to use MatrixIOBus bus\n\n\nmicrophone_core\n.\nSetup\n(\nbus\n);\n\n\n\n\n\n\n\n.SetFIRCoeff\nSetFIRCoeff\n is a \nfunction\n that sends the \nfir_coeff_\n array in the \nMicrophoneCore\n object to the FPGA.\n\n\n// Function declaration in header file\n\n\nbool\n \nSetFIRCoeff\n();\n\n\n\n\n\n\n// Sends fir_coeff_ to FPGA\n\n\nmicrophone_core\n.\nSetFIRCoeff\n();\n\n\n\n\n\n\n.SetCustomFIRCoeff\nSetCustomFIRCoeff\n is a \nfunction\n that sets the \nfir_coeff_\n array in the \nMicrophoneCore\n object.\n\n\nIf input is valid then the function also calls \nSetFIRCoeff\n to send the \nfir_coeff_\n array in the \nMicrophoneCore\n object to the FPGA.\n\n\nbool\n \nSetCustomFIRCoeff\n(\nconst\n \nstd\n::\nvalarray\nint16_t\n \ncustom_fir\n);\n\n\n\n\n\n// Sets fir_coeff_ to custom_fir\n\n\nmicrophone_core\n.\nSetCustomFIRCoeff\n(\ncustom_fir\n);\n\n\n\n\n\n\n\n.SelectFIRCoeff\nSelectFIRCoeff\n is a \nfunction\n that sets the \nfir_coeff_\n array in the \nMicrophoneCore\n object. \n\n\nIf input is valid then the function also calls \nSetFIRCoeff\n to send the \nfir_coeff_\n array in the \nMicrophoneCore\n object to the FPGA.\n\n\nThis function accepts a FIRCoeff struct, which is defined below.\n\n\n// FIRCoeff definition in header file\n\n\nstruct\n \nFIRCoeff\n \n{\n\n\nuint32_t\n \nrate_\n;\n\n\nstd\n::\nvalarray\nint16_t\n \ncoeff_\n;\n\n\n};\n\n\n\n\n\nbool\n \nSelectFIRCoeff\n(\nFIRCoeff\n \n*\nFIR_coeff\n);\n\n\n\n\n\n// Sets fir_coeff_ from FIR_default[0]\n\n\nmicrophone_core\n.\nSelectFIRCoeff\n(\nFIR_default\n[\n0\n]);\n\n\n\n\n\n\n\nProvided FIR Filters\nA FIR filter is provided in \nmatrix_hal/microphone_core_fir.h\n.\n\n\nThis filter provided is in the form of a FIRCoeff struct, which is defined below.\n\n\n// FIRCoeff definition in header file\n\n\nstruct\n \nFIRCoeff\n \n{\n\n\nuint32_t\n \nrate_\n;\n\n\nstd\n::\nvalarray\nint16_t\n \ncoeff_\n;\n\n\n};\n\n\n\n\n\nTo use the provided FIR filter the \nSelectFIRCoeff\n function is used to set it, then the \nSetFIRCoeff\n function is used to send it to the FPGA.\n\n\n// Sets fir_coeff_ from FIR_default[0]\n\n\nmicrophone_core\n.\nSelectFIRCoeff\n(\nFIR_default\n[\n0\n]);\n\n\n// Sends FIR filter in fir_coeff_ to FPGA\n\n\nmicrophone_core\n.\nSetFIRCoeff\n();", 
            "title": "Microphone"
        }, 
        {
            "location": "/matrix-hal/reference/microphone/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/reference/microphone/#overview", 
            "text": "The microphone array interface supports:   Accepting input from individual microphones  Accepting input from beamformed microphone", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/reference/microphone/#references", 
            "text": "Below is the overview of the microphone array implementation. Code examples can be found  here .  These header files are required to use the microphone array.  // Interfaces with microphone array  #include   matrix_hal/microphone_array.h  // Enables using FIR filter with microphone array  #include   matrix_hal/microphone_core.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h   MicrophoneArray MicrophoneArray  is a required  object  that contains functions to interface with the microphone array.  // Create MicrophoneArray object  matrix_hal :: MicrophoneArray   microphone_array ;   The functions below are part of  MicrophoneArray .  .Setup Setup  is a  function  that takes a  MatrixIOBus  object as a parameter and sets that object as the bus to use for communicating with MATRIX device.  // Function declaration in header file  void   Setup ( MatrixIOBus   * bus );   // Set microphone_array to use MatrixIOBus bus  microphone_array . Setup ( bus );    .Read Read  is a  function  that outputs microphone array data to the  delayed_data_  array and the  beamformed_  array in the  MicrophoneArray  object.  // Function declaration in header file  bool   Read ();   // Reading 8-mics buffer from the FPGA  microphone_array . Read ();    .SamplingRate SamplingRate  is a  function  that returns the  sampling_frequency_  value in the  MicrophoneArray  object.  // Function declaration in header file  uint32_t   SamplingRate ()   {   return   sampling_frequency_ ;   }   // Return the stored sampling rate  uint32_t   SamplingRate   =   microphone_array . SamplingRate ();    .Gain Gain  is a  function  that returns the  gain_  value in the  MicrophoneArray  object.  // Function declaration in header file  uint16_t   Gain ()   {   return   gain_ ;   }   // Return the stored gain  uint32_t   Gain   =   microphone_array . Gain ();    .SetSamplingRate SetSamplingRate  is a  function  that sets the  sampling_frequency_  value in the  MicrophoneArray  object and sends it to the microphone array.  // Function declaration in header file  bool   SetSamplingRate ( uint32_t   sampling_frequency );   // Set the sampling rate  microphone_array . SetSamplingRate ( sampling_rate );    .SetGain SetGain  is a  function  that sets the  gain_  value in the  MicrophoneArray  object and sends it to the microphone array.  // Function declaration in header file  bool   SetGain ( uint16_t   gain );   // Set the gain  microphone_array . SetGain ( gain );    .GetSamplingRate GetSamplingRate  is a  function  that gets the sampling rate value from the microphone array and saves it in the  MicrophoneArray  object as value  sampling_frequency_ .  // Function declaration in header file  bool   GetSamplingRate ();   // Update sampling_frequency_ from microphone array  microphone_array . GetSamplingRate ();    .GetGain GetGain  is a  function  that gets the gain value from the microphone array and saves it in the  MicrophoneArray  object as value  gain_ .  // Function declaration in header file  bool   GetGain ();   // Update gain_ from microphone array  microphone_array . GetGain ();    .ReadConfValues ReadConfValues  is a  function  that runs both the  GetGain  and  GetSamplingRate  functions. \nThis updates the  gain_  and the  sampling_frequency_  values in the  MicrophoneArray  object with values from the microphone array.  // Function declaration in header file  void   ReadConfValues ();   // Update values from microphone array  microphone_array . ReadConfValues ();    .ShowConfiguration ShowConfiguration  is a  function  that outputs the  gain_  and  sampling_frequency_  values in the  MicrophoneArray  object.  // Function declaration in header file  void   ShowConfiguration ();   // Output `gain_` and `sampling_frequency_` values  microphone_array . void   ShowConfiguration ();   // Style of output  std :: cout     Audio Configuration:      std :: endl ;  std :: cout     Sampling Frequency:      sampling_frequency_     std :: endl ;  std :: cout     Gain :      gain_     std :: endl ;    .Channels Channels  is a  function  that returns the number of microphone channels.  // Function declaration in header file  uint16_t   Channels ()   {   return   kMicrophoneChannels ;   }   // Return the number of channels  uint16_t   Channels   =   microphone_array . Channels ();    .NumberOfSamples NumberOfSamples  is a  function  that returns the number of samples.  // Function declaration in header file  uint32_t   NumberOfSamples ()   { \n     return   kMicarrayBufferSize   /   kMicrophoneChannels ;  }   // Return the number of samples  uint16_t   SampleAmount   =   microphone_array . NumberOfSamples ();    .At At  is a  function  that returns microphone data from the  delayed_data_  array. The  Read  function populates the  delayed_data_  array.  // Function declaration in header file  int16_t   At ( int16_t   sample ,   int16_t   channel )   { \n     return   delayed_data_ [ sample   *   kMicrophoneChannels   +   channel ];  }   // Return a single sample  int16_t   sample   =   microphone_array . At ( s ,   c );    .Beam Beam  is a  function  that returns beamformed microphone data from the  beamformed_  array. The  Read  function populates the  beamformed_  array.  // Function declaration in header file  int16_t   Beam ( int16_t   sample )   {   return   beamformed_ [ sample ];   }   // Return a single sample  int16_t   sample   =   microphone_array . Beam ( s );    .CalculateDelays CalculateDelays  is a  function  that calculates and sets up delays for beamforming.  // Function declaration in header file  void   CalculateDelays ( float   azimutal_angle ,   float   polar_angle , \n                     float   radial_distance_mm   =   100.0 , \n                     float   sound_speed_mmseg   =   320   *   1000.0 );   // Calculate and set up beamforming delays  microphone_array . CalculateDelays ( 0 ,   0 ,   1000 ,   320   *   1000 );     MicrophoneCore MicrophoneCore  is an optional  object  that contains functions to enable using a  FIR  filter with microphone array. It accepts a  MicrophoneArray  object in it's constructor.  // Constructor declaration in header file  MicrophoneCore ( MicrophoneArray   microphone_array );    // Create MicrophoneCore object  matrix_hal :: MicrophoneCore   microphone_core ( microphone_array );   The functions below are part of  MicrophoneCore .  .Setup Setup  is a  function  that takes a  MatrixIOBus  object as a parameter and sets that object as the bus to use for communicating with MATRIX device. It also sets up the FIR filter by calling  SelectFIRCoeff( FIR_default[0]) .  // Function declaration in header file  void   Setup ( MatrixIOBus   * bus );   // Set microphone_core to use MatrixIOBus bus  microphone_core . Setup ( bus );    .SetFIRCoeff SetFIRCoeff  is a  function  that sends the  fir_coeff_  array in the  MicrophoneCore  object to the FPGA.  // Function declaration in header file  bool   SetFIRCoeff ();    // Sends fir_coeff_ to FPGA  microphone_core . SetFIRCoeff ();    .SetCustomFIRCoeff SetCustomFIRCoeff  is a  function  that sets the  fir_coeff_  array in the  MicrophoneCore  object.  If input is valid then the function also calls  SetFIRCoeff  to send the  fir_coeff_  array in the  MicrophoneCore  object to the FPGA.  bool   SetCustomFIRCoeff ( const   std :: valarray int16_t   custom_fir );   // Sets fir_coeff_ to custom_fir  microphone_core . SetCustomFIRCoeff ( custom_fir );    .SelectFIRCoeff SelectFIRCoeff  is a  function  that sets the  fir_coeff_  array in the  MicrophoneCore  object.   If input is valid then the function also calls  SetFIRCoeff  to send the  fir_coeff_  array in the  MicrophoneCore  object to the FPGA.  This function accepts a FIRCoeff struct, which is defined below.  // FIRCoeff definition in header file  struct   FIRCoeff   {  uint32_t   rate_ ;  std :: valarray int16_t   coeff_ ;  };   bool   SelectFIRCoeff ( FIRCoeff   * FIR_coeff );   // Sets fir_coeff_ from FIR_default[0]  microphone_core . SelectFIRCoeff ( FIR_default [ 0 ]);    Provided FIR Filters A FIR filter is provided in  matrix_hal/microphone_core_fir.h .  This filter provided is in the form of a FIRCoeff struct, which is defined below.  // FIRCoeff definition in header file  struct   FIRCoeff   {  uint32_t   rate_ ;  std :: valarray int16_t   coeff_ ;  };   To use the provided FIR filter the  SelectFIRCoeff  function is used to set it, then the  SetFIRCoeff  function is used to send it to the FPGA.  // Sets fir_coeff_ from FIR_default[0]  microphone_core . SelectFIRCoeff ( FIR_default [ 0 ]);  // Sends FIR filter in fir_coeff_ to FPGA  microphone_core . SetFIRCoeff ();", 
            "title": "References"
        }, 
        {
            "location": "/matrix-hal/examples/", 
            "text": "MATRIX HAL Examples\n\n\nDownload Examples\n\n\nThe following commands download and compile all the examples.\n\n\nsudo apt-get install cmake g++ git\n\n\n\n\nDownload, build, and run the examples.\n\ncd\n ~/\ngit clone https://github.com/matrix-io/matrix-hal-examples.git\n\ncd\n matrix-hal-examples\nmkdir build\n\ncd\n build\ncmake ..\nmake -j4\n\n\n\nEverloop\n\n\n\nLED interface.\n\n\nHumidity\n\n\n\nHumidity and temperature measurement.\n\n\nIMU\n\n\n\nInertial Measurement Unit.\n\n\nPressure\n\n\n\nPressure, altitude and temperature measurement.\n\n\nUV\n\n\n\nUltraviolet light sensor.\n\n\nGPIO\n\n\n\nGeneral Purpose Input/Output.\n\n\nMicrophone\n\n\n\nMicrophone Array.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-hal/examples/#matrix-hal-examples", 
            "text": "", 
            "title": "MATRIX HAL Examples"
        }, 
        {
            "location": "/matrix-hal/examples/#download-examples", 
            "text": "The following commands download and compile all the examples.  sudo apt-get install cmake g++ git  Download, build, and run the examples. cd  ~/\ngit clone https://github.com/matrix-io/matrix-hal-examples.git cd  matrix-hal-examples\nmkdir build cd  build\ncmake ..\nmake -j4", 
            "title": "Download Examples"
        }, 
        {
            "location": "/matrix-hal/examples/everloop/", 
            "text": "Everloop\n\n\n\nHAL Example\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe Everloop interface supports:\n\n\n\n\nSetting the RGBW colors for each individual LED.\n\n\n\n\nCode Examples\n\n\nBelow are examples of how to interface with the Everloop in MATRIX HAL.\n\n\nEverloop function references can be found \nhere\n.\n\n\nThe command below will compile each example. Be sure to pass in your C++ file and desired output file.\n\n\ng\n++\n \n-\no\n \nYOUR_OUTPUT_FILE\n \nYOUR_CPP_FILE\n \n-\nstd\n=\nc\n++\n11\n \n-\nlmatrix_creator_hal\n\n\n\n\n\nEverloop Green\nThe following section shows how to set the Everloop to green. You can download this example \nhere\n.\n\n\nResult\n\n\n\n\nInclude Statements\nTo begin working with the Everloop you need to include these header files.\n\n\n// System calls\n\n\n#include\n \nunistd.h\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n\n// Interfaces with Everloop\n\n\n#include\n \nmatrix_hal/everloop.h\n\n\n// Holds data for Everloop\n\n\n#include\n \nmatrix_hal/everloop_image.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device.\n\n\nint\n \nmain\n()\n \n{\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nEverloopImage\n and \nEverloop\n object and use it to set the Everloop to green for 10 seconds.\n\n\n// The following code is part of main()\n\n\n\n// Holds the number of LEDs on MATRIX device\n\n\nint\n \nledCount\n \n=\n \nbus\n.\nMatrixLeds\n();\n\n\n// Create EverloopImage object, with size of ledCount\n\n\nmatrix_hal\n::\nEverloopImage\n \neverloop_image\n(\nledCount\n);\n\n\n// Create Everloop object\n\n\nmatrix_hal\n::\nEverloop\n \neverloop\n;\n\n\n// Set everloop to use MatrixIOBus bus\n\n\neverloop\n.\nSetup\n(\nbus\n);\n\n\n\n// For each led in everloop_image.leds, set led value\n\n\nfor\n \n(\nmatrix_hal\n::\nLedValue\n \nled\n \n:\n \neverloop_image\n.\nleds\n)\n \n{\n\n    \nled\n.\nred\n \n=\n \n0\n;\n\n    \n// Set green to 100\n\n    \nled\n.\ngreen\n \n=\n \n100\n;\n\n    \nled\n.\nblue\n \n=\n \n0\n;\n\n    \nled\n.\nwhite\n \n=\n \n0\n;\n\n\n}\n\n\n\n// Updates the Everloop on the MATRIX device\n\n\neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n\n// Output everloop status to console\n\n\nstd\n::\ncout\n \n \nEverloop set to green for 10 seconds.\n \n \nstd\n::\nendl\n;\n\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n=\n \n10\n;\n \ni\n++\n)\n \n{\n\n    \n// Output time remaining to console\n\n    \nstd\n::\ncout\n \n \nTime remaining (s) : \n \n \n10\n \n-\n \ni\n \n \nstd\n::\nendl\n;\n\n    \n// Sleep for 1 second\n\n    \nusleep\n(\n1000000\n);\n\n\n}\n\n\n\n// For each led in everloop_image.leds, set led value to 0\n\n\nfor\n \n(\nmatrix_hal\n::\nLedValue\n \nled\n \n:\n \neverloop_image\n.\nleds\n)\n \n{\n\n    \n// Turn off Everloop\n\n    \nled\n.\nred\n \n=\n \n0\n;\n\n    \nled\n.\ngreen\n \n=\n \n0\n;\n\n    \nled\n.\nblue\n \n=\n \n0\n;\n\n    \nled\n.\nwhite\n \n=\n \n0\n;\n\n\n}\n\n\n\n// Updates the Everloop on the MATRIX device\n\n\neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n\nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\n\n\nEverloop Yellow/Purple\nThe following section shows how to set the Everloop to yellow and purple (with color blending). You can download this example \nhere\n.\n\n\nResult\n\n\n\n\nInclude Statements\nTo begin working with the Everloop you need to include these header files.\n\n\n// System calls\n\n\n#include\n \nunistd.h\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n\n// Interfaces with Everloop\n\n\n#include\n \nmatrix_hal/everloop.h\n\n\n// Holds data for Everloop\n\n\n#include\n \nmatrix_hal/everloop_image.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device.\n\n\nint\n \nmain\n()\n \n{\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nEverloopImage\n and \nEverloop\n object and use it to set the Everloop to yellow and purple for 10 seconds.\n\n\n// The following code is part of main()\n\n\n\n// Holds the number of LEDs on MATRIX device\n\n\nint\n \nledCount\n \n=\n \nbus\n.\nMatrixLeds\n();\n\n\n// Create EverloopImage object, with size of ledCount\n\n\nmatrix_hal\n::\nEverloopImage\n \neverloop_image\n(\nledCount\n);\n\n\n// Create Everloop object\n\n\nmatrix_hal\n::\nEverloop\n \neverloop\n;\n\n\n// Set everloop to use MatrixIOBus bus\n\n\neverloop\n.\nSetup\n(\nbus\n);\n\n\n\n// For each led in everloop_image.leds, set led value\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \neverloop_image\n.\nleds\n.\nsize\n();\n \ni\n++\n)\n \n{\n\n    \n// When remainder is zero set led to purple\n\n    \nif\n \n(\ni\n \n%\n \n2\n \n==\n \n0\n)\n \n{\n\n    \n// Blending blue and red to make purple\n\n    \neverloop_image\n.\nleds\n[\ni\n].\nblue\n \n=\n \n40\n;\n\n    \neverloop_image\n.\nleds\n[\ni\n].\nred\n \n=\n \n40\n;\n\n    \n}\n\n    \n// Else set led to yellow\n\n    \nelse\n \n{\n\n    \n// Blending green and red to make yellow\n\n    \neverloop_image\n.\nleds\n[\ni\n].\ngreen\n \n=\n \n40\n;\n\n    \neverloop_image\n.\nleds\n[\ni\n].\nred\n \n=\n \n60\n;\n\n    \n}\n\n\n}\n\n\n\n// Updates the Everloop on the MATRIX device\n\n\neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n\n// Output everloop status to console\n\n\nstd\n::\ncout\n \n \nEverloop set to yellow and purple for 10 seconds.\n \n \nstd\n::\nendl\n;\n\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n=\n \n10\n;\n \ni\n++\n)\n \n{\n\n    \n// Output time remaining to console\n\n    \nstd\n::\ncout\n \n \nTime remaining (s) : \n \n \n10\n \n-\n \ni\n \n \nstd\n::\nendl\n;\n\n    \n// Sleep for 1 second\n\n    \nusleep\n(\n1000000\n);\n\n\n}\n\n\n\n// For each led in everloop_image.leds, set led value to 0\n\n\nfor\n \n(\nmatrix_hal\n::\nLedValue\n \nled\n \n:\n \neverloop_image\n.\nleds\n)\n \n{\n\n    \n// Turn off Everloop\n\n    \nled\n.\nred\n \n=\n \n0\n;\n\n    \nled\n.\ngreen\n \n=\n \n0\n;\n\n    \nled\n.\nblue\n \n=\n \n0\n;\n\n    \nled\n.\nwhite\n \n=\n \n0\n;\n\n\n}\n\n\n\n// Updates the Everloop on the MATRIX device\n\n\neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n\nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\n\n\nEverloop Rainbow\nThe following section shows how to set the Everloop to rainbow. You can download this example \nhere\n.\n\n\nResult\n\n\n\n\nInclude Statements\nTo begin working with the Everloop you need to include these header files.\n\n\n// System calls\n\n\n#include\n \nunistd.h\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n// Included for sin() function.\n\n\n#include\n \ncmath\n\n\n\n// Interfaces with Everloop\n\n\n#include\n \nmatrix_hal/everloop.h\n\n\n// Holds data for Everloop\n\n\n#include\n \nmatrix_hal/everloop_image.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device.\n\n\nint\n \nmain\n()\n \n{\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nEverloopImage\n and \nEverloop\n object and use it to set the Everloop to rainbow for 10 seconds.\n\n\n// The following code is part of main()\n\n\n\n// Holds the number of LEDs on MATRIX device\n\n\nint\n \nledCount\n \n=\n \nbus\n.\nMatrixLeds\n();\n\n\n// Create EverloopImage object, with size of ledCount\n\n\nmatrix_hal\n::\nEverloopImage\n \neverloop_image\n(\nledCount\n);\n\n\n// Create Everloop object\n\n\nmatrix_hal\n::\nEverloop\n \neverloop\n;\n\n\n// Set everloop to use MatrixIOBus bus\n\n\neverloop\n.\nSetup\n(\nbus\n);\n\n\n\n// Variables used for sine wave rainbow logic\n\n\nfloat\n \ncounter\n \n=\n \n0\n;\n\n\nconst\n \nfloat\n \nfreq\n \n=\n \n0.375\n;\n\n\n\n// 10 sec loop for rainbow effect 250*40000 microsec = 10 sec\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n=\n \n250\n;\n \ni\n++\n)\n \n{\n\n    \n// For each led in everloop_image.leds, set led value\n\n    \nfor\n \n(\nmatrix_hal\n::\nLedValue\n \nled\n \n:\n \neverloop_image\n.\nleds\n)\n \n{\n\n    \n// Sine waves 120 degrees out of phase for rainbow\n\n    \nled\n.\nred\n \n=\n\n        \n(\nstd\n::\nsin\n(\nfreq\n \n*\n \ncounter\n \n+\n \n(\nM_PI\n \n/\n \n180\n \n*\n \n240\n))\n \n*\n \n155\n \n+\n \n100\n)\n \n/\n \n10\n;\n\n    \nled\n.\ngreen\n \n=\n\n        \n(\nstd\n::\nsin\n(\nfreq\n \n*\n \ncounter\n \n+\n \n(\nM_PI\n \n/\n \n180\n \n*\n \n120\n))\n \n*\n \n155\n \n+\n \n100\n)\n \n/\n \n10\n;\n\n    \nled\n.\nblue\n \n=\n \n(\nstd\n::\nsin\n(\nfreq\n \n*\n \ncounter\n \n+\n \n0\n)\n \n*\n \n155\n \n+\n \n100\n)\n \n/\n \n10\n;\n\n    \n// If MATRIX Creator, increment by 0.51\n\n    \nif\n \n(\nledCount\n \n==\n \n35\n)\n \n{\n\n        \ncounter\n \n=\n \ncounter\n \n+\n \n0.51\n;\n\n    \n}\n\n    \n// If MATRIX Voice, increment by 1.01\n\n    \nif\n \n(\nledCount\n \n==\n \n18\n)\n \n{\n\n        \ncounter\n \n=\n \ncounter\n \n+\n \n1.01\n;\n\n    \n}\n\n    \n}\n\n\n    \n// Updates the LEDs\n\n    \neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n    \n// If i is 0 (first run)\n\n    \nif\n \n(\ni\n \n==\n \n0\n)\n \n{\n\n    \n// Output everloop status to console\n\n    \nstd\n::\ncout\n \n \nEverloop set to rainbow for 10 seconds.\n \n \nstd\n::\nendl\n;\n\n    \n}\n\n    \n// If i is cleanly divisible by 25\n\n    \nif\n \n((\ni\n \n%\n \n25\n)\n \n==\n \n0\n)\n \n{\n\n    \nstd\n::\ncout\n \n \nTime remaining (s) : \n \n \n10\n \n-\n \n(\ni\n \n/\n \n25\n)\n \n \nstd\n::\nendl\n;\n\n    \n}\n\n\n    \n// Sleep for 40000 microseconds\n\n    \nusleep\n(\n40000\n);\n\n\n}\n\n\n\n// Updates the Everloop on the MATRIX device\n\n\neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n\n// For each led in everloop_image.leds, set led value to 0\n\n\nfor\n \n(\nmatrix_hal\n::\nLedValue\n \nled\n \n:\n \neverloop_image\n.\nleds\n)\n \n{\n\n    \n// Turn off Everloop\n\n    \nled\n.\nred\n \n=\n \n0\n;\n\n    \nled\n.\ngreen\n \n=\n \n0\n;\n\n    \nled\n.\nblue\n \n=\n \n0\n;\n\n    \nled\n.\nwhite\n \n=\n \n0\n;\n\n\n}\n\n\n\n// Updates the Everloop on the MATRIX device\n\n\neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n\nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\n\n\nEverloop Moving Dots\nThe following section shows how to set the Everloop to moving dots. You can download this example \nhere\n.\n\n\nResult\n\n\n\n\nInclude Statements\nTo begin working with the Everloop you need to include these header files.\n\n\n// System calls\n\n\n#include\n \nunistd.h\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n// Included for sin() function.\n\n\n#include\n \ncmath\n\n\n\n// Interfaces with Everloop\n\n\n#include\n \nmatrix_hal/everloop.h\n\n\n// Holds data for Everloop\n\n\n#include\n \nmatrix_hal/everloop_image.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device.\n\n\nint\n \nmain\n()\n \n{\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nEverloopImage\n and \nEverloop\n object and use it to set the Everloop to moving dots for 10 seconds.\n\n\n// The following code is part of main()\n\n\n\n// Holds the number of LEDs on MATRIX device\n\n\nint\n \nledCount\n \n=\n \nbus\n.\nMatrixLeds\n();\n\n\n// Create EverloopImage object, with size of ledCount\n\n\nmatrix_hal\n::\nEverloopImage\n \neverloop_image\n(\nledCount\n);\n\n\n// Create Everloop object\n\n\nmatrix_hal\n::\nEverloop\n \neverloop\n;\n\n\n// Set everloop to use MatrixIOBus bus\n\n\neverloop\n.\nSetup\n(\nbus\n);\n\n\n\n// Keeps track of location of moving dots\n\n\nlong\n \ncounter\n \n=\n \n0\n;\n\n\n\n// 10 sec loop for rainbow effect 500*20000 microsec = 10 sec\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n=\n \n500\n;\n \ni\n++\n)\n \n{\n\n    \n// For each led in everloop_image.leds, set led value to 0\n\n    \nfor\n \n(\nmatrix_hal\n::\nLedValue\n \nled\n \n:\n \neverloop_image\n.\nleds\n)\n \n{\n\n    \n// Turn off Everloop\n\n    \nled\n.\nred\n \n=\n \n0\n;\n\n    \nled\n.\ngreen\n \n=\n \n0\n;\n\n    \nled\n.\nblue\n \n=\n \n0\n;\n\n    \nled\n.\nwhite\n \n=\n \n0\n;\n\n    \n}\n\n\n    \n// Set led color per led\n\n    \neverloop_image\n.\nleds\n[(\ncounter\n \n/\n \n2\n)\n \n%\n \neverloop_image\n.\nleds\n.\nsize\n()].\nred\n \n=\n \n40\n;\n\n    \neverloop_image\n.\nleds\n[(\ncounter\n \n/\n \n2\n)\n \n%\n \neverloop_image\n.\nleds\n.\nsize\n()].\nblue\n \n=\n \n40\n;\n\n    \neverloop_image\n.\nleds\n[(\ncounter\n \n/\n \n7\n)\n \n%\n \neverloop_image\n.\nleds\n.\nsize\n()].\ngreen\n \n=\n \n60\n;\n\n    \neverloop_image\n.\nleds\n[(\ncounter\n \n/\n \n11\n)\n \n%\n \neverloop_image\n.\nleds\n.\nsize\n()].\nblue\n \n=\n \n60\n;\n\n    \neverloop_image\n\n        \n.\nleds\n[\neverloop_image\n.\nleds\n.\nsize\n()\n \n-\n \n1\n \n-\n\n            \n(\ncounter\n \n%\n \neverloop_image\n.\nleds\n.\nsize\n())]\n\n        \n.\nwhite\n \n=\n \n20\n;\n\n\n    \n// Updates the Everloop on the MATRIX device\n\n    \neverloop\n.\nWrite\n(\neverloop_image\n);\n\n    \n// Increment counter\n\n    \ncounter\n++\n;\n\n\n    \n// If i is 0 (first run)\n\n    \nif\n \n(\ni\n \n==\n \n0\n)\n \n{\n\n    \n// Output everloop status to console\n\n    \nstd\n::\ncout\n \n \nEverloop set to moving dots for 10 seconds.\n \n \nstd\n::\nendl\n;\n\n    \n}\n\n    \n// If i is cleanly divisible by 50\n\n    \nif\n \n((\ni\n \n%\n \n50\n)\n \n==\n \n0\n)\n \n{\n\n    \n// Output time remaining to console\n\n    \nstd\n::\ncout\n \n \nTime remaining (s) : \n \n \n10\n \n-\n \n(\ni\n \n/\n \n50\n)\n \n \nstd\n::\nendl\n;\n\n    \n}\n\n\n    \n// Sleep for 20000 microseconds\n\n    \nusleep\n(\n20000\n);\n\n\n}\n\n\n\n// Updates the Everloop on the MATRIX device\n\n\neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n\n// For each led in everloop_image.leds, set led value to 0\n\n\nfor\n \n(\nmatrix_hal\n::\nLedValue\n \nled\n \n:\n \neverloop_image\n.\nleds\n)\n \n{\n\n    \n// Turn off Everloop\n\n    \nled\n.\nred\n \n=\n \n0\n;\n\n    \nled\n.\ngreen\n \n=\n \n0\n;\n\n    \nled\n.\nblue\n \n=\n \n0\n;\n\n    \nled\n.\nwhite\n \n=\n \n0\n;\n\n\n}\n\n\n\n// Updates the Everloop on the MATRIX device\n\n\neverloop\n.\nWrite\n(\neverloop_image\n);\n\n\n\nreturn\n \n0\n;\n\n\n}", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-hal/examples/everloop/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/examples/everloop/#overview", 
            "text": "The Everloop interface supports:   Setting the RGBW colors for each individual LED.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/examples/everloop/#code-examples", 
            "text": "Below are examples of how to interface with the Everloop in MATRIX HAL.  Everloop function references can be found  here .  The command below will compile each example. Be sure to pass in your C++ file and desired output file.  g ++   - o   YOUR_OUTPUT_FILE   YOUR_CPP_FILE   - std = c ++ 11   - lmatrix_creator_hal   Everloop Green The following section shows how to set the Everloop to green. You can download this example  here .", 
            "title": "Code Examples"
        }, 
        {
            "location": "/matrix-hal/examples/humidity/", 
            "text": "Humidity\n\n\n\nHAL Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe humidity sensor reports values for:\n\n\n\n\nHumidity\n\n\nTemperature\n\n\n\n\nCode Example\n\n\nBelow is an example of how to interface with the humidity sensor in MATRIX HAL.\n\n\nHumidity sensor function references can be found \nhere\n.\n\n\nThe following section shows how to receive data from the humidity sensor. You can download this example \nhere\n.\n\n\nThe command below will compile the example. Be sure to pass in your C++ file and desired output file.\n\n\ng\n++\n \n-\no\n \nYOUR_OUTPUT_FILE\n \nYOUR_CPP_FILE\n \n-\nstd\n=\nc\n++\n11\n \n-\nlmatrix_creator_hal\n\n\n\n\n\nInclude Statements\nTo begin working with the humidity sensor you need to include these header files.\n\n\n// System calls\n\n\n#include\n \nunistd.h\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n\n// Interfaces with humidity sensor\n\n\n#include\n \nmatrix_hal/humidity_sensor.h\n\n\n// Holds data from humidity sensor\n\n\n#include\n \nmatrix_hal/humidity_data.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device.\n\n\nint\n \nmain\n()\n \n{\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nHumidityData\n and \nHumiditySensor\n object and use it to receive data from the humidity sensor.\n\n\n// The following code is part of main()\n\n\n\n// Create HumidityData object\n\n\nmatrix_hal\n::\nHumidityData\n \nhumidity_data\n;\n\n\n// Create HumiditySensor object\n\n\nmatrix_hal\n::\nHumiditySensor\n \nhumidity_sensor\n;\n\n\n// Set humidity_sensor to use MatrixIOBus bus\n\n\nhumidity_sensor\n.\nSetup\n(\nbus\n);\n\n\n\n// Endless loop\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n    \n// Overwrites humidity_data with new data from humidity sensor\n\n    \nhumidity_sensor\n.\nRead\n(\nhumidity_data\n);\n\n    \n// Humidity output is represented in %\n\n    \nfloat\n \nhumidity\n \n=\n \nhumidity_data\n.\nhumidity\n;\n\n    \n// Temperature output is represented in Celsius\n\n    \nfloat\n \ntemperature\n \n=\n \nhumidity_data\n.\ntemperature\n;\n\n    \n// Clear console\n\n    \nstd\n::\nsystem\n(\nclear\n);\n\n    \n// Output sensor data to console\n\n    \nstd\n::\ncout\n \n \n [ Humidity Sensor Output ]\n \n \nstd\n::\nendl\n;\n\n    \nstd\n::\ncout\n \n \n [ Humidity (%) : \n \n \nhumidity\n\n            \n \n ] [ Temperature (Celsius) : \n \n \ntemperature\n \n \n]\n \n \nstd\n::\nendl\n;\n\n\n    \n// Sleep for 20000 microseconds\n\n    \nusleep\n(\n20000\n);\n\n\n}\n\n\n\nreturn\n \n0\n;\n\n\n}", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-hal/examples/humidity/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/examples/humidity/#overview", 
            "text": "The humidity sensor reports values for:   Humidity  Temperature", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/examples/humidity/#code-example", 
            "text": "Below is an example of how to interface with the humidity sensor in MATRIX HAL.  Humidity sensor function references can be found  here .  The following section shows how to receive data from the humidity sensor. You can download this example  here .  The command below will compile the example. Be sure to pass in your C++ file and desired output file.  g ++   - o   YOUR_OUTPUT_FILE   YOUR_CPP_FILE   - std = c ++ 11   - lmatrix_creator_hal   Include Statements To begin working with the humidity sensor you need to include these header files.  // System calls  #include   unistd.h  // Input/output streams and functions  #include   iostream  // Interfaces with humidity sensor  #include   matrix_hal/humidity_sensor.h  // Holds data from humidity sensor  #include   matrix_hal/humidity_data.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h    Initial Setup You'll then need to setup  MatrixIOBus  in order to communicate with the hardware on your MATRIX device.  int   main ()   {  // Create MatrixIOBus object for hardware communication  matrix_hal :: MatrixIOBus   bus ;  // Initialize bus and exit program if error occurs  if   ( ! bus . Init ())   return   false ;    Main Setup Now we will create our  HumidityData  and  HumiditySensor  object and use it to receive data from the humidity sensor.  // The following code is part of main()  // Create HumidityData object  matrix_hal :: HumidityData   humidity_data ;  // Create HumiditySensor object  matrix_hal :: HumiditySensor   humidity_sensor ;  // Set humidity_sensor to use MatrixIOBus bus  humidity_sensor . Setup ( bus );  // Endless loop  while   ( true )   { \n     // Overwrites humidity_data with new data from humidity sensor \n     humidity_sensor . Read ( humidity_data ); \n     // Humidity output is represented in % \n     float   humidity   =   humidity_data . humidity ; \n     // Temperature output is represented in Celsius \n     float   temperature   =   humidity_data . temperature ; \n     // Clear console \n     std :: system ( clear ); \n     // Output sensor data to console \n     std :: cout      [ Humidity Sensor Output ]     std :: endl ; \n     std :: cout      [ Humidity (%) :      humidity \n                ] [ Temperature (Celsius) :      temperature     ]     std :: endl ; \n\n     // Sleep for 20000 microseconds \n     usleep ( 20000 );  }  return   0 ;  }", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-hal/examples/imu/", 
            "text": "Inertial Measurement Unit (IMU)\n\n\n\nHAL Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe IMU sensor reports values for:\n\n\n\n\nYaw, Pitch, and Roll\n\n\nAcceleration for \nx\n, \ny\n, \nz\n axes\n\n\nGyroscope for \nx\n, \ny\n, \nz\n axes\n\n\nMagnetometer for \nx\n, \ny\n, \nz\n axes\n\n\n\n\nCode Example\n\n\nBelow is an example of how to interface with the IMU sensor in MATRIX HAL.\n\n\nIMU sensor function references can be found \nhere\n.\n\n\nThe following section shows how to receive data from the IMU sensor. You can download this example \nhere\n.\n\n\nThe command below will compile the example. Be sure to pass in your C++ file and desired output file.\n\n\ng\n++\n \n-\no\n \nYOUR_OUTPUT_FILE\n \nYOUR_CPP_FILE\n \n-\nstd\n=\nc\n++\n11\n \n-\nlmatrix_creator_hal\n\n\n\n\n\nInclude Statements\nTo begin working with the IMU sensor you need to include these header files.\n\n\n// System calls\n\n\n#include\n \nunistd.h\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n\n// Interfaces with IMU sensor\n\n\n#include\n \nmatrix_hal/imu_sensor.h\n\n\n// Holds data from IMU sensor\n\n\n#include\n \nmatrix_hal/imu_data.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device.\n\n\nint\n \nmain\n()\n \n{\n\n    \n// Create MatrixIOBus object for hardware communication\n\n    \nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n    \n// Initialize bus and exit program if error occurs\n\n    \nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nIMUData\n and \nIMUSensor\n object and use it to receive data from the IMU sensor.\n\n\n    \n// The following code is part of main()\n\n\n    \n// Create IMUData object\n\n    \nmatrix_hal\n::\nIMUData\n \nimu_data\n;\n\n    \n// Create IMUSensor object\n\n    \nmatrix_hal\n::\nIMUSensor\n \nimu_sensor\n;\n\n    \n// Set imu_sensor to use MatrixIOBus bus\n\n    \nimu_sensor\n.\nSetup\n(\nbus\n);\n\n\n    \n// Endless loop\n\n    \nwhile\n \n(\ntrue\n)\n \n{\n\n    \n// Overwrites imu_data with new data from IMU sensor\n\n    \nimu_sensor\n.\nRead\n(\nimu_data\n);\n\n    \n// Accelerometer Output\n\n    \nfloat\n \naccel_X\n \n=\n \nimu_data\n.\naccel_x\n;\n\n    \nfloat\n \naccel_Y\n \n=\n \nimu_data\n.\naccel_y\n;\n\n    \nfloat\n \naccel_Z\n \n=\n \nimu_data\n.\naccel_z\n;\n\n    \n// Gyroscope Output\n\n    \nfloat\n \ngyro_X\n \n=\n \nimu_data\n.\ngyro_x\n;\n\n    \nfloat\n \ngyro_Y\n \n=\n \nimu_data\n.\ngyro_y\n;\n\n    \nfloat\n \ngyro_Z\n \n=\n \nimu_data\n.\ngyro_z\n;\n\n    \n// Yaw, Pitch, Roll Output\n\n    \nfloat\n \nyaw\n \n=\n \nimu_data\n.\nyaw\n;\n\n    \nfloat\n \npitch\n \n=\n \nimu_data\n.\npitch\n;\n\n    \nfloat\n \nroll\n \n=\n \nimu_data\n.\nroll\n;\n\n    \n// Magnetometer Output\n\n    \nfloat\n \nmag_X\n \n=\n \nimu_data\n.\nmag_x\n;\n\n    \nfloat\n \nmag_Y\n \n=\n \nimu_data\n.\nmag_y\n;\n\n    \nfloat\n \nmag_Z\n \n=\n \nimu_data\n.\nmag_z\n;\n  \n// Z-axis points upward\n\n    \n// Clear console\n\n    \nstd\n::\nsystem\n(\nclear\n);\n\n    \n// Output sensor data to console\n\n    \nstd\n::\ncout\n \n \n [ IMU Sensor Output ]\n \n \nstd\n::\nendl\n;\n\n    \nstd\n::\ncout\n \n \n [ Acceleration In X : \n \n \naccel_X\n\n                \n \n ] [ Acceleration In Y : \n \n \naccel_Y\n\n                \n \n ] [ Acceleration In Z : \n \n \naccel_Z\n \n \n ]\n \n \nstd\n::\nendl\n;\n\n    \nstd\n::\ncout\n \n \n [ Gyroscope In X : \n \n \ngyro_X\n\n                \n \n ] [ Gyroscope In Y : \n \n \ngyro_X\n\n                \n \n ] [ Gyroscope In Z : \n \n \ngyro_Z\n \n \n ]\n \n \nstd\n::\nendl\n;\n\n    \nstd\n::\ncout\n \n \n [ Yaw : \n \n \nyaw\n \n \n ] [ Pitch : \n \n \npitch\n\n                \n \n ] [ Roll : \n \n \nroll\n \n \n ]\n \n \nstd\n::\nendl\n;\n\n    \nstd\n::\ncout\n \n \n [ Magnetometer in X : \n \n \nmag_X\n\n                \n \n ] [ Magnetometer in Y : \n \n \nmag_Y\n\n                \n \n ] [ Magnetometer in Z : \n \n \nmag_Z\n \n \n ]\n \n \nstd\n::\nendl\n;\n\n\n    \n// Sleep for 20000 microseconds\n\n    \nusleep\n(\n20000\n);\n\n    \n}\n\n\n    \nreturn\n \n0\n;\n\n\n}", 
            "title": "IMU"
        }, 
        {
            "location": "/matrix-hal/examples/imu/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/examples/imu/#overview", 
            "text": "The IMU sensor reports values for:   Yaw, Pitch, and Roll  Acceleration for  x ,  y ,  z  axes  Gyroscope for  x ,  y ,  z  axes  Magnetometer for  x ,  y ,  z  axes", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/examples/imu/#code-example", 
            "text": "Below is an example of how to interface with the IMU sensor in MATRIX HAL.  IMU sensor function references can be found  here .  The following section shows how to receive data from the IMU sensor. You can download this example  here .  The command below will compile the example. Be sure to pass in your C++ file and desired output file.  g ++   - o   YOUR_OUTPUT_FILE   YOUR_CPP_FILE   - std = c ++ 11   - lmatrix_creator_hal   Include Statements To begin working with the IMU sensor you need to include these header files.  // System calls  #include   unistd.h  // Input/output streams and functions  #include   iostream  // Interfaces with IMU sensor  #include   matrix_hal/imu_sensor.h  // Holds data from IMU sensor  #include   matrix_hal/imu_data.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h    Initial Setup You'll then need to setup  MatrixIOBus  in order to communicate with the hardware on your MATRIX device.  int   main ()   { \n     // Create MatrixIOBus object for hardware communication \n     matrix_hal :: MatrixIOBus   bus ; \n     // Initialize bus and exit program if error occurs \n     if   ( ! bus . Init ())   return   false ;    Main Setup Now we will create our  IMUData  and  IMUSensor  object and use it to receive data from the IMU sensor.       // The following code is part of main() \n\n     // Create IMUData object \n     matrix_hal :: IMUData   imu_data ; \n     // Create IMUSensor object \n     matrix_hal :: IMUSensor   imu_sensor ; \n     // Set imu_sensor to use MatrixIOBus bus \n     imu_sensor . Setup ( bus ); \n\n     // Endless loop \n     while   ( true )   { \n     // Overwrites imu_data with new data from IMU sensor \n     imu_sensor . Read ( imu_data ); \n     // Accelerometer Output \n     float   accel_X   =   imu_data . accel_x ; \n     float   accel_Y   =   imu_data . accel_y ; \n     float   accel_Z   =   imu_data . accel_z ; \n     // Gyroscope Output \n     float   gyro_X   =   imu_data . gyro_x ; \n     float   gyro_Y   =   imu_data . gyro_y ; \n     float   gyro_Z   =   imu_data . gyro_z ; \n     // Yaw, Pitch, Roll Output \n     float   yaw   =   imu_data . yaw ; \n     float   pitch   =   imu_data . pitch ; \n     float   roll   =   imu_data . roll ; \n     // Magnetometer Output \n     float   mag_X   =   imu_data . mag_x ; \n     float   mag_Y   =   imu_data . mag_y ; \n     float   mag_Z   =   imu_data . mag_z ;    // Z-axis points upward \n     // Clear console \n     std :: system ( clear ); \n     // Output sensor data to console \n     std :: cout      [ IMU Sensor Output ]     std :: endl ; \n     std :: cout      [ Acceleration In X :      accel_X \n                    ] [ Acceleration In Y :      accel_Y \n                    ] [ Acceleration In Z :      accel_Z      ]     std :: endl ; \n     std :: cout      [ Gyroscope In X :      gyro_X \n                    ] [ Gyroscope In Y :      gyro_X \n                    ] [ Gyroscope In Z :      gyro_Z      ]     std :: endl ; \n     std :: cout      [ Yaw :      yaw      ] [ Pitch :      pitch \n                    ] [ Roll :      roll      ]     std :: endl ; \n     std :: cout      [ Magnetometer in X :      mag_X \n                    ] [ Magnetometer in Y :      mag_Y \n                    ] [ Magnetometer in Z :      mag_Z      ]     std :: endl ; \n\n     // Sleep for 20000 microseconds \n     usleep ( 20000 ); \n     } \n\n     return   0 ;  }", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-hal/examples/pressure/", 
            "text": "Pressure\n\n\n\nHAL Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe pressure sensor reports values for:\n\n\n\n\nPressure\n\n\nAltitude\n\n\nTemperature\n\n\n\n\nCode Example\n\n\nBelow is an example of how to interface with the pressure sensor in MATRIX HAL.\n\n\nPressure sensor function references can be found \nhere\n.\n\n\nThe following section shows how to receive data from the pressure sensor. You can download this example \nhere\n.\n\n\nThe command below will compile the example. Be sure to pass in your C++ file and desired output file.\n\n\ng\n++\n \n-\no\n \nYOUR_OUTPUT_FILE\n \nYOUR_CPP_FILE\n \n-\nstd\n=\nc\n++\n11\n \n-\nlmatrix_creator_hal\n\n\n\n\n\nInclude Statements\nTo begin working with the pressure sensor you need to include these header files.\n\n\n// System calls\n\n\n#include\n \nunistd.h\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n\n// Interfaces with pressure sensor\n\n\n#include\n \nmatrix_hal/pressure_sensor.h\n\n\n// Holds data from pressure sensor\n\n\n#include\n \nmatrix_hal/pressure_data.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device.\n\n\nint\n \nmain\n()\n \n{\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nPressureData\n and \nPressureSensor\n object and use it to receive data from the pressure sensor.\n\n\n// The following code is part of main()\n\n\n\n// Create PressureData object\n\n\nmatrix_hal\n::\nPressureData\n \npressure_data\n;\n\n\n// Create PressureSensor object\n\n\nmatrix_hal\n::\nPressureSensor\n \npressure_sensor\n;\n\n\n// Set pressure_sensor to use MatrixIOBus bus\n\n\npressure_sensor\n.\nSetup\n(\nbus\n);\n\n\n\n// Endless loop\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n    \n// Overwrites pressure_data with new data from pressure sensor\n\n    \npressure_sensor\n.\nRead\n(\npressure_data\n);\n\n    \n// Altitude output is represented in meters\n\n    \nfloat\n \naltitude\n \n=\n \npressure_data\n.\naltitude\n;\n\n    \n// Pressure output is represented in Pa\n\n    \nfloat\n \npressure\n \n=\n \npressure_data\n.\npressure\n;\n\n    \n// Temperature output is represented in Celsius\n\n    \nfloat\n \ntemperature\n \n=\n \npressure_data\n.\ntemperature\n;\n\n    \n// Clear console\n\n    \nstd\n::\nsystem\n(\nclear\n);\n\n    \n// Output sensor data to console\n\n    \nstd\n::\ncout\n \n \n [ Pressure Sensor Output ]\n \n \nstd\n::\nendl\n;\n\n    \nstd\n::\ncout\n \n \n [ Altitude (m) : \n \n \naltitude\n\n            \n \n ] [ Pressure (Pa) : \n \n \npressure\n\n            \n \n ] [ Temperature (Celsius) : \n \n \ntemperature\n \n \n ]\n \n \nstd\n::\nendl\n;\n\n\n    \n// Sleep for 20000 microseconds\n\n    \nusleep\n(\n20000\n);\n\n\n}\n\n\n\nreturn\n \n0\n;\n\n\n}", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-hal/examples/pressure/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/examples/pressure/#overview", 
            "text": "The pressure sensor reports values for:   Pressure  Altitude  Temperature", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/examples/pressure/#code-example", 
            "text": "Below is an example of how to interface with the pressure sensor in MATRIX HAL.  Pressure sensor function references can be found  here .  The following section shows how to receive data from the pressure sensor. You can download this example  here .  The command below will compile the example. Be sure to pass in your C++ file and desired output file.  g ++   - o   YOUR_OUTPUT_FILE   YOUR_CPP_FILE   - std = c ++ 11   - lmatrix_creator_hal   Include Statements To begin working with the pressure sensor you need to include these header files.  // System calls  #include   unistd.h  // Input/output streams and functions  #include   iostream  // Interfaces with pressure sensor  #include   matrix_hal/pressure_sensor.h  // Holds data from pressure sensor  #include   matrix_hal/pressure_data.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h    Initial Setup You'll then need to setup  MatrixIOBus  in order to communicate with the hardware on your MATRIX device.  int   main ()   {  // Create MatrixIOBus object for hardware communication  matrix_hal :: MatrixIOBus   bus ;  // Initialize bus and exit program if error occurs  if   ( ! bus . Init ())   return   false ;    Main Setup Now we will create our  PressureData  and  PressureSensor  object and use it to receive data from the pressure sensor.  // The following code is part of main()  // Create PressureData object  matrix_hal :: PressureData   pressure_data ;  // Create PressureSensor object  matrix_hal :: PressureSensor   pressure_sensor ;  // Set pressure_sensor to use MatrixIOBus bus  pressure_sensor . Setup ( bus );  // Endless loop  while   ( true )   { \n     // Overwrites pressure_data with new data from pressure sensor \n     pressure_sensor . Read ( pressure_data ); \n     // Altitude output is represented in meters \n     float   altitude   =   pressure_data . altitude ; \n     // Pressure output is represented in Pa \n     float   pressure   =   pressure_data . pressure ; \n     // Temperature output is represented in Celsius \n     float   temperature   =   pressure_data . temperature ; \n     // Clear console \n     std :: system ( clear ); \n     // Output sensor data to console \n     std :: cout      [ Pressure Sensor Output ]     std :: endl ; \n     std :: cout      [ Altitude (m) :      altitude \n                ] [ Pressure (Pa) :      pressure \n                ] [ Temperature (Celsius) :      temperature      ]     std :: endl ; \n\n     // Sleep for 20000 microseconds \n     usleep ( 20000 );  }  return   0 ;  }", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-hal/examples/uv/", 
            "text": "UV\n\n\n\nHAL Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe UV sensor reports values for:\n\n\n\n\nUV Index scale used in the United States, conforms with international guidelines for UVI reporting established by the World Health Organization.  From \nUV Index Scale\n\n\n\n\nCode Example\n\n\nBelow is an example of how to interface with the UV sensor in MATRIX HAL.\n\n\nUV sensor function references can be found \nhere\n.\n\n\nThe following section shows how to receive data from the UV sensor. You can download this example \nhere\n.\n\n\nThe command below will compile the example. Be sure to pass in your C++ file and desired output file.\n\n\ng\n++\n \n-\no\n \nYOUR_OUTPUT_FILE\n \nYOUR_CPP_FILE\n \n-\nstd\n=\nc\n++\n11\n \n-\nlmatrix_creator_hal\n\n\n\n\n\nInclude Statements\nTo begin working with the UV sensor you need to include these header files.\n\n\n// System calls\n\n\n#include\n \nunistd.h\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n\n// Interfaces with UV sensor\n\n\n#include\n \nmatrix_hal/uv_sensor.h\n\n\n// Holds data from UV sensor\n\n\n#include\n \nmatrix_hal/uv_data.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device.\n\n\nint\n \nmain\n()\n \n{\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nUVData\n and \nUVSensor\n object and use it to receive data from the UV sensor.\n\n\n// The following code is part of main()\n\n\n\n// Create UVData object\n\n\nmatrix_hal\n::\nUVData\n \nuv_data\n;\n\n\n// Create UVSensor object\n\n\nmatrix_hal\n::\nUVSensor\n \nuv_sensor\n;\n\n\n// Set uv_sensor to use MatrixIOBus bus\n\n\nuv_sensor\n.\nSetup\n(\nbus\n);\n\n\n\n// Endless loop\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n    \n// Overwrites UVData object with new data\n\n    \nuv_sensor\n.\nRead\n(\nuv_data\n);\n\n    \n// UV output is represented in UV Index\n\n    \nfloat\n \nUV\n \n=\n \nuv_data\n.\nuv\n;\n\n    \n// Clear console\n\n    \nstd\n::\nsystem\n(\nclear\n);\n\n    \n// Output sensor data to console\n\n    \nstd\n::\ncout\n \n \n [ UV Sensor Output ]\n \n \nstd\n::\nendl\n;\n\n    \nstd\n::\ncout\n \n \n [ UV : \n \n \nUV\n \n \n ]\n \n \nstd\n::\nendl\n;\n\n\n    \n// Sleep for 20000 microseconds\n\n    \nusleep\n(\n20000\n);\n\n\n}\n\n\n\nreturn\n \n0\n;\n\n\n}", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-hal/examples/uv/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/examples/uv/#overview", 
            "text": "The UV sensor reports values for:   UV Index scale used in the United States, conforms with international guidelines for UVI reporting established by the World Health Organization.  From  UV Index Scale", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/examples/uv/#code-example", 
            "text": "Below is an example of how to interface with the UV sensor in MATRIX HAL.  UV sensor function references can be found  here .  The following section shows how to receive data from the UV sensor. You can download this example  here .  The command below will compile the example. Be sure to pass in your C++ file and desired output file.  g ++   - o   YOUR_OUTPUT_FILE   YOUR_CPP_FILE   - std = c ++ 11   - lmatrix_creator_hal   Include Statements To begin working with the UV sensor you need to include these header files.  // System calls  #include   unistd.h  // Input/output streams and functions  #include   iostream  // Interfaces with UV sensor  #include   matrix_hal/uv_sensor.h  // Holds data from UV sensor  #include   matrix_hal/uv_data.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h    Initial Setup You'll then need to setup  MatrixIOBus  in order to communicate with the hardware on your MATRIX device.  int   main ()   {  // Create MatrixIOBus object for hardware communication  matrix_hal :: MatrixIOBus   bus ;  // Initialize bus and exit program if error occurs  if   ( ! bus . Init ())   return   false ;    Main Setup Now we will create our  UVData  and  UVSensor  object and use it to receive data from the UV sensor.  // The following code is part of main()  // Create UVData object  matrix_hal :: UVData   uv_data ;  // Create UVSensor object  matrix_hal :: UVSensor   uv_sensor ;  // Set uv_sensor to use MatrixIOBus bus  uv_sensor . Setup ( bus );  // Endless loop  while   ( true )   { \n     // Overwrites UVData object with new data \n     uv_sensor . Read ( uv_data ); \n     // UV output is represented in UV Index \n     float   UV   =   uv_data . uv ; \n     // Clear console \n     std :: system ( clear ); \n     // Output sensor data to console \n     std :: cout      [ UV Sensor Output ]     std :: endl ; \n     std :: cout      [ UV :      UV      ]     std :: endl ; \n\n     // Sleep for 20000 microseconds \n     usleep ( 20000 );  }  return   0 ;  }", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-hal/examples/gpio/", 
            "text": "General Purpose Input Output (GPIO)\n\n\n\nHAL Example\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe GPIO interface supports:\n\n\n\n\nPin I/O input\n\n\nPin I/O output\n\n\nPin PWM output\n\n\n\n\nDevice Pinouts\n:\n\n\n\n\nMATRIX Creator\n\n\nMATRIX Voice\n\n\n\n\nCode Examples\n\n\nBelow are examples of how to interface with the GPIO in MATRIX HAL.\n\n\nGPIO function references can be found \nhere\n.\n\n\nThe command below will compile each example. Be sure to pass in your C++ file and desired output file.\n\n\ng\n++\n \n-\no\n \nYOUR_OUTPUT_FILE\n \nYOUR_CPP_FILE\n \n-\nstd\n=\nc\n++\n11\n \n-\nlmatrix_creator_hal\n\n\n\n\n\nGPIO I/O\nThe following section shows how to use GPIO in digital I/O mode for output and input. You can download this example \nhere\n.\n\n\nInclude Statements\nTo begin working with the GPIO you need to include these header files.\n\n\n// System calls\n\n\n#include\n \nunistd.h\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n\n// Interfaces with GPIO\n\n\n#include\n \nmatrix_hal/gpio_control.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\n\n\nInitial Variables\nThese initial variables are used in the example.\n\n\n// GPIOOutputMode is 1\n\n\nconst\n \nuint16_t\n \nGPIOOutputMode\n \n=\n \n1\n;\n\n\n// GPIOInputMode is 0\n\n\nconst\n \nuint16_t\n \nGPIOInputMode\n \n=\n \n0\n;\n\n\n\n// Holds desired GPIO pin for output [0-15]\n\n\nuint16_t\n \npin_out\n;\n\n\n// Holds desired output state\n\n\nuint16_t\n \npin_out_state\n;\n\n\n// Holds desired GPIO pin for input [0-15]\n\n\nuint16_t\n \npin_in\n;\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device.\n\n\nint\n \nmain\n()\n \n{\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nGPIOControl\n object and use it to output and input a digital GPIO signal.\n\n\n// The following code is part of main()\n\n\n\n// Create GPIOControl object\n\n\nmatrix_hal\n::\nGPIOControl\n \ngpio\n;\n\n\n// Set gpio to use MatrixIOBus bus\n\n\ngpio\n.\nSetup\n(\nbus\n);\n\n\n\n// Prompt user for GPIO pin\n\n\nstd\n::\ncout\n \n \nSelect Pin [0-15] For Output: \n;\n\n\n// Log user input\n\n\nstd\n::\ncin\n \n \npin_out\n;\n\n\n// Prompt user for GPIO state\n\n\nstd\n::\ncout\n \n \nPin Output State [0-1] : \n;\n\n\n// Log user input\n\n\nstd\n::\ncin\n \n \npin_out_state\n;\n\n\n// Prompt user for GPIO pin\n\n\nstd\n::\ncout\n \n \nSelect Pin [0-15] For Input: \n;\n\n\n// Log user input\n\n\nstd\n::\ncin\n \n \npin_in\n;\n\n\n\n// Set pin_out mode to output\n\n\ngpio\n.\nSetMode\n(\npin_out\n,\n \nGPIOOutputMode\n);\n\n\n\n// Set pin_in mode to input\n\n\ngpio\n.\nSetMode\n(\npin_in\n,\n \nGPIOInputMode\n);\n\n\n\n// Set pin_out to output pin_out_state\n\n\ngpio\n.\nSetGPIOValue\n(\npin_out\n,\n \npin_out_state\n);\n\n\n\n// Endless loop\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n    \n// Get state of pin_in\n\n    \nuint16_t\n \npin_in_state\n \n=\n \ngpio\n.\nGetGPIOValue\n(\npin_in\n);\n\n    \n// Clear console\n\n    \nstd\n::\nsystem\n(\nclear\n);\n\n    \n// Output pin_out info to console\n\n    \nstd\n::\ncout\n \n \n[ Output Pin : \n \n \npin_out\n \n \n ]\n\n            \n \n [ Output State : \n \n \npin_out_state\n \n \n ]\n \n \nstd\n::\nendl\n;\n\n    \n// Output pin_in info to console\n\n    \nstd\n::\ncout\n \n \n[ Input Pin : \n \n \npin_in\n \n \n ]\n\n            \n \n [ Input State : \n \n \npin_in_state\n \n \n ]\n \n \nstd\n::\nendl\n;\n\n    \n// Sleep for 10000 microseconds\n\n    \nusleep\n(\n10000\n);\n\n\n}\n\n\n\nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\n\n\nGPIO PWM\nThe following section shows how to use GPIO in PWM mode for PWM output. You can download this example \nhere\n.\n\n\nInclude Statements\nTo begin working with the GPIO you need to include these header files.\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n\n// Interfaces with GPIO\n\n\n#include\n \nmatrix_hal/gpio_control.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\n\n\nInitial Variables\nThese initial variables are used in the example.\n\n\n// GPIOOutputMode is 1\n\n\nconst\n \nuint16_t\n \nGPIOOutputMode\n \n=\n \n1\n;\n\n\n// GPIOInputMode is 0\n\n\nconst\n \nuint16_t\n \nGPIOInputMode\n \n=\n \n0\n;\n\n\n// PWMFunction is 1\n\n\nconst\n \nuint16_t\n \nPWMFunction\n \n=\n \n1\n;\n\n\n\n// Holds desired PWM frequency\n\n\nfloat\n \nfrequency\n;\n\n\n// Holds desired PWM duty percentage\n\n\nfloat\n \npercentage\n;\n\n\n// Holds desired GPIO pin [0-15]\n\n\nuint16_t\n \npin\n;\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device.\n\n\nint\n \nmain\n()\n \n{\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nGPIOControl\n object and use it to output and input a digital GPIO signal.\n\n\n// The following code is part of main()\n\n\n\n// Create GPIOControl object\n\n\nmatrix_hal\n::\nGPIOControl\n \ngpio\n;\n\n\n// Set gpio to use MatrixIOBus bus\n\n\ngpio\n.\nSetup\n(\nbus\n);\n\n\n\n// Prompt user for GPIO pin\n\n\nstd\n::\ncout\n \n \nSelect Pin [0-15] : \n;\n\n\n// Log user input\n\n\nstd\n::\ncin\n \n \npin\n;\n\n\n// Prompt user for PWM frequency\n\n\nstd\n::\ncout\n \n \nSelect Frequency (in Hz) : \n;\n\n\n// Log user input\n\n\nstd\n::\ncin\n \n \nfrequency\n;\n\n\n// Prompt user for PWM duty percentage\n\n\nstd\n::\ncout\n \n \nSelect Duty Percentage : \n;\n\n\n// Log user input\n\n\nstd\n::\ncin\n \n \npercentage\n;\n\n\n\n// Set pin mode to output\n\n\ngpio\n.\nSetMode\n(\npin\n,\n \nGPIOOutputMode\n);\n\n\n// Set pin function to PWM\n\n\ngpio\n.\nSetFunction\n(\npin\n,\n \nPWMFunction\n);\n\n\n\n// If setting PWM returns an error, log it\n\n\n// SetPWM function carries out PWM logic and outputs PWM signal\n\n\nif\n \n(\n!\ngpio\n.\nSetPWM\n(\nfrequency\n,\n \npercentage\n,\n \npin\n))\n\n    \n// Output error to console\n\n    \nstd\n::\ncerr\n \n \nERROR: invalid input\n \n \nstd\n::\nendl\n;\n\n\nelse\n\n    \n// Else output GPIO PWM info to console\n\n    \nstd\n::\ncout\n \n \n[ Pin : \n \n \npin\n \n \n ] [ Frequency : \n \n \nfrequency\n\n            \n \n ] [ Duty Percentage : \n \n \npercentage\n \n \n ]\n \n \nstd\n::\nendl\n;\n\n\n\nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\n\n\nGPIO Servo\nThe following section shows how to use GPIO in PWM mode for controlling a servo. You can download this example \nhere\n.\n\n\nInclude Statements\nTo begin working with the GPIO you need to include these header files.\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n\n// Interfaces with GPIO\n\n\n#include\n \nmatrix_hal/gpio_control.h\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n\n\n\n\n\nInitial Variables\nThese initial variables are used in the example.\n\n\n// GPIOOutputMode is 1\n\n\nconst\n \nuint16_t\n \nGPIOOutputMode\n \n=\n \n1\n;\n\n\n// GPIOInputMode is 0\n\n\nconst\n \nuint16_t\n \nGPIOInputMode\n \n=\n \n0\n;\n\n\n\n// PWMFunction is 1\n\n\nconst\n \nuint16_t\n \nPWMFunction\n \n=\n \n1\n;\n\n\n\n// Holds desired PWM frequency\n\n\nfloat\n \nfrequency\n;\n\n\n// Holds desired PWM duty percentage\n\n\nfloat\n \npercentage\n;\n\n\n// Holds desired GPIO pin [0-15]\n\n\nuint16_t\n \npin\n;\n\n\n// Holds desired servo angle\n\n\nfloat\n \nangle\n;\n\n\n// Holds servo minimum pulse length (for calibration)\n\n\nfloat\n \nmin_pulse_ms\n;\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device.\n\n\nint\n \nmain\n()\n \n{\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nGPIOControl\n object and use it to output and input a digital GPIO signal.\n\n\nServo neutral position is achieved with a 1.5 milliseconds pulse, so by taking the minimum servo pulse (in milliseconds) the SetServoAngle function calibrates servo angle.\nIf unsure of min_pulse_ms enter \n0.8\n.\n\n\n// The following code is part of main()\n\n\n\n// Create GPIOControl object\n\n\nmatrix_hal\n::\nGPIOControl\n \ngpio\n;\n\n\n// Set gpio to use MatrixIOBus bus\n\n\ngpio\n.\nSetup\n(\nbus\n);\n\n\n\n// Prompt user for GPIO pin\n\n\nstd\n::\ncout\n \n \nSelect Pin [0-15] : \n;\n\n\n// Log user input\n\n\nstd\n::\ncin\n \n \npin\n;\n\n\n// Prompt user for servo angle\n\n\nstd\n::\ncout\n \n \nServo Angle : \n;\n\n\n// Log user input\n\n\nstd\n::\ncin\n \n \nangle\n;\n\n\n// Prompt user for servo minimum pulse length in ms (for calibration)\n\n\nstd\n::\ncout\n \n \nServo Min Pulse (ms) : \n;\n\n\n// Log user input\n\n\nstd\n::\ncin\n \n \nmin_pulse_ms\n;\n\n\n\n// Set pin mode to output\n\n\ngpio\n.\nSetMode\n(\npin\n,\n \nGPIOOutputMode\n);\n\n\n// Set pin function to PWM\n\n\ngpio\n.\nSetFunction\n(\npin\n,\n \nPWMFunction\n);\n\n\n\n// If setting servo angle returns an error, log it\n\n\n// SetServoAngle function sets a servo angle based on the min_pulse_ms\n\n\nif\n \n(\n!\ngpio\n.\nSetServoAngle\n(\nangle\n,\n \nmin_pulse_ms\n,\n \npin\n))\n\n    \n// Output error to console\n\n    \nstd\n::\ncerr\n \n \nERROR: invalid input\n \n \nstd\n::\nendl\n;\n\n\nelse\n\n    \n// Else output servo control info to console\n\n    \nstd\n::\ncout\n \n \n[ Pin : \n \n \npin\n \n \n ]\n\n            \n \n [ Servo Angle : \n \n \nangle\n\n            \n \n ] [ Servo Min Pulse (ms) : \n \n \nmin_pulse_ms\n \n \n ] \n\n            \n \nstd\n::\nendl\n;\n\n\n\nreturn\n \n0\n;\n\n\n}", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-hal/examples/gpio/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/examples/gpio/#overview", 
            "text": "The GPIO interface supports:   Pin I/O input  Pin I/O output  Pin PWM output   Device Pinouts :   MATRIX Creator  MATRIX Voice", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/examples/gpio/#code-examples", 
            "text": "Below are examples of how to interface with the GPIO in MATRIX HAL.  GPIO function references can be found  here .  The command below will compile each example. Be sure to pass in your C++ file and desired output file.  g ++   - o   YOUR_OUTPUT_FILE   YOUR_CPP_FILE   - std = c ++ 11   - lmatrix_creator_hal   GPIO I/O The following section shows how to use GPIO in digital I/O mode for output and input. You can download this example  here .  Include Statements To begin working with the GPIO you need to include these header files.  // System calls  #include   unistd.h  // Input/output streams and functions  #include   iostream  // Interfaces with GPIO  #include   matrix_hal/gpio_control.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h    Initial Variables These initial variables are used in the example.  // GPIOOutputMode is 1  const   uint16_t   GPIOOutputMode   =   1 ;  // GPIOInputMode is 0  const   uint16_t   GPIOInputMode   =   0 ;  // Holds desired GPIO pin for output [0-15]  uint16_t   pin_out ;  // Holds desired output state  uint16_t   pin_out_state ;  // Holds desired GPIO pin for input [0-15]  uint16_t   pin_in ;    Initial Setup You'll then need to setup  MatrixIOBus  in order to communicate with the hardware on your MATRIX device.  int   main ()   {  // Create MatrixIOBus object for hardware communication  matrix_hal :: MatrixIOBus   bus ;  // Initialize bus and exit program if error occurs  if   ( ! bus . Init ())   return   false ;    Main Setup Now we will create our  GPIOControl  object and use it to output and input a digital GPIO signal.  // The following code is part of main()  // Create GPIOControl object  matrix_hal :: GPIOControl   gpio ;  // Set gpio to use MatrixIOBus bus  gpio . Setup ( bus );  // Prompt user for GPIO pin  std :: cout     Select Pin [0-15] For Output:  ;  // Log user input  std :: cin     pin_out ;  // Prompt user for GPIO state  std :: cout     Pin Output State [0-1] :  ;  // Log user input  std :: cin     pin_out_state ;  // Prompt user for GPIO pin  std :: cout     Select Pin [0-15] For Input:  ;  // Log user input  std :: cin     pin_in ;  // Set pin_out mode to output  gpio . SetMode ( pin_out ,   GPIOOutputMode );  // Set pin_in mode to input  gpio . SetMode ( pin_in ,   GPIOInputMode );  // Set pin_out to output pin_out_state  gpio . SetGPIOValue ( pin_out ,   pin_out_state );  // Endless loop  while   ( true )   { \n     // Get state of pin_in \n     uint16_t   pin_in_state   =   gpio . GetGPIOValue ( pin_in ); \n     // Clear console \n     std :: system ( clear ); \n     // Output pin_out info to console \n     std :: cout     [ Output Pin :      pin_out      ] \n                [ Output State :      pin_out_state      ]     std :: endl ; \n     // Output pin_in info to console \n     std :: cout     [ Input Pin :      pin_in      ] \n                [ Input State :      pin_in_state      ]     std :: endl ; \n     // Sleep for 10000 microseconds \n     usleep ( 10000 );  }  return   0 ;  }     GPIO PWM The following section shows how to use GPIO in PWM mode for PWM output. You can download this example  here .  Include Statements To begin working with the GPIO you need to include these header files.  // Input/output streams and functions  #include   iostream  // Interfaces with GPIO  #include   matrix_hal/gpio_control.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h    Initial Variables These initial variables are used in the example.  // GPIOOutputMode is 1  const   uint16_t   GPIOOutputMode   =   1 ;  // GPIOInputMode is 0  const   uint16_t   GPIOInputMode   =   0 ;  // PWMFunction is 1  const   uint16_t   PWMFunction   =   1 ;  // Holds desired PWM frequency  float   frequency ;  // Holds desired PWM duty percentage  float   percentage ;  // Holds desired GPIO pin [0-15]  uint16_t   pin ;    Initial Setup You'll then need to setup  MatrixIOBus  in order to communicate with the hardware on your MATRIX device.  int   main ()   {  // Create MatrixIOBus object for hardware communication  matrix_hal :: MatrixIOBus   bus ;  // Initialize bus and exit program if error occurs  if   ( ! bus . Init ())   return   false ;    Main Setup Now we will create our  GPIOControl  object and use it to output and input a digital GPIO signal.  // The following code is part of main()  // Create GPIOControl object  matrix_hal :: GPIOControl   gpio ;  // Set gpio to use MatrixIOBus bus  gpio . Setup ( bus );  // Prompt user for GPIO pin  std :: cout     Select Pin [0-15] :  ;  // Log user input  std :: cin     pin ;  // Prompt user for PWM frequency  std :: cout     Select Frequency (in Hz) :  ;  // Log user input  std :: cin     frequency ;  // Prompt user for PWM duty percentage  std :: cout     Select Duty Percentage :  ;  // Log user input  std :: cin     percentage ;  // Set pin mode to output  gpio . SetMode ( pin ,   GPIOOutputMode );  // Set pin function to PWM  gpio . SetFunction ( pin ,   PWMFunction );  // If setting PWM returns an error, log it  // SetPWM function carries out PWM logic and outputs PWM signal  if   ( ! gpio . SetPWM ( frequency ,   percentage ,   pin )) \n     // Output error to console \n     std :: cerr     ERROR: invalid input     std :: endl ;  else \n     // Else output GPIO PWM info to console \n     std :: cout     [ Pin :      pin      ] [ Frequency :      frequency \n                ] [ Duty Percentage :      percentage      ]     std :: endl ;  return   0 ;  }     GPIO Servo The following section shows how to use GPIO in PWM mode for controlling a servo. You can download this example  here .  Include Statements To begin working with the GPIO you need to include these header files.  // Input/output streams and functions  #include   iostream  // Interfaces with GPIO  #include   matrix_hal/gpio_control.h  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h    Initial Variables These initial variables are used in the example.  // GPIOOutputMode is 1  const   uint16_t   GPIOOutputMode   =   1 ;  // GPIOInputMode is 0  const   uint16_t   GPIOInputMode   =   0 ;  // PWMFunction is 1  const   uint16_t   PWMFunction   =   1 ;  // Holds desired PWM frequency  float   frequency ;  // Holds desired PWM duty percentage  float   percentage ;  // Holds desired GPIO pin [0-15]  uint16_t   pin ;  // Holds desired servo angle  float   angle ;  // Holds servo minimum pulse length (for calibration)  float   min_pulse_ms ;    Initial Setup You'll then need to setup  MatrixIOBus  in order to communicate with the hardware on your MATRIX device.  int   main ()   {  // Create MatrixIOBus object for hardware communication  matrix_hal :: MatrixIOBus   bus ;  // Initialize bus and exit program if error occurs  if   ( ! bus . Init ())   return   false ;    Main Setup Now we will create our  GPIOControl  object and use it to output and input a digital GPIO signal.  Servo neutral position is achieved with a 1.5 milliseconds pulse, so by taking the minimum servo pulse (in milliseconds) the SetServoAngle function calibrates servo angle.\nIf unsure of min_pulse_ms enter  0.8 .  // The following code is part of main()  // Create GPIOControl object  matrix_hal :: GPIOControl   gpio ;  // Set gpio to use MatrixIOBus bus  gpio . Setup ( bus );  // Prompt user for GPIO pin  std :: cout     Select Pin [0-15] :  ;  // Log user input  std :: cin     pin ;  // Prompt user for servo angle  std :: cout     Servo Angle :  ;  // Log user input  std :: cin     angle ;  // Prompt user for servo minimum pulse length in ms (for calibration)  std :: cout     Servo Min Pulse (ms) :  ;  // Log user input  std :: cin     min_pulse_ms ;  // Set pin mode to output  gpio . SetMode ( pin ,   GPIOOutputMode );  // Set pin function to PWM  gpio . SetFunction ( pin ,   PWMFunction );  // If setting servo angle returns an error, log it  // SetServoAngle function sets a servo angle based on the min_pulse_ms  if   ( ! gpio . SetServoAngle ( angle ,   min_pulse_ms ,   pin )) \n     // Output error to console \n     std :: cerr     ERROR: invalid input     std :: endl ;  else \n     // Else output servo control info to console \n     std :: cout     [ Pin :      pin      ] \n                [ Servo Angle :      angle \n                ] [ Servo Min Pulse (ms) :      min_pulse_ms      ]  \n               std :: endl ;  return   0 ;  }", 
            "title": "Code Examples"
        }, 
        {
            "location": "/matrix-hal/examples/microphone/", 
            "text": "Microphone Array\n\n\n\nHAL Example\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe microphone array interface supports:\n\n\n\n\nAccepting input from individual microphones\n\n\nAccepting input from beamformed microphone\n\n\n\n\nDevice Pinouts\n:\n\n\n\n\nMATRIX Creator\n\n\nMATRIX Voice\n\n\n\n\nCode Examples\n\n\nBelow are examples of how to interface with the microphone array in MATRIX HAL.\n\n\nMicrophone array function references can be found \nhere\n.\n\n\nThe command below will compile each example. Be sure to pass in your C++ file and desired output file.\n\n\ng\n++\n \n-\no\n \nYOUR_OUTPUT_FILE\n \nYOUR_CPP_FILE\n \n-\nstd\n=\nc\n++\n11\n \n-\nlmatrix_creator_hal\n \n-\nlgflags\n\n\n\n\n\nMicrophone Array Record to File\nThe following section shows how to record data from the microphone array to a file. You can download this example \nhere\n.\n\n\n\n\nBeamformed microphone is channel 8\n\n\n\n\nTo convert the \n.raw\n files outputted by this example to playable \n.wav\n files run these commands, replacing \n16000\n with selected sampling rate.\n\n\nsudo apt-get install sox alsa-utils\nsox -r \n16000\n -c \n1\n -e signed -c \n1\n -e signed -b \n16\n mic_16000_s16le_channel_0.raw channel_0.wav\nsox -r \n16000\n -c \n1\n -e signed -c \n1\n -e signed -b \n16\n mic_16000_s16le_channel_1.raw channel_1.wav\nsox -r \n16000\n -c \n1\n -e signed -c \n1\n -e signed -b \n16\n mic_16000_s16le_channel_2.raw channel_2.wav\nsox -r \n16000\n -c \n1\n -e signed -c \n1\n -e signed -b \n16\n mic_16000_s16le_channel_3.raw channel_3.wav\nsox -r \n16000\n -c \n1\n -e signed -c \n1\n -e signed -b \n16\n mic_16000_s16le_channel_4.raw channel_4.wav\nsox -r \n16000\n -c \n1\n -e signed -c \n1\n -e signed -b \n16\n mic_16000_s16le_channel_5.raw channel_5.wav\nsox -r \n16000\n -c \n1\n -e signed -c \n1\n -e signed -b \n16\n mic_16000_s16le_channel_6.raw channel_6.wav\nsox -r \n16000\n -c \n1\n -e signed -c \n1\n -e signed -b \n16\n mic_16000_s16le_channel_7.raw channel_7.wav\nsox -r \n16000\n -c \n1\n -e signed -c \n1\n -e signed -b \n16\n mic_16000_s16le_channel_8.raw channel_8.wav\n\n\n\n\nInclude Statements\nTo begin working with the Microphone Array you need to include these header files.\n\n\n// Google gflags parser\n\n\n#include\n \ngflags/gflags.h\n\n\n// Communicating with Pi GPIO\n\n\n#include\n \nwiringPi.h\n\n\n// Input/output stream class to operate on files\n\n\n#include\n \nfstream\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n// Use strings\n\n\n#include\n \nstring\n\n\n// Arrays for math operations\n\n\n#include\n \nvalarray\n\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n// Interfaces with microphone array\n\n\n#include\n \nmatrix_hal/microphone_array.h\n\n\n// Enables using FIR filter with microphone array\n\n\n#include\n \nmatrix_hal/microphone_core.h\n\n\n\n\n\n\n\nInitial Variables\nThese initial variables are used in the example.\n\n\n// Defines variables from user arguments using gflags utility\n\n\n// (https://gflags.github.io/gflags/)\n\n\n\n// Grabs sampling frequency input from user\n\n\nDEFINE_int32\n(\nsampling_frequency\n,\n \n16000\n,\n \nSampling Frequency\n);\n  \n// Argument example: \n--sampling_frequency 48000\n\n\n// Grabs duration input from user\n\n\nDEFINE_int32\n(\nduration\n,\n \n5\n,\n \nInterrupt after N seconds\n);\n \n// Argument example: \n--duration 10\n\n\n// Grabs gain input from user\n\n\nDEFINE_int32\n(\ngain\n,\n \n-\n1\n,\n \nMicrophone Gain\n);\n \n// Argument example: \n--gain 5\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device. Also, parse command line flags and set user flags as variables.\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n \n*\nagrv\n[])\n \n{\n\n\n// Parse command line flags with gflags utility\n\n\n// (https://gflags.github.io/gflags/)\n\n\ngoogle\n::\nParseCommandLineFlags\n(\nargc\n,\n \nagrv\n,\n \ntrue\n);\n\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n// Set user flags from gflags as variables\n\n\nint\n \nsampling_rate\n \n=\n \nFLAGS_sampling_frequency\n;\n\n\nint\n \nseconds_to_record\n \n=\n \nFLAGS_duration\n;\n\n\nint\n \ngain\n \n=\n \nFLAGS_gain\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nMicrophoneArray\n object and use it to interface with the microphone array.\n\n\n// The following code is part of main()\n\n\n\n// Create MicrophoneArray object\n\n\nmatrix_hal\n::\nMicrophoneArray\n \nmicrophone_array\n;\n\n\n// Set microphone_array to use MatrixIOBus bus\n\n\nmicrophone_array\n.\nSetup\n(\nbus\n);\n\n\n// Set microphone sampling rate\n\n\nmicrophone_array\n.\nSetSamplingRate\n(\nsampling_rate\n);\n\n\n// If gain is positive, set the gain\n\n\nif\n \n(\ngain\n \n \n0\n)\n \nmicrophone_array\n.\nSetGain\n(\ngain\n);\n\n\n\n// Log gain_ and sampling_frequency_ variables\n\n\nmicrophone_array\n.\nShowConfiguration\n();\n\n\n// Log recording duration variable\n\n\nstd\n::\ncout\n \n \nDuration : \n \n \nseconds_to_record\n \n \ns\n \n \nstd\n::\nendl\n;\n\n\n\n// Calculate and set up beamforming delays for beamforming\n\n\nmicrophone_array\n.\nCalculateDelays\n(\n0\n,\n \n0\n,\n \n1000\n,\n \n320\n \n*\n \n1000\n);\n  \n// These are default values\n\n\n\n\n\n\n\nFir Filter Setup\nNow we will create our \nMicrophoneCore\n object and use it to enable the FIR filter.\n\n\n// The following code is part of main()\n\n\n\n// Create MicrophoneCore object\n\n\nmatrix_hal\n::\nMicrophoneCore\n \nmicrophone_core\n(\nmicrophone_array\n);\n\n\n// Set microphone_core to use MatrixIOBus bus\n\n\nmicrophone_core\n.\nSetup\n(\nbus\n);\n\n\n\n\n\n\n\nMicrophone Input\nNow we will read microphone array data, send to a buffer, and write to file.\n\n\n// The following code is part of main()\n\n\n\n// Create a buffer array for microphone input\n\n\nint16_t\n \nbuffer\n[\nmicrophone_array\n.\nChannels\n()\n \n+\n \n1\n]\n\n                \n[\nmicrophone_array\n.\nSamplingRate\n()\n \n+\n\n                \nmicrophone_array\n.\nNumberOfSamples\n()];\n\n\n\n// Create an array of streams to write microphone data to files\n\n\nstd\n::\nofstream\n \nos\n[\nmicrophone_array\n.\nChannels\n()\n \n+\n \n1\n];\n\n\n\n// For each microphone channel (+1 for beamforming), make a file and open it\n\n\nfor\n \n(\nuint16_t\n \nc\n \n=\n \n0\n;\n \nc\n \n \nmicrophone_array\n.\nChannels\n()\n \n+\n \n1\n;\n \nc\n++\n)\n \n{\n\n    \n// Set filename for microphone output\n\n    \nstd\n::\nstring\n \nfilename\n \n=\n \nmic_\n \n+\n\n                        \nstd\n::\nto_string\n(\nmicrophone_array\n.\nSamplingRate\n())\n \n+\n\n                        \n_s16le_channel_\n \n+\n \nstd\n::\nto_string\n(\nc\n)\n \n+\n \n.raw\n;\n\n    \n// Create and open file\n\n    \nos\n[\nc\n].\nopen\n(\nfilename\n,\n \nstd\n::\nofstream\n::\nbinary\n);\n\n\n}\n\n\n\n// Counter variable for tracking recording time\n\n\nuint32_t\n \nsamples\n \n=\n \n0\n;\n\n\n// For recording duration\n\n\nfor\n \n(\nint\n \ns\n \n=\n \n0\n;\n \ns\n \n \nseconds_to_record\n;\n \ns\n++\n)\n \n{\n\n    \n// Endless loop\n\n    \nwhile\n \n(\ntrue\n)\n \n{\n\n    \n// Read microphone stream data\n\n    \nmicrophone_array\n.\nRead\n();\n\n\n    \n// For number of samples\n\n    \nfor\n \n(\nuint32_t\n \ns\n \n=\n \n0\n;\n \ns\n \n \nmicrophone_array\n.\nNumberOfSamples\n();\n \ns\n++\n)\n \n{\n\n        \n// For each microphone\n\n        \nfor\n \n(\nuint16_t\n \nc\n \n=\n \n0\n;\n \nc\n \n \nmicrophone_array\n.\nChannels\n();\n \nc\n++\n)\n \n{\n\n        \n// Send microphone data to buffer\n\n        \nbuffer\n[\nc\n][\nsamples\n]\n \n=\n \nmicrophone_array\n.\nAt\n(\ns\n,\n \nc\n);\n\n        \n}\n\n        \n// Writes beamformed microphone data into buffer\n\n        \nbuffer\n[\nmicrophone_array\n.\nChannels\n()][\nsamples\n]\n \n=\n \nmicrophone_array\n.\nBeam\n(\ns\n);\n\n        \n// Increment samples for buffer write\n\n        \nsamples\n++\n;\n\n    \n}\n\n\n    \n// Once number of samples is \n= sampling rate\n\n    \nif\n \n(\nsamples\n \n=\n \nmicrophone_array\n.\nSamplingRate\n())\n \n{\n\n        \n// For each microphone channel\n\n        \nfor\n \n(\nuint16_t\n \nc\n \n=\n \n0\n;\n \nc\n \n \nmicrophone_array\n.\nChannels\n()\n \n+\n \n1\n;\n \nc\n++\n)\n \n{\n\n        \n// Write to recording file\n\n        \nos\n[\nc\n].\nwrite\n((\nconst\n \nchar\n \n*\n)\nbuffer\n[\nc\n],\n \nsamples\n \n*\n \nsizeof\n(\nint16_t\n));\n\n        \n}\n\n        \n// Set samples to zero for loop to fill buffer\n\n        \nsamples\n \n=\n \n0\n;\n\n        \nbreak\n;\n\n    \n}\n\n    \n}\n\n\n}\n\n\n\nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\n\n\nMicrophone Array Record to Pipe\nThe following section shows how to record data from the microphone array to a linux FIFO pipe. You can download this example \nhere\n.\n\n\n\n\nWhen beamformed microphone (channel 8) is read from a FIFO pipe distortion may occur.\n\n\n\n\nThe following commands copy a modified \nasound.conf\n file into \n/etc/\n, which allows \narecord\n to record from the pipe.\n\n\nwget https://github.com/matrix-io/matrix-hal-examples/blob/master/microphone_array/asound.conf\nsudo mv -f /etc/asound.conf /etc/asound.conf_old\nsudo mv -f ./asound.conf /etc/\n\n\n\n\nTo record from microphone channel 0 for 5 seconds at 16KHz using \narecord\n, run these commands. \n\n\nrm -rf /tmp/matrix_micarray_channel_*\n./mic_record_pipe --sampling_frequency \n16000\n \n\narecord channel0.wav -f S16_LE -r \n16000\n -d \n5\n --device\n=\nmic_channel0\n\n\n\n\nTo stop the example from running, run this command.\n\n\nkillall mic_record_pipe\n\n\n\n\nInclude Statements\nTo begin working with the Microphone Array you need to include these header files.\n\n\n// Imports FIFO pipe support (https://en.wikipedia.org/wiki/Named_pipe)\n\n\n#include\n \nsys/stat.h\n\n\n// Linux file control options\n\n\n#include\n \nfcntl.h\n\n\n// System calls\n\n\n#include\n \nunistd.h\n\n\n// Google gflags parser\n\n\n#include\n \ngflags/gflags.h\n\n\n// Communicating with Pi GPIO\n\n\n#include\n \nwiringPi.h\n\n\n// Input/output stream class to operate on files\n\n\n#include\n \nfstream\n\n\n// Input/output streams and functions\n\n\n#include\n \niostream\n\n\n// Use strings\n\n\n#include\n \nstring\n\n\n// Arrays for math operations\n\n\n#include\n \nvalarray\n\n\n\n// Communicates with MATRIX device\n\n\n#include\n \nmatrix_hal/matrixio_bus.h\n\n\n// Interfaces with microphone array\n\n\n#include\n \nmatrix_hal/microphone_array.h\n\n\n// Enables using FIR filter with microphone array\n\n\n#include\n \nmatrix_hal/microphone_core.h\n\n\n\n\n\n\n\nInitial Variables\nThese initial variables are used in the example.\n\n\n// Defines variables from user arguments using gflags utility\n\n\n// (https://gflags.github.io/gflags/)\n\n\n\n// Grabs sampling frequency input from user\n\n\nDEFINE_int32\n(\nsampling_frequency\n,\n \n16000\n,\n \nSampling Frequency\n);\n  \n// Argument example: \n--sampling_frequency 48000\n\n\n// Grabs gain input from user\n\n\nDEFINE_int32\n(\ngain\n,\n \n-\n1\n,\n \nMicrophone Gain\n);\n \n// Argument example: \n--gain 5\n\n\n\n\n\n\n\nInitial Setup\nYou'll then need to setup \nMatrixIOBus\n in order to communicate with the hardware on your MATRIX device. Also, parse command line flags and set user flags as variables.\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n \n*\nagrv\n[])\n \n{\n\n\n// Parse command line flags with gflags utility\n\n\n// (https://gflags.github.io/gflags/)\n\n\ngoogle\n::\nParseCommandLineFlags\n(\nargc\n,\n \nagrv\n,\n \ntrue\n);\n\n\n\n// Create MatrixIOBus object for hardware communication\n\n\nmatrix_hal\n::\nMatrixIOBus\n \nbus\n;\n\n\n// Initialize bus and exit program if error occurs\n\n\nif\n \n(\n!\nbus\n.\nInit\n())\n \nreturn\n \nfalse\n;\n\n\n\n// Set user flags from gflags as variables\n\n\nint\n \nsampling_rate\n \n=\n \nFLAGS_sampling_frequency\n;\n\n\nint\n \ngain\n \n=\n \nFLAGS_gain\n;\n\n\n\n\n\n\n\nMain Setup\nNow we will create our \nMicrophoneArray\n object and use it to interface with the microphone array.\n\n\n// The following code is part of main()\n\n\n\n// Create MicrophoneArray object\n\n\nmatrix_hal\n::\nMicrophoneArray\n \nmicrophone_array\n;\n\n\n// Set microphone_array to use MatrixIOBus bus\n\n\nmicrophone_array\n.\nSetup\n(\nbus\n);\n\n\n// Set microphone sampling rate\n\n\nmicrophone_array\n.\nSetSamplingRate\n(\nsampling_rate\n);\n\n\n// If gain is positive, set the gain\n\n\nif\n \n(\ngain\n \n \n0\n)\n \nmicrophone_array\n.\nSetGain\n(\ngain\n);\n\n\n\n// Log gain_ and sampling_frequency_ variables\n\n\nmicrophone_array\n.\nShowConfiguration\n();\n\n\n// Log recording duration variable\n\n\nstd\n::\ncout\n \n \nDuration : \n \n \nseconds_to_record\n \n \ns\n \n \nstd\n::\nendl\n;\n\n\n\n// Calculate and set up beamforming delays for beamforming\n\n\nmicrophone_array\n.\nCalculateDelays\n(\n0\n,\n \n0\n,\n \n1000\n,\n \n320\n \n*\n \n1000\n);\n  \n// These are default values\n\n\n\n\n\n\n\nFir Filter Setup\nNow we will create our \nMicrophoneCore\n object and use it to enable the FIR filter.\n\n\n// The following code is part of main()\n\n\n\n// Create MicrophoneCore object\n\n\nmatrix_hal\n::\nMicrophoneCore\n \nmicrophone_core\n(\nmicrophone_array\n);\n\n\n// Set microphone_core to use MatrixIOBus bus\n\n\nmicrophone_core\n.\nSetup\n(\nbus\n);\n\n\n\n\n\n\n\nMicrophone Input\nNow we will read microphone array data, send to a buffer, and write to a FIFO pipe.\n\n\n// The following code is part of main()\n\n\n\n// Create a buffer array for microphone input\n\n\nint16_t\n \nbuffer\n[\nmicrophone_array\n.\nChannels\n()\n \n+\n \n1\n]\n\n                \n[\nmicrophone_array\n.\nSamplingRate\n()\n \n+\n\n                \nmicrophone_array\n.\nNumberOfSamples\n()];\n\n\n\n// For each channel plus the beamforming channel\n\n\nfor\n \n(\nuint16_t\n \nc\n \n=\n \n0\n;\n \nc\n \n \nmicrophone_array\n.\nChannels\n()\n \n+\n \n1\n;\n \nc\n++\n)\n \n{\n\n    \n// Name for the FIFO pipe\n\n    \nstd\n::\nstring\n \nname\n \n=\n \n/tmp/matrix_micarray_channel_\n \n+\n \nstd\n::\nto_string\n(\nc\n);\n\n\n    \n// Create the FIFO pipe\n\n    \nif\n \n(\nmkfifo\n(\nname\n.\nc_str\n(),\n \n0666\n)\n \n!=\n \n0\n)\n \n{\n\n    \n// Output error if mkfifo fails\n\n    \nstd\n::\ncerr\n \n \nunable to create \n \n \nname\n \n \n FIFO.\n \n \nstd\n::\nendl\n;\n\n    \n}\n\n\n}\n\n\n\n// For pipe operations\n\n\nint\n \nnamed_pipe_handle\n;\n\n\n// Endless loop\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n    \n// Read microphone stream data\n\n    \nmicrophone_array\n.\nRead\n();\n\n\n    \n// Bool to flag when beamformed written\n\n    \nbool\n \nbeam_write\n \n=\n \nfalse\n;\n\n\n    \n// For each microphone\n\n    \nfor\n \n(\nuint16_t\n \nc\n \n=\n \n0\n;\n \nc\n \n \nmicrophone_array\n.\nChannels\n()\n \n+\n \n1\n;\n \nc\n++\n)\n \n{\n\n    \n// Open pipe\n\n    \nstd\n::\nstring\n \nname\n \n=\n \n/tmp/matrix_micarray_channel_\n \n+\n \nstd\n::\nto_string\n(\nc\n);\n\n    \nnamed_pipe_handle\n \n=\n \nopen\n(\nname\n.\nc_str\n(),\n \nO_WRONLY\n \n|\n \nO_NONBLOCK\n);\n\n\n    \n// For number of samples\n\n    \nfor\n \n(\nuint32_t\n \ns\n \n=\n \n0\n;\n \ns\n \n \nmicrophone_array\n.\nNumberOfSamples\n();\n \ns\n++\n)\n \n{\n\n        \nbuffer\n[\nc\n][\ns\n]\n \n=\n \nmicrophone_array\n.\nAt\n(\ns\n,\n \nc\n);\n\n        \n// If beamformed data was not sent to buffer, send it\n\n        \nif\n \n(\n!\nbeam_write\n)\n \n{\n\n        \n// Send beamformed data to buffer\n\n        \nbuffer\n[\nmicrophone_array\n.\nChannels\n()][\ns\n]\n \n=\n \nmicrophone_array\n.\nBeam\n(\ns\n);\n\n        \n}\n\n    \n}\n\n    \n// Flag that beamforming data is in buffer\n\n    \nbeam_write\n \n=\n \ntrue\n;\n\n\n    \n// Write to each pipe\n\n    \nwrite\n(\nnamed_pipe_handle\n,\n \nbuffer\n[\nc\n][\n0\n],\n\n            \nsizeof\n(\nint16_t\n)\n \n*\n \nmicrophone_array\n.\nNumberOfSamples\n());\n\n    \n// Close pipe after write\n\n    \nclose\n(\nnamed_pipe_handle\n);\n\n    \n}\n\n\n}\n\n\n\nreturn\n \n0\n;\n\n\n}", 
            "title": "Microphone"
        }, 
        {
            "location": "/matrix-hal/examples/microphone/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-hal/examples/microphone/#overview", 
            "text": "The microphone array interface supports:   Accepting input from individual microphones  Accepting input from beamformed microphone   Device Pinouts :   MATRIX Creator  MATRIX Voice", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/examples/microphone/#code-examples", 
            "text": "Below are examples of how to interface with the microphone array in MATRIX HAL.  Microphone array function references can be found  here .  The command below will compile each example. Be sure to pass in your C++ file and desired output file.  g ++   - o   YOUR_OUTPUT_FILE   YOUR_CPP_FILE   - std = c ++ 11   - lmatrix_creator_hal   - lgflags   Microphone Array Record to File The following section shows how to record data from the microphone array to a file. You can download this example  here .   Beamformed microphone is channel 8   To convert the  .raw  files outputted by this example to playable  .wav  files run these commands, replacing  16000  with selected sampling rate.  sudo apt-get install sox alsa-utils\nsox -r  16000  -c  1  -e signed -c  1  -e signed -b  16  mic_16000_s16le_channel_0.raw channel_0.wav\nsox -r  16000  -c  1  -e signed -c  1  -e signed -b  16  mic_16000_s16le_channel_1.raw channel_1.wav\nsox -r  16000  -c  1  -e signed -c  1  -e signed -b  16  mic_16000_s16le_channel_2.raw channel_2.wav\nsox -r  16000  -c  1  -e signed -c  1  -e signed -b  16  mic_16000_s16le_channel_3.raw channel_3.wav\nsox -r  16000  -c  1  -e signed -c  1  -e signed -b  16  mic_16000_s16le_channel_4.raw channel_4.wav\nsox -r  16000  -c  1  -e signed -c  1  -e signed -b  16  mic_16000_s16le_channel_5.raw channel_5.wav\nsox -r  16000  -c  1  -e signed -c  1  -e signed -b  16  mic_16000_s16le_channel_6.raw channel_6.wav\nsox -r  16000  -c  1  -e signed -c  1  -e signed -b  16  mic_16000_s16le_channel_7.raw channel_7.wav\nsox -r  16000  -c  1  -e signed -c  1  -e signed -b  16  mic_16000_s16le_channel_8.raw channel_8.wav  Include Statements To begin working with the Microphone Array you need to include these header files.  // Google gflags parser  #include   gflags/gflags.h  // Communicating with Pi GPIO  #include   wiringPi.h  // Input/output stream class to operate on files  #include   fstream  // Input/output streams and functions  #include   iostream  // Use strings  #include   string  // Arrays for math operations  #include   valarray  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h  // Interfaces with microphone array  #include   matrix_hal/microphone_array.h  // Enables using FIR filter with microphone array  #include   matrix_hal/microphone_core.h    Initial Variables These initial variables are used in the example.  // Defines variables from user arguments using gflags utility  // (https://gflags.github.io/gflags/)  // Grabs sampling frequency input from user  DEFINE_int32 ( sampling_frequency ,   16000 ,   Sampling Frequency );    // Argument example:  --sampling_frequency 48000  // Grabs duration input from user  DEFINE_int32 ( duration ,   5 ,   Interrupt after N seconds );   // Argument example:  --duration 10  // Grabs gain input from user  DEFINE_int32 ( gain ,   - 1 ,   Microphone Gain );   // Argument example:  --gain 5    Initial Setup You'll then need to setup  MatrixIOBus  in order to communicate with the hardware on your MATRIX device. Also, parse command line flags and set user flags as variables.  int   main ( int   argc ,   char   * agrv [])   {  // Parse command line flags with gflags utility  // (https://gflags.github.io/gflags/)  google :: ParseCommandLineFlags ( argc ,   agrv ,   true );  // Create MatrixIOBus object for hardware communication  matrix_hal :: MatrixIOBus   bus ;  // Initialize bus and exit program if error occurs  if   ( ! bus . Init ())   return   false ;  // Set user flags from gflags as variables  int   sampling_rate   =   FLAGS_sampling_frequency ;  int   seconds_to_record   =   FLAGS_duration ;  int   gain   =   FLAGS_gain ;    Main Setup Now we will create our  MicrophoneArray  object and use it to interface with the microphone array.  // The following code is part of main()  // Create MicrophoneArray object  matrix_hal :: MicrophoneArray   microphone_array ;  // Set microphone_array to use MatrixIOBus bus  microphone_array . Setup ( bus );  // Set microphone sampling rate  microphone_array . SetSamplingRate ( sampling_rate );  // If gain is positive, set the gain  if   ( gain     0 )   microphone_array . SetGain ( gain );  // Log gain_ and sampling_frequency_ variables  microphone_array . ShowConfiguration ();  // Log recording duration variable  std :: cout     Duration :      seconds_to_record     s     std :: endl ;  // Calculate and set up beamforming delays for beamforming  microphone_array . CalculateDelays ( 0 ,   0 ,   1000 ,   320   *   1000 );    // These are default values    Fir Filter Setup Now we will create our  MicrophoneCore  object and use it to enable the FIR filter.  // The following code is part of main()  // Create MicrophoneCore object  matrix_hal :: MicrophoneCore   microphone_core ( microphone_array );  // Set microphone_core to use MatrixIOBus bus  microphone_core . Setup ( bus );    Microphone Input Now we will read microphone array data, send to a buffer, and write to file.  // The following code is part of main()  // Create a buffer array for microphone input  int16_t   buffer [ microphone_array . Channels ()   +   1 ] \n                 [ microphone_array . SamplingRate ()   + \n                 microphone_array . NumberOfSamples ()];  // Create an array of streams to write microphone data to files  std :: ofstream   os [ microphone_array . Channels ()   +   1 ];  // For each microphone channel (+1 for beamforming), make a file and open it  for   ( uint16_t   c   =   0 ;   c     microphone_array . Channels ()   +   1 ;   c ++ )   { \n     // Set filename for microphone output \n     std :: string   filename   =   mic_   + \n                         std :: to_string ( microphone_array . SamplingRate ())   + \n                         _s16le_channel_   +   std :: to_string ( c )   +   .raw ; \n     // Create and open file \n     os [ c ]. open ( filename ,   std :: ofstream :: binary );  }  // Counter variable for tracking recording time  uint32_t   samples   =   0 ;  // For recording duration  for   ( int   s   =   0 ;   s     seconds_to_record ;   s ++ )   { \n     // Endless loop \n     while   ( true )   { \n     // Read microphone stream data \n     microphone_array . Read (); \n\n     // For number of samples \n     for   ( uint32_t   s   =   0 ;   s     microphone_array . NumberOfSamples ();   s ++ )   { \n         // For each microphone \n         for   ( uint16_t   c   =   0 ;   c     microphone_array . Channels ();   c ++ )   { \n         // Send microphone data to buffer \n         buffer [ c ][ samples ]   =   microphone_array . At ( s ,   c ); \n         } \n         // Writes beamformed microphone data into buffer \n         buffer [ microphone_array . Channels ()][ samples ]   =   microphone_array . Beam ( s ); \n         // Increment samples for buffer write \n         samples ++ ; \n     } \n\n     // Once number of samples is  = sampling rate \n     if   ( samples   =   microphone_array . SamplingRate ())   { \n         // For each microphone channel \n         for   ( uint16_t   c   =   0 ;   c     microphone_array . Channels ()   +   1 ;   c ++ )   { \n         // Write to recording file \n         os [ c ]. write (( const   char   * ) buffer [ c ],   samples   *   sizeof ( int16_t )); \n         } \n         // Set samples to zero for loop to fill buffer \n         samples   =   0 ; \n         break ; \n     } \n     }  }  return   0 ;  }     Microphone Array Record to Pipe The following section shows how to record data from the microphone array to a linux FIFO pipe. You can download this example  here .   When beamformed microphone (channel 8) is read from a FIFO pipe distortion may occur.   The following commands copy a modified  asound.conf  file into  /etc/ , which allows  arecord  to record from the pipe.  wget https://github.com/matrix-io/matrix-hal-examples/blob/master/microphone_array/asound.conf\nsudo mv -f /etc/asound.conf /etc/asound.conf_old\nsudo mv -f ./asound.conf /etc/  To record from microphone channel 0 for 5 seconds at 16KHz using  arecord , run these commands.   rm -rf /tmp/matrix_micarray_channel_*\n./mic_record_pipe --sampling_frequency  16000   \narecord channel0.wav -f S16_LE -r  16000  -d  5  --device = mic_channel0  To stop the example from running, run this command.  killall mic_record_pipe  Include Statements To begin working with the Microphone Array you need to include these header files.  // Imports FIFO pipe support (https://en.wikipedia.org/wiki/Named_pipe)  #include   sys/stat.h  // Linux file control options  #include   fcntl.h  // System calls  #include   unistd.h  // Google gflags parser  #include   gflags/gflags.h  // Communicating with Pi GPIO  #include   wiringPi.h  // Input/output stream class to operate on files  #include   fstream  // Input/output streams and functions  #include   iostream  // Use strings  #include   string  // Arrays for math operations  #include   valarray  // Communicates with MATRIX device  #include   matrix_hal/matrixio_bus.h  // Interfaces with microphone array  #include   matrix_hal/microphone_array.h  // Enables using FIR filter with microphone array  #include   matrix_hal/microphone_core.h    Initial Variables These initial variables are used in the example.  // Defines variables from user arguments using gflags utility  // (https://gflags.github.io/gflags/)  // Grabs sampling frequency input from user  DEFINE_int32 ( sampling_frequency ,   16000 ,   Sampling Frequency );    // Argument example:  --sampling_frequency 48000  // Grabs gain input from user  DEFINE_int32 ( gain ,   - 1 ,   Microphone Gain );   // Argument example:  --gain 5    Initial Setup You'll then need to setup  MatrixIOBus  in order to communicate with the hardware on your MATRIX device. Also, parse command line flags and set user flags as variables.  int   main ( int   argc ,   char   * agrv [])   {  // Parse command line flags with gflags utility  // (https://gflags.github.io/gflags/)  google :: ParseCommandLineFlags ( argc ,   agrv ,   true );  // Create MatrixIOBus object for hardware communication  matrix_hal :: MatrixIOBus   bus ;  // Initialize bus and exit program if error occurs  if   ( ! bus . Init ())   return   false ;  // Set user flags from gflags as variables  int   sampling_rate   =   FLAGS_sampling_frequency ;  int   gain   =   FLAGS_gain ;    Main Setup Now we will create our  MicrophoneArray  object and use it to interface with the microphone array.  // The following code is part of main()  // Create MicrophoneArray object  matrix_hal :: MicrophoneArray   microphone_array ;  // Set microphone_array to use MatrixIOBus bus  microphone_array . Setup ( bus );  // Set microphone sampling rate  microphone_array . SetSamplingRate ( sampling_rate );  // If gain is positive, set the gain  if   ( gain     0 )   microphone_array . SetGain ( gain );  // Log gain_ and sampling_frequency_ variables  microphone_array . ShowConfiguration ();  // Log recording duration variable  std :: cout     Duration :      seconds_to_record     s     std :: endl ;  // Calculate and set up beamforming delays for beamforming  microphone_array . CalculateDelays ( 0 ,   0 ,   1000 ,   320   *   1000 );    // These are default values    Fir Filter Setup Now we will create our  MicrophoneCore  object and use it to enable the FIR filter.  // The following code is part of main()  // Create MicrophoneCore object  matrix_hal :: MicrophoneCore   microphone_core ( microphone_array );  // Set microphone_core to use MatrixIOBus bus  microphone_core . Setup ( bus );    Microphone Input Now we will read microphone array data, send to a buffer, and write to a FIFO pipe.  // The following code is part of main()  // Create a buffer array for microphone input  int16_t   buffer [ microphone_array . Channels ()   +   1 ] \n                 [ microphone_array . SamplingRate ()   + \n                 microphone_array . NumberOfSamples ()];  // For each channel plus the beamforming channel  for   ( uint16_t   c   =   0 ;   c     microphone_array . Channels ()   +   1 ;   c ++ )   { \n     // Name for the FIFO pipe \n     std :: string   name   =   /tmp/matrix_micarray_channel_   +   std :: to_string ( c ); \n\n     // Create the FIFO pipe \n     if   ( mkfifo ( name . c_str (),   0666 )   !=   0 )   { \n     // Output error if mkfifo fails \n     std :: cerr     unable to create      name      FIFO.     std :: endl ; \n     }  }  // For pipe operations  int   named_pipe_handle ;  // Endless loop  while   ( true )   { \n     // Read microphone stream data \n     microphone_array . Read (); \n\n     // Bool to flag when beamformed written \n     bool   beam_write   =   false ; \n\n     // For each microphone \n     for   ( uint16_t   c   =   0 ;   c     microphone_array . Channels ()   +   1 ;   c ++ )   { \n     // Open pipe \n     std :: string   name   =   /tmp/matrix_micarray_channel_   +   std :: to_string ( c ); \n     named_pipe_handle   =   open ( name . c_str (),   O_WRONLY   |   O_NONBLOCK ); \n\n     // For number of samples \n     for   ( uint32_t   s   =   0 ;   s     microphone_array . NumberOfSamples ();   s ++ )   { \n         buffer [ c ][ s ]   =   microphone_array . At ( s ,   c ); \n         // If beamformed data was not sent to buffer, send it \n         if   ( ! beam_write )   { \n         // Send beamformed data to buffer \n         buffer [ microphone_array . Channels ()][ s ]   =   microphone_array . Beam ( s ); \n         } \n     } \n     // Flag that beamforming data is in buffer \n     beam_write   =   true ; \n\n     // Write to each pipe \n     write ( named_pipe_handle ,   buffer [ c ][ 0 ], \n             sizeof ( int16_t )   *   microphone_array . NumberOfSamples ()); \n     // Close pipe after write \n     close ( named_pipe_handle ); \n     }  }  return   0 ;  }", 
            "title": "Code Examples"
        }, 
        {
            "location": "/matrix-hal/troubleshooting/", 
            "text": "Community\n\n\nPlease visit our community support forums at\n\ncommunity.matrix.one\n\n\nCheck Installed MATRIX Packages\n\n\nRun the following command on your Raspberry Pi's terminal to see the currently installed MATRIX packages. \n\ndpkg -l \n|\n grep matrix\n\n\n\nReinstall MATRIX HAL\n\n\nIf you experience strange behavior, reinstall MATRIX HAL.\n\n\nUninstall the \nlibmatrixio-creator-hal\n and \nlibmatrixio-creator-hal-dev\n package.\n\n\nsudo apt-get --purge remove libmatrixio-creator-hal libmatrixio-creator-hal-dev\n\n\n\n\nUninstall HAL built from source.\n\n\nsudo rm -rf /usr/local/include/matrix_hal\nsudo rm -rf /usr/local/lib/libmatrix_creator_hal.so\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nInstall MATRIX HAL from \npackage\n or from \nsource\n.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-hal/troubleshooting/#community", 
            "text": "Please visit our community support forums at community.matrix.one", 
            "title": "Community"
        }, 
        {
            "location": "/matrix-hal/troubleshooting/#check-installed-matrix-packages", 
            "text": "Run the following command on your Raspberry Pi's terminal to see the currently installed MATRIX packages.  dpkg -l  |  grep matrix", 
            "title": "Check Installed MATRIX Packages"
        }, 
        {
            "location": "/matrix-hal/troubleshooting/#reinstall-matrix-hal", 
            "text": "If you experience strange behavior, reinstall MATRIX HAL.  Uninstall the  libmatrixio-creator-hal  and  libmatrixio-creator-hal-dev  package.  sudo apt-get --purge remove libmatrixio-creator-hal libmatrixio-creator-hal-dev  Uninstall HAL built from source.  sudo rm -rf /usr/local/include/matrix_hal\nsudo rm -rf /usr/local/lib/libmatrix_creator_hal.so  Reboot your device.  sudo reboot  Install MATRIX HAL from  package  or from  source .", 
            "title": "Reinstall MATRIX HAL"
        }, 
        {
            "location": "/matrix-core/overview/", 
            "text": "MATRIX CORE\n\n\n\n\n\nPreviously known as MATRIX MALOS.\n\n\n\n\nMATRIX CORE is an abstraction layer for \nMATRIX HAL\n. This layer uses \n\nProtocol Buffers\n \n \nZeroMQ\n to communicate with your MATRIX device. Applications for your MATRIX device can be programmed with any language that supports these tools.\n\n\nGetting Started\n\n\nLearn how to install MATRIX CORE and gain a deeper understanding of how this layer interacts with your MATRIX device. Setup tutorials and hello world examples for Javascript, Python, and Golang are available here.\n\n\nDriver Protocols\n\n\nSee the available drivers you can interact with and the protocols they require for communicating with your application.\n\n\nLibrary Examples\n\n\n\n\nJavascript\n\n\nPython\n\n\n\n\nTroubleshooting\n\n\nLook at common debugging solutions for any issues you encounter.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/overview/#getting-started", 
            "text": "Learn how to install MATRIX CORE and gain a deeper understanding of how this layer interacts with your MATRIX device. Setup tutorials and hello world examples for Javascript, Python, and Golang are available here.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/matrix-core/overview/#driver-protocols", 
            "text": "See the available drivers you can interact with and the protocols they require for communicating with your application.", 
            "title": "Driver Protocols"
        }, 
        {
            "location": "/matrix-core/overview/#library-examples", 
            "text": "", 
            "title": "Library Examples"
        }, 
        {
            "location": "/matrix-core/overview/#troubleshooting", 
            "text": "Look at common debugging solutions for any issues you encounter.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-core/getting-started/", 
            "text": "Getting Started\n\n\nInstallation\n\n\n\nLearn how to install MATRIX CORE on your MATRIX Device.\n\n\nUnderstanding CORE\n\n\n\nUnderstand how MATRIX CORE uses ZeroMQ to communicate with Protocol Buffers.\n\n\n\nProgramming Languages\n\n\n \nJavascript Setup\n\n\n\nUse Javascript to program with MATRIX CORE.\n\n\nPython Setup\n\n\n\nUse Python to program with MATRIX CORE.\n\n\nGolang Setup\n\n\n\nUse Golang to program with MATRIX CORE.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-core/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/matrix-core/getting-started/#programming-languages", 
            "text": "", 
            "title": "Programming Languages"
        }, 
        {
            "location": "/matrix-core/getting-started/core-installation/", 
            "text": "Installing MATRIX CORE\n\n\n\n\n\nMake sure you have setup your\n\nMATRIX Creator\n or \n\nMATRIX Voice\n before continuing.\n\n\n\n\nInstallation\n\n\nBefore starting, ensure you have access to the terminal of your Raspberry Pi via an \nSSH-session\n or a connected screen, mouse, and keyboard. Then insert and run the following commands into your Raspberry Pi's terminal, one at a time.\n\n\nAdd the MATRIX repository and key.\n\n\ncurl https://apt.matrix.one/doc/apt-key.gpg \n|\n sudo apt-key add -\n\necho\n \ndeb https://apt.matrix.one/raspbian \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n\n\n\nUpdate your repository and packages.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\nInstall the the MATRIX CORE packages.\n\n\nsudo apt-get install matrixio-malos\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nMATRIX CORE will now be running as a service each time your Raspberry Pi boots up.\n\n\nThese remaining commands will install \nZeroMQ\n.\n\n\necho\n \ndeb http://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/Debian_9.0/ ./\n \n|\n sudo tee /etc/apt/sources.list.d/zeromq.list\nwget https://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/Debian_9.0/Release.key -O- \n|\n sudo apt-key add\n\n\n\n\n\n\nNext Steps\n\n\nNow that you have MATRIX CORE and ZeroMQ installed, please take a look at Understanding CORE \nhere\n.\n\n\nIf you're already familiar, you can learn how to setup a programming language for communicating with CORE.  We currently have tutorials for the following languages:\n\n\n\n\nJavascript\n\n\nPython\n\n\nGolang\n\n\n\n\n\n\nHelpful Information\n\n\nUpgrading\n\n\nIf you need to upgrade your MATRIX CORE package at any time, please run the following commands on your Raspberry Pi.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\nA reboot will be required after upgrading your packages.\n\n\nsudo reboot\n\n\n\n\nStopping \n&\n Starting\n\n\n\nIf you need to manually stop MATRIX CORE use:\n\n\nsudo pkill -9 malos\n\n\n\n\nIf you need to manually start MATRIX CORE again use:\n\n\nmalos", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-core/getting-started/core-installation/#installation", 
            "text": "Before starting, ensure you have access to the terminal of your Raspberry Pi via an  SSH-session  or a connected screen, mouse, and keyboard. Then insert and run the following commands into your Raspberry Pi's terminal, one at a time.  Add the MATRIX repository and key.  curl https://apt.matrix.one/doc/apt-key.gpg  |  sudo apt-key add - echo   deb https://apt.matrix.one/raspbian  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/matrixlabs.list  Update your repository and packages.  sudo apt-get update\nsudo apt-get upgrade  Install the the MATRIX CORE packages.  sudo apt-get install matrixio-malos  Reboot your device.  sudo reboot  MATRIX CORE will now be running as a service each time your Raspberry Pi boots up.  These remaining commands will install  ZeroMQ .  echo   deb http://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/Debian_9.0/ ./   |  sudo tee /etc/apt/sources.list.d/zeromq.list\nwget https://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/Debian_9.0/Release.key -O-  |  sudo apt-key add", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-core/getting-started/core-installation/#next-steps", 
            "text": "Now that you have MATRIX CORE and ZeroMQ installed, please take a look at Understanding CORE  here .  If you're already familiar, you can learn how to setup a programming language for communicating with CORE.  We currently have tutorials for the following languages:   Javascript  Python  Golang", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-core/getting-started/core-installation/#helpful-information", 
            "text": "", 
            "title": "Helpful Information"
        }, 
        {
            "location": "/matrix-core/getting-started/understanding-core/", 
            "text": "Overview\n\n\nMATRIX CORE functions by sending and receiving \nProtocol Buffers\n over a \nZeroMQ\n connection. This can be used to query sensors and control any MATRIX device from any language that supports Protocol Buffers (version 3.X) and ZeroMQ.\n\n\n\n\nPorts \n Protocol\n\n\nMATRIX CORE contains drivers (components \n sensors) that communicate with your MATRIX device. This occurs by having each driver send or receive Protocol Buffers over a ZeroMQ driver port. Depending on the driver port it may allow for \nread-only\n, \nwrite-only\n or \nread-write\n.\n\n\nCurrent Driver Base Ports:\n\n\n\n\nIMU\n - \n20013\n\n\nHumidity\n - \n20017\n\n\nEverloop\n - \n20021\n\n\nPressure\n - \n20025\n\n\nUV\n - \n20029\n\n\n\n\n\n\nServo\n - \n20045\n\n\nGPIO\n - \n20049\n\n\nWakeword\n - \n60001\n\n\n\n\nEach driver reserves 4 ports beginning with their \nbase port\n as shown above. The other 3 ports are in sequential order counting up from the \nbase port\n. Below is an example of all IMU ports. Note, not all drivers utilize every port.\n\n\nAll IMU Ports\n\n\n\n\nIMU Base Port\n - \n20013\n\n\nIMU Keep-Alive Port\n - \n20014\n\n\nIMU Error Port\n - \n20015\n\n\nIMU Data Update Port\n - \n20016\n\n\n\n\nBase Port\nThe \nbase port\n is used to configure a driver on your MATRIX device. This port is a \nZeroMQ PULL port\n that accepts a configuration which is created as a protocol buffer.\n\n\nTo send a configuration you need to create a valid message for each driver. For example, the UV driver uses a configuration message to set the refresh rate and timeout for sending UV data.\n\n\nConfiguration messages are named \nDriverConfig\n. The file for where this is defined can be seen \nhere\n.\n\n\nBelow is an example for a UV configuration message:\n\nmessage\n \nDriverConfig\n \n{\n\n\n// Delay between updates. In seconds.\n\n\nfloat\n \ndelay_between_updates\n \n=\n \n1\n;\n\n\n// Timeout after last ping.\n\n\nfloat\n \ntimeout_after_last_ping\n \n=\n \n2\n;\n\n\n}\n\n\n\n\nOnce the \nDriverConfig\n message is filled out, it needs to be serialized as a string and sent to the ZeroMQ configuration port.\n\n\n\n\n\n\n\nKeep-alive Port\nPort\n: \nbase port\n + 1\n\n\nThe Keep-alive port is a \nZeroMQ PULL port\n that is required for certain drivers to keep their function alive. Drivers that are pushing data need this in place to let it know if data will continue to be requested. For example, the Everloop driver doesn't require Keep-alive messages, but the Humidity driver does. Any message that is sent to the Keep-alive port will be discarded, so an empty string \n\"\"\n makes for a good Keep-alive message.\n\n\n\n\n\n\n\nError Port\nPort\n: \nbase port\n + 2\n\n\nPrograms can subscribe to this port to receive driver related errors. The Error port is a \nZeroMQ PUSH port\n that will send you a string with any errors that it has encountered.\n\n\n\n\n\n\n\nData Update Port\nPort\n: \nbase port\n + 3\n\n\nThis \nZeroMQ PUSH port\n is used by drivers that send data (Humidity, UV, etc.). Each driver uses a different message to report data to programs that subscribe for these updates.\n\n\nTo demonstrate, the UV driver will be used as an example. You can find the file \nhere\n.\nThe message follows:\n\n\n// Basic UV radiation lecture.\n\n\nmessage\n \nUV\n{\n\n\n// UV index\n\n\nfloat\n \nuv_index\n \n=\n \n1\n;\n\n\n// OMS risk\n\n\nstring\n \noms_risk\n \n=\n \n2\n;\n\n\n}\n\n\n\n\n\nApplications that subscribe to UV driver updates will receive a string with serialized messages of type UV. Once received, the message needs to be deserialized by the application for the values can be used.\n\n\n\n\n\n\nNext Steps\n\n\nWe currently provide libraries and examples for the following languages:\n\n\n\n\nJavascript\n\n\nPython\n\n\n\n\nIf you want to use another protocol buffer supported programming language then we suggest you view the \nProtocol Buffers Documentation\n for the language you want to use in MATRIX CORE. Remember to use \nZeroMQ\n for sending these Protocol Buffers. You can view the protocols for each of our drivers \nhere\n.", 
            "title": "Understanding CORE"
        }, 
        {
            "location": "/matrix-core/getting-started/understanding-core/#overview", 
            "text": "MATRIX CORE functions by sending and receiving  Protocol Buffers  over a  ZeroMQ  connection. This can be used to query sensors and control any MATRIX device from any language that supports Protocol Buffers (version 3.X) and ZeroMQ.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/getting-started/understanding-core/#ports-protocol", 
            "text": "MATRIX CORE contains drivers (components   sensors) that communicate with your MATRIX device. This occurs by having each driver send or receive Protocol Buffers over a ZeroMQ driver port. Depending on the driver port it may allow for  read-only ,  write-only  or  read-write .  Current Driver Base Ports:   IMU  -  20013  Humidity  -  20017  Everloop  -  20021  Pressure  -  20025  UV  -  20029    Servo  -  20045  GPIO  -  20049  Wakeword  -  60001   Each driver reserves 4 ports beginning with their  base port  as shown above. The other 3 ports are in sequential order counting up from the  base port . Below is an example of all IMU ports. Note, not all drivers utilize every port.  All IMU Ports   IMU Base Port  -  20013  IMU Keep-Alive Port  -  20014  IMU Error Port  -  20015  IMU Data Update Port  -  20016   Base Port The  base port  is used to configure a driver on your MATRIX device. This port is a  ZeroMQ PULL port  that accepts a configuration which is created as a protocol buffer.  To send a configuration you need to create a valid message for each driver. For example, the UV driver uses a configuration message to set the refresh rate and timeout for sending UV data.  Configuration messages are named  DriverConfig . The file for where this is defined can be seen  here .  Below is an example for a UV configuration message: message   DriverConfig   {  // Delay between updates. In seconds.  float   delay_between_updates   =   1 ;  // Timeout after last ping.  float   timeout_after_last_ping   =   2 ;  }   Once the  DriverConfig  message is filled out, it needs to be serialized as a string and sent to the ZeroMQ configuration port.    Keep-alive Port Port :  base port  + 1  The Keep-alive port is a  ZeroMQ PULL port  that is required for certain drivers to keep their function alive. Drivers that are pushing data need this in place to let it know if data will continue to be requested. For example, the Everloop driver doesn't require Keep-alive messages, but the Humidity driver does. Any message that is sent to the Keep-alive port will be discarded, so an empty string  \"\"  makes for a good Keep-alive message.    Error Port Port :  base port  + 2  Programs can subscribe to this port to receive driver related errors. The Error port is a  ZeroMQ PUSH port  that will send you a string with any errors that it has encountered.    Data Update Port Port :  base port  + 3  This  ZeroMQ PUSH port  is used by drivers that send data (Humidity, UV, etc.). Each driver uses a different message to report data to programs that subscribe for these updates.  To demonstrate, the UV driver will be used as an example. You can find the file  here .\nThe message follows:  // Basic UV radiation lecture.  message   UV {  // UV index  float   uv_index   =   1 ;  // OMS risk  string   oms_risk   =   2 ;  }   Applications that subscribe to UV driver updates will receive a string with serialized messages of type UV. Once received, the message needs to be deserialized by the application for the values can be used.", 
            "title": "Ports &amp; Protocol"
        }, 
        {
            "location": "/matrix-core/getting-started/understanding-core/#next-steps", 
            "text": "We currently provide libraries and examples for the following languages:   Javascript  Python   If you want to use another protocol buffer supported programming language then we suggest you view the  Protocol Buffers Documentation  for the language you want to use in MATRIX CORE. Remember to use  ZeroMQ  for sending these Protocol Buffers. You can view the protocols for each of our drivers  here .", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-core/getting-started/javascript-installation/", 
            "text": "Ensure you have \nMATRIX CORE\n installed, before moving on.\n\n\n\n\nInstalling Node.js\n\n\n\n\nThis setup will go through how to install \nNode.js\n and the dependencies needed to create a Node application that can communicate with MATRIX CORE.\n\n\nRun the following commands on your MATRIX device(Raspberry Pi) to install \nNode Version Manager\n which will then be used to install version \n8.6\n of Node.js.\n\n\n\n\nIt is \nstrongly\n recommended to use version \n8.6\n of Node.js\n\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh \n|\n bash\n. ~/.bashrc\nnvm install \n8\n.6\n\n\n\n\n\n\n\nCreating A Node.js Application\n\n\nMaking Your Project Directory\n\nUse the following commands to initialize a Node project folder, in the home directory \n~/\n of your MATRIX device.\n\ncd\n ~/\nmkdir js-matrix-core-app\n\ncd\n js-matrix-core-app\nnpm init\n\n\n\nInstalling npm Packages for ZMQ and Protocol Buffers\n\n\n\nWhile staying inside your app folder, use the commands below to install the ZMQ and MATRIX Protocol Buffers npm packages. This allows you to interact with MATRIX Core through Node.js.\n\nnpm install zeromq --save\nnpm install matrix-protos --save\n\n\n\n\n\nCheck If Everything Works\n\n\nCreating app.js\n\nTo ensure your installation has succeeded, create a file named \napp.js\n and paste the code below.\n\n\n// Set Initial Variables \\\\\n\n\nvar\n \nzmq\n \n=\n \nrequire\n(\nzeromq\n);\n// Asynchronous Messaging Framework\n\n\nvar\n \nmatrix_io\n \n=\n \nrequire\n(\nmatrix-protos\n).\nmatrix_io\n;\n// Protocol Buffers for MATRIX function\n\n\nvar\n \nmatrix_ip\n \n=\n \n127.0.0.1\n;\n// Local IP\n\n\nvar\n \nmatrix_everloop_base_port\n \n=\n \n20021\n// Port for Everloop driver\n\n\nvar\n \nmatrix_device_leds\n \n=\n \n0\n;\n// Holds amount of LEDs on MATRIX device\n\n\n\n// ERROR PORT \\\\\n\n\nvar\n \nerrorSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n// Create a Subscriber socket\n\n\nerrorSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_everloop_base_port\n \n+\n \n2\n));\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nsubscribe\n(\n);\n// Subscribe to messages\n\n\n// On Message\n\n\nerrorSocket\n.\non\n(\nmessage\n,\n \n(\nerror_message\n)\n \n=\n \n{\n\n    \nconsole\n.\nlog\n(\nError received: \n \n+\n \nerror_message\n.\ntoString\n(\nutf8\n));\n// Log error\n\n\n});\n\n\n\n// DATA UPDATE PORT \\\\\n\n\nvar\n \nupdateSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n// Create a Subscriber socket\n\n\nupdateSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_everloop_base_port\n \n+\n \n3\n));\n// Connect Subscriber to Data Update port\n\n\nupdateSocket\n.\nsubscribe\n(\n);\n// Subscribe to messages\n\n\n// On Message\n\n\nupdateSocket\n.\non\n(\nmessage\n,\n \n(\nbuffer\n)\n \n=\n \n{\n\n    \nvar\n \ndata\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nio\n.\nEverloopImage\n.\ndecode\n(\nbuffer\n);\n// Extract message\n\n    \nmatrix_device_leds\n \n=\n \ndata\n.\neverloopLength\n;\n// Save MATRIX device LED count\n\n\n});\n\n\n\n// KEEP-ALIVE PORT \\\\\n\n\nvar\n \npingSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n// Create a Pusher socket\n\n\npingSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_everloop_base_port\n \n+\n \n1\n));\n// Connect Pusher to Keep-alive port\n\n\npingSocket\n.\nsend\n(\n);\n// Send a single ping\n\n\n\n// BASE PORT \\\\\n\n\nvar\n \nconfigSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n// Create a Pusher socket\n\n\nconfigSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \nmatrix_everloop_base_port\n);\n// Connect Pusher to Base port\n\n\n\n// Create an empty Everloop image\n\n\nvar\n \nimage\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nio\n.\nEverloopImage\n.\ncreate\n();\n\n\n\n// Loop every 50 milliseconds\n\n\nsetInterval\n(\nfunction\n(){\n\n    \n// For each device LED\n\n    \nfor\n \n(\nvar\n \ni\n \n=\n \n0\n;\n \ni\n \n \nmatrix_device_leds\n;\n \n++\ni\n)\n \n{\n\n        \n// Set individual LED value\n\n        \nimage\n.\nled\n[\ni\n]\n \n=\n \n{\n\n            \nred\n:\n \nMath\n.\nfloor\n(\nMath\n.\nrandom\n()\n \n*\n \n200\n)\n+\n1\n,\n\n            \ngreen\n:\n \nMath\n.\nfloor\n(\nMath\n.\nrandom\n()\n \n*\n \n255\n)\n+\n1\n,\n\n            \nblue\n:\n \nMath\n.\nfloor\n(\nMath\n.\nrandom\n()\n \n*\n \n50\n)\n+\n1\n,\n\n            \nwhite\n:\n \n0\n\n        \n};\n\n    \n}\n\n\n    \n// Store the Everloop image in MATRIX configuration\n\n    \nvar\n \nconfig\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\ncreate\n({\n\n        \nimage\n:\n \nimage\n\n    \n});\n\n\n    \n// Send MATRIX configuration to MATRIX device\n\n    \nif\n(\nmatrix_device_leds\n \n \n0\n)\n\n        \nconfigSocket\n.\nsend\n(\nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\nencode\n(\nconfig\n).\nfinish\n());\n\n\n},\n50\n);\n\n\n\n\n\nRunning app.js\n\n\n\nOnce you have the app.js code copied, use the following command to run a simple hello world app.\n\nnode app.js\n\n\n\nResult\n\n\n\n\nNext Steps\n\n\nNow that everything is properly installed, learn more about the Everloop and other \nDriver Protocols\n MATRIX Core has to offer, or view the available \nJavascript examples\n.", 
            "title": "Javascript Setup"
        }, 
        {
            "location": "/matrix-core/getting-started/javascript-installation/#installing-nodejs", 
            "text": "This setup will go through how to install  Node.js  and the dependencies needed to create a Node application that can communicate with MATRIX CORE.  Run the following commands on your MATRIX device(Raspberry Pi) to install  Node Version Manager  which will then be used to install version  8.6  of Node.js.   It is  strongly  recommended to use version  8.6  of Node.js curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh  |  bash\n. ~/.bashrc\nnvm install  8 .6", 
            "title": "Installing Node.js"
        }, 
        {
            "location": "/matrix-core/getting-started/javascript-installation/#creating-a-nodejs-application", 
            "text": "", 
            "title": "Creating A Node.js Application"
        }, 
        {
            "location": "/matrix-core/getting-started/javascript-installation/#check-if-everything-works", 
            "text": "", 
            "title": "Check If Everything Works"
        }, 
        {
            "location": "/matrix-core/getting-started/javascript-installation/#next-steps", 
            "text": "Now that everything is properly installed, learn more about the Everloop and other  Driver Protocols  MATRIX Core has to offer, or view the available  Javascript examples .", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-core/getting-started/python-installation/", 
            "text": "Ensure you have \nMATRIX CORE\n installed, before moving on.\n\n\n\n\nCreating A Python Project\n\n\n\n\nThis setup will go through how to install all the necessary python packages needed to program with MATRIX CORE.\n\n\nFirst, use the commands below to create a folder, inside in the home directory \n~/\n of your MATRIX device(Raspberry Pi). This will be where you'll put your python scripts.\n\ncd\n ~/\nmkdir python-matrix-core-app\n\ncd\n python-matrix-core-app\n\n\n\n\n\nInstalling Python Packages\n\n\nWhile inside your project directory, use the following commands to install all the necessary Python packages needed to interact with MATRIX CORE.\n\nwget \nhttps://github.com/matrix-io/matrix-creator-malos/blob/master/src/python_test/Pipfile\n -O Pipfile\nwget \nhttps://github.com/matrix-io/matrix-creator-malos/blob/master/src/python_test/Pipfile.lock\n -O Pipfile.lock\nwget \nhttps://raw.githubusercontent.com/matrix-io/matrix-creator-malos/master/src/python_test/requirements.txt\n -O requirements.txt \nwget \nhttps://raw.githubusercontent.com/matrix-io/matrix-creator-malos/master/src/python_test/utils.py\n -O utils.py \nsudo apt-get install build-essential python-dev\n\n\n\nPython 2 Packages\n\nRequired packages for Python 2 can be installed by using the following command.\n\npip install -r requirements.txt\n\n\n\nPython 3 Packages\n\nInstead of pip, Python 3 packages will require pip3 which can be installed with the command below.\n\nsudo apt-get install python3-pip\n\n\nYou can now install the required packages for Python 3.\n\npip3 install -r requirements.txt\n\n\n\n\n\nCheck If Everything Works\n\n\nCreating app.py\n\nTo ensure your installation has succeeded, create a file named \napp.py\n and paste the code below.\n\n\n## Set Initial Variables ##\n\n\nimport\n \nos\n \n# Miscellaneous operating system interface\n\n\nimport\n \nzmq\n \n# Asynchronous messaging framework\n\n\nimport\n \ntime\n \n# Time access and conversions\n\n\nfrom\n \nrandom\n \nimport\n \nrandint\n \n# Random numbers\n\n\nimport\n \nsys\n \n# System-specific parameters and functions\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \ndriver_pb2\n \n# MATRIX Protocol Buffer driver library\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \nio_pb2\n \n# MATRIX Protocol Buffer sensor library\n\n\nfrom\n \nmultiprocessing\n \nimport\n \nProcess\n,\n \nManager\n,\n \nValue\n \n# Allow for multiple processes at once\n\n\nfrom\n \nzmq.eventloop\n \nimport\n \nioloop\n,\n \nzmqstream\n# Asynchronous events through ZMQ\n\n\nmatrix_ip\n \n=\n \n127.0.0.1\n \n# Local device ip\n\n\neverloop_port\n \n=\n \n20021\n \n# Driver Base port\n\n\nled_count\n \n=\n \n0\n \n# Amount of LEDs on MATRIX device\n\n\n# Handy function for connecting to the Error port \n\n\nfrom\n \nutils\n \nimport\n \nregister_error_callback\n\n\n\n## BASE PORT ##\n\n\ndef\n \nconfig_socket\n(\nledCount\n):\n  \n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Pusher socket\n\n    \nsocket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n    \n# Connect Pusher to configuration socket\n\n    \nsocket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \neverloop_port\n))\n\n\n    \n# Loop forever\n\n    \nwhile\n \nTrue\n:\n\n        \n# Create a new driver config\n\n        \ndriver_config_proto\n \n=\n \ndriver_pb2\n.\nDriverConfig\n()\n\n        \n# Create an empty Everloop image\n\n        \nimage\n \n=\n \n[]\n\n        \n# For each device LED\n\n        \nfor\n \nled\n \nin\n \nrange\n(\nledCount\n):\n\n            \n# Set individual LED value\n\n            \nledValue\n \n=\n \nio_pb2\n.\nLedValue\n()\n\n            \nledValue\n.\nblue\n \n=\n \nrandint\n(\n0\n,\n \n50\n)\n\n            \nledValue\n.\nred\n \n=\n \nrandint\n(\n0\n,\n \n200\n)\n\n            \nledValue\n.\ngreen\n \n=\n \nrandint\n(\n0\n,\n \n255\n)\n\n            \nledValue\n.\nwhite\n \n=\n \n0\n\n            \nimage\n.\nappend\n(\nledValue\n)\n\n        \n# Store the Everloop image in driver configuration\n\n        \ndriver_config_proto\n.\nimage\n.\nled\n.\nextend\n(\nimage\n)\n\n\n        \n# Send driver configuration through ZMQ socket\n\n        \nsocket\n.\nsend\n(\ndriver_config_proto\n.\nSerializeToString\n())\n\n        \n#Wait before restarting loop\n\n        \ntime\n.\nsleep\n(\n0.05\n)\n\n\n\n## KEEP ALIVE ##\n\n\ndef\n \nping_socket\n():\n\n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Pusher socket\n\n    \nping_socket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n    \n# Connect to the socket\n\n    \nping_socket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \neverloop_port\n+\n1\n))\n\n    \n# Ping with empty string to let the drive know we\nre still listening\n\n    \nping_socket\n.\nsend_string\n(\n)\n\n\n\n## ERROR PORT ##\n\n\ndef\n \neverloop_error_callback\n(\nerror\n):\n\n    \n# Log error\n\n    \nprint\n(\n{0}\n.\nformat\n(\nerror\n))\n\n\n\n## DATA UPDATE PORT ##\n\n\ndef\n \nupdate_socket\n():\n\n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Subscriber socket\n\n    \nsocket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nSUB\n)\n\n    \n# Connect to the Data Update port\n\n    \nsocket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \neverloop_port\n+\n3\n))\n\n    \n# Connect Subscriber to Error port\n\n    \nsocket\n.\nsetsockopt\n(\nzmq\n.\nSUBSCRIBE\n,\n \nb\n)\n\n    \n# Create the stream to listen to data from port\n\n    \nstream\n \n=\n \nzmqstream\n.\nZMQStream\n(\nsocket\n)\n\n\n    \n# Function to update LED count and close connection to the Data Update Port\n\n    \ndef\n \nupdateLedCount\n(\ndata\n):\n\n        \n# Extract data and pass into led_count global variable\n\n        \nglobal\n \nled_count\n\n        \nled_count\n \n=\n \nio_pb2\n.\nLedValue\n()\n.\nFromString\n(\ndata\n[\n0\n])\n.\ngreen\n\n        \n# Log LEDs\n\n        \nprint\n(\n{0} LEDs counted\n.\nformat\n(\nled_count\n))\n\n        \n# If LED count obtained\n\n        \nif\n \nled_count\n \n \n0\n:\n\n            \n# Close Data Update Port connection\n\n            \nioloop\n.\nIOLoop\n.\ninstance\n()\n.\nstop\n()\n\n            \nprint\n(\nLED count obtained. Disconnecting from data publisher {0}\n.\nformat\n(\neverloop_port\n+\n3\n))\n\n    \n# Call updateLedCount() once data is received\n\n    \nstream\n.\non_recv\n(\nupdateLedCount\n)\n\n\n    \n# Log and begin event loop for ZMQ connection to Data Update Port\n\n    \nprint\n(\nConnected to data publisher with port {0}\n.\nformat\n(\neverloop_port\n+\n3\n))\n\n    \nioloop\n.\nIOLoop\n.\ninstance\n()\n.\nstart\n()\n\n\n\n## START  PROCESSES ##\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \n# Initiate asynchronous events\n\n    \nioloop\n.\ninstall\n()\n\n    \n# Start Error Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_error_callback\n,\n \nargs\n=\n(\neverloop_error_callback\n,\n \nmatrix_ip\n,\n \neverloop_port\n))\n.\nstart\n()\n    \n\n    \n# Ping the Keep-alive Port once\n\n    \nping_socket\n()\n\n    \n# Start Data Update Port connection \n close after response\n\n    \nupdate_socket\n()\n\n    \n# Send Base Port configuration\n\n    \ntry\n:\n\n        \nconfig_socket\n(\nled_count\n)\n\n    \n# Avoid logging Everloop errors on user quiting\n\n    \nexcept\n \nKeyboardInterrupt\n:\n\n        \nprint\n(\n quit\n)\n\n\n\n\n\nRunning app.py\n\n\n\nOnce you have the app.py code copied, use one of the following commands to run a simple hello world app.\n\n\nPython 2\n\n\n\npython app.py\n\n\n\nPython 3\n\n\npython3 app.py\n\n\n\nResult\n\n\n\n\nNext Steps\n\n\nNow that everything is properly installed, learn more about the Everloop and other \nDriver Protocols\n MATRIX Core has to offer, or view the available \nPython examples\n.", 
            "title": "Python Setup"
        }, 
        {
            "location": "/matrix-core/getting-started/python-installation/#creating-a-python-project", 
            "text": "This setup will go through how to install all the necessary python packages needed to program with MATRIX CORE.  First, use the commands below to create a folder, inside in the home directory  ~/  of your MATRIX device(Raspberry Pi). This will be where you'll put your python scripts. cd  ~/\nmkdir python-matrix-core-app cd  python-matrix-core-app", 
            "title": "Creating A Python Project"
        }, 
        {
            "location": "/matrix-core/getting-started/python-installation/#installing-python-packages", 
            "text": "While inside your project directory, use the following commands to install all the necessary Python packages needed to interact with MATRIX CORE. wget  https://github.com/matrix-io/matrix-creator-malos/blob/master/src/python_test/Pipfile  -O Pipfile\nwget  https://github.com/matrix-io/matrix-creator-malos/blob/master/src/python_test/Pipfile.lock  -O Pipfile.lock\nwget  https://raw.githubusercontent.com/matrix-io/matrix-creator-malos/master/src/python_test/requirements.txt  -O requirements.txt \nwget  https://raw.githubusercontent.com/matrix-io/matrix-creator-malos/master/src/python_test/utils.py  -O utils.py \nsudo apt-get install build-essential python-dev", 
            "title": "Installing Python Packages"
        }, 
        {
            "location": "/matrix-core/getting-started/python-installation/#check-if-everything-works", 
            "text": "", 
            "title": "Check If Everything Works"
        }, 
        {
            "location": "/matrix-core/getting-started/python-installation/#next-steps", 
            "text": "Now that everything is properly installed, learn more about the Everloop and other  Driver Protocols  MATRIX Core has to offer, or view the available  Python examples .", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-core/getting-started/golang-installation/", 
            "text": "Ensure you have \nMATRIX CORE\n installed, before moving on.\n\n\n\n\nInstalling Golang\n\n\n\n\nThis setup will go through how to install \nGolang\n and the dependencies needed to create a Go application that can communicate with MATRIX CORE. Run the following on your Raspberry Pi.\n\n\nBefore downloading Go, you'll need to make sure you have \ngit\n installed.\n\nsudo apt-get install git\n\n\n\nDownload and install \nGo v1.11.2\n.\n\nwget https://dl.google.com/go/go1.11.2.linux-armv6l.tar.gz\nsudo tar -C /usr/local -xvzf go1.11.2.linux-armv6l.tar.gz\nrm go1.11.2.linux-armv6l.tar.gz\n\n\n\nSetup the \nGOPATH\n directory and environment variables.\n\nmkdir -p ~/go/\n{\nbin,src,pkg\n}\n\n\necho\n -e \n\\n##Golang Environment Variables##\n \n|\n sudo tee -a /etc/profile\n\necho\n \nexport PATH=$PATH:/usr/local/go/bin\n \n|\n sudo tee -a /etc/profile\n\necho\n \nexport GOPATH=$HOME/go\n \n|\n sudo tee -a /etc/profile\n\necho\n \nexport PATH=$PATH:$GOPATH/bin\n \n|\n sudo tee -a /etc/profile\n\nsource\n /etc/profile\n\n\n\nMake sure Go is properly installed. The command below should output \ngo version go1.11 linux/arm\n.\n\ngo version\n\n\n\n\n\nInstalling ZMQ Dependency\n\n\nAlthough ZMQ has already been installed, Go requires an extra dependency.\n\nsudo apt-get install libsodium-dev\n\n\n\n\n\nCreating A Go Application\n\n\nMaking Your Project Directory\n\nUse the following commands to initialize a Go project folder, in the home directory \n~/\n of your MATRIX device.\n\ncd\n ~/\nmkdir go-matrix-core-app\n\ncd\n go-matrix-core-app\ngo mod init go-matrix-core-app\n\n\n\nInstalling Go Packages for ZMQ and Protocol Buffers\n\n\n\nWhile inside your project folder, use the commands below to install the required dependencies for interacting with MATRIX CORE.\n\ngo get github.com/pebbe/zmq4\ngo get github.com/matrix-io/matrix-protos-go\n\n\n\n\n\nCheck If Everything Works\n\n\nCreating main.go\n\nTo ensure your installation has succeeded, create a file named \nmain.go\n and paste the code below.\n\n\npackage\n \nmain\n\n\n\nimport\n \n(\n\n    \nfmt\n\n    \nmath/rand\n\n    \ntime\n\n\n    \ngithub.com/golang/protobuf/proto\n\n    \ncore\n \ngithub.com/matrix-io/matrix-protos-go/matrix_io/malos/v1\n\n    \nzmq\n \ngithub.com/pebbe/zmq4\n\n\n)\n\n\n\n// Global Vars\n\n\nvar\n \nportStatus\n \n=\n \nmake\n(\nchan\n \nstring\n,\n \n4\n)\n \n// Channel To Ensure Port Goroutines Are Called\n\n\nvar\n \neverloop\n \n=\n \ncore\n.\nEverloopImage\n{}\n   \n// State Of All MATRIX LEDs\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nStarting MATRIX CORE Everloop\n)\n\n\n    \n// Asynchronously Start MATRIX CORE Ports\n\n    \ngo\n \nkeepAlivePort\n()\n  \n// Ping Once\n\n    \ngo\n \nerrorPort\n()\n      \n// Report Any Errors\n\n    \ngo\n \ndataUpdatePort\n()\n \n// Receive # Of Leds \n Starts basePort()\n\n\n    \n// Wait For Each Port Connection (ensures each goroutine is able to run)\n\n    \nfor\n \nportStatus\n \n:=\n \nrange\n \nportStatus\n \n{\n\n        \nfmt\n.\nPrintln\n(\nreceived\n,\n \nportStatus\n)\n\n    \n}\n\n\n}\n\n\n\n// BASE PORT \\\\ (port where configurations are sent)\n\n\nfunc\n \nbasePort\n()\n \n{\n\n    \n// Connect ZMQ Socket To MATRIX CORE\n\n    \npusher\n,\n \n_\n \n:=\n \nzmq\n.\nNewSocket\n(\nzmq\n.\nPUSH\n)\n    \n// Create A Pusher Socket\n\n    \npusher\n.\nConnect\n(\ntcp://127.0.0.1:20021\n)\n \n// Connect Pusher To Base Port\n\n\n    \n// Notify That Port Is Ready\n\n    \nportStatus\n \n-\n \nBase Port: CONNECTED\n\n\n    \n// Keep Sending Everloop Image\n\n    \nfor\n \n{\n\n        \n// Create (x) Amount Of Randomly Colored LEDs\n\n        \nfor\n \ni\n \n:=\n \nint32\n(\n0\n);\n \ni\n \n \neverloop\n.\nEverloopLength\n;\n \ni\n++\n \n{\n\n            \nled\n \n:=\n \ncore\n.\nLedValue\n{\n\n                \nRed\n:\n   \n(\nuint32\n)(\nrand\n.\nInt31n\n(\n200\n)\n \n+\n \n1\n),\n\n                \nGreen\n:\n \n(\nuint32\n)(\nrand\n.\nInt31n\n(\n255\n)\n \n+\n \n1\n),\n\n                \nBlue\n:\n  \n(\nuint32\n)(\nrand\n.\nInt31n\n(\n50\n)\n \n+\n \n1\n),\n\n                \nWhite\n:\n \n0\n,\n\n            \n}\n\n            \n// Add New LED to Everloop LED Array\n\n            \neverloop\n.\nLed\n \n=\n \nappend\n(\neverloop\n.\nLed\n,\n \nled\n)\n\n        \n}\n\n\n        \n// Create Everloop Driver Configuration Protocol\n\n        \nconfiguration\n \n:=\n \ncore\n.\nDriverConfig\n{\n\n            \nImage\n:\n \neverloop\n,\n\n        \n}\n\n        \n//Encode Protocol Buffer\n\n        \nvar\n \nencodedConfiguration\n,\n \n_\n \n=\n \nproto\n.\nMarshal\n(\nconfiguration\n)\n\n        \n// Send Protocol Buffer\n\n        \npusher\n.\nSend\n(\nstring\n((\nencodedConfiguration\n)),\n \n1\n)\n\n\n        \n// Reset Everloop Array\n\n        \neverloop\n.\nLed\n \n=\n \n[]\n*\ncore\n.\nLedValue\n{}\n\n        \n// Loop delay\n\n        \ntime\n.\nSleep\n(\n50\n \n*\n \ntime\n.\nMillisecond\n)\n\n    \n}\n\n\n}\n\n\n\n// KEEP-ALIVE PORT \\\\ (port where pings are sent)\n\n\nfunc\n \nkeepAlivePort\n()\n \n{\n\n    \n// Connect ZMQ Socket To MATRIX CORE\n\n    \npusher\n,\n \n_\n \n:=\n \nzmq\n.\nNewSocket\n(\nzmq\n.\nPUSH\n)\n    \n// Create A Pusher Socket\n\n    \npusher\n.\nConnect\n(\ntcp://127.0.0.1:20022\n)\n \n// Connect Pusher To Keep-Alive Port\n\n\n    \n// Notify That Port Is Ready\n\n    \nportStatus\n \n-\n \nKeep-Alive Port: CONNECTED\n\n\n    \n// Send Keep Alive Message\n\n    \npusher\n.\nSend\n(\n,\n \n1\n)\n\n\n}\n\n\n\n// ERROR PORT \\\\ (port where errors are received)\n\n\nfunc\n \nerrorPort\n()\n \n{\n\n    \n// Connect ZMQ Socket To MATRIX CORE\n\n    \nsubscriber\n,\n \n_\n \n:=\n \nzmq\n.\nNewSocket\n(\nzmq\n.\nSUB\n)\n     \n// Create A Subscriber Socket\n\n    \nsubscriber\n.\nConnect\n(\ntcp://127.0.0.1:20023\n)\n \n// Connect Subscriber To Data Update Port\n\n    \nsubscriber\n.\nSetSubscribe\n(\n)\n                 \n// Subscribe To Error Port Messages\n\n\n    \n// Notify That Port Is Ready\n\n    \nportStatus\n \n-\n \nError Port: CONNECTED\n\n\n    \n// Wait For Error\n\n    \nfor\n \n{\n\n        \n// On Error\n\n        \nmessage\n,\n \n_\n \n:=\n \nsubscriber\n.\nRecv\n(\n2\n)\n\n        \n// Print Error\n\n        \nfmt\n.\nPrintln\n(\nERROR:\n,\n \nmessage\n)\n\n    \n}\n\n\n}\n\n\n\n// DATA UPDATE PORT \\\\ (port where updates are received)\n\n\nfunc\n \ndataUpdatePort\n()\n \n{\n\n    \n// Connect ZMQ Socket To MATRIX CORE\n\n    \nsubscriber\n,\n \n_\n \n:=\n \nzmq\n.\nNewSocket\n(\nzmq\n.\nSUB\n)\n     \n// Create A Subscriber Socket\n\n    \nsubscriber\n.\nConnect\n(\ntcp://127.0.0.1:20024\n)\n \n// Connect Subscriber To Data Update Port\n\n    \nsubscriber\n.\nSetSubscribe\n(\n)\n                 \n// Subscribe To Data Update Port Messages\n\n\n    \n// Notify That Port Is Ready\n\n    \nportStatus\n \n-\n \nData Update Port: CONNECTED\n\n\n    \n// Wait For Data\n\n    \nfor\n \n{\n\n        \n// On Data\n\n        \nmessage\n,\n \n_\n \n:=\n \nsubscriber\n.\nRecv\n(\n2\n)\n\n        \n// Decode Protocol Buffer \n Update everloop Struct LED Count\n\n        \nproto\n.\nUnmarshal\n([]\nbyte\n(\nmessage\n),\n \neverloop\n)\n\n        \n// Print Data\n\n        \nfmt\n.\nPrint\n(\n\\nEverloop Length: \n,\n \neverloop\n.\nEverloopLength\n,\n \n\\n\\n\n)\n\n\n        \n// Start Base Port\n\n        \ngo\n \nbasePort\n()\n \n// Send Configuration Message\n\n\n        \n// Close Data Update Port\n\n        \nreturn\n\n    \n}\n\n\n}\n\n\n\n\n\nRunning main.go\n\n\n\nOnce you have main.go ready, use the following command to run a simple hello world app.\n\ngo run main.go\n\n\n\nResult\n\n\n\n\nNext Steps\n\n\nNow that everything is properly installed, learn more about the Everloop and other \nDriver Protocols\n MATRIX Core has to offer. \nGo examples coming soon!", 
            "title": "Golang Setup"
        }, 
        {
            "location": "/matrix-core/getting-started/golang-installation/#installing-golang", 
            "text": "This setup will go through how to install  Golang  and the dependencies needed to create a Go application that can communicate with MATRIX CORE. Run the following on your Raspberry Pi.  Before downloading Go, you'll need to make sure you have  git  installed. sudo apt-get install git  Download and install  Go v1.11.2 . wget https://dl.google.com/go/go1.11.2.linux-armv6l.tar.gz\nsudo tar -C /usr/local -xvzf go1.11.2.linux-armv6l.tar.gz\nrm go1.11.2.linux-armv6l.tar.gz  Setup the  GOPATH  directory and environment variables. mkdir -p ~/go/ { bin,src,pkg }  echo  -e  \\n##Golang Environment Variables##   |  sudo tee -a /etc/profile echo   export PATH=$PATH:/usr/local/go/bin   |  sudo tee -a /etc/profile echo   export GOPATH=$HOME/go   |  sudo tee -a /etc/profile echo   export PATH=$PATH:$GOPATH/bin   |  sudo tee -a /etc/profile source  /etc/profile  Make sure Go is properly installed. The command below should output  go version go1.11 linux/arm . go version", 
            "title": "Installing Golang"
        }, 
        {
            "location": "/matrix-core/getting-started/golang-installation/#installing-zmq-dependency", 
            "text": "Although ZMQ has already been installed, Go requires an extra dependency. sudo apt-get install libsodium-dev", 
            "title": "Installing ZMQ Dependency"
        }, 
        {
            "location": "/matrix-core/getting-started/golang-installation/#creating-a-go-application", 
            "text": "", 
            "title": "Creating A Go Application"
        }, 
        {
            "location": "/matrix-core/getting-started/golang-installation/#check-if-everything-works", 
            "text": "", 
            "title": "Check If Everything Works"
        }, 
        {
            "location": "/matrix-core/getting-started/golang-installation/#next-steps", 
            "text": "Now that everything is properly installed, learn more about the Everloop and other  Driver Protocols  MATRIX Core has to offer.  Go examples coming soon!", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-core/protocols/", 
            "text": "Driver Protocols\n\n\nEverloop\n\nLED interface.\n\n\nHumidity\n\n\n\nHumidity and temperature measurement.\n\n\nIMU\n\n\n\nInertial Measurement Unit.\n\n\nPressure\n\n\n\nPressure, altitude and temperature measurement.\n\n\nUV\n\n\n\nUltraviolet light sensor.\n\n\nServo\n\n\n\nAdjust servo positions.\n\n\nGPIO\n\n\n\nGeneral Purpose Input/Output.\n\n\nWakeword\n\n\n\nCreate custom voice commands with Pocket Sphinx.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-core/protocols/#driver-protocols", 
            "text": "", 
            "title": "Driver Protocols"
        }, 
        {
            "location": "/matrix-core/protocols/everloop/", 
            "text": "Everloop\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe Everloop driver allows for:\n\n\n\n\nReading amount of LEDs your MATRIX device has.\n\n\nSetting the RGBW colors for each individual LED.\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20021\n\n\nKeep-alive port\n: 20022\n\n\nError port\n: 20023\n\n\nData update port\n: 20024\n\n\n\n\nProtocol\n\n\n\n\n\nBase Port\nThis port accepts a single configuration for communicating with the Everloop driver. \n\n\n\n\nimage\n - the everloop configuration that's created from an \nEverloopImage\n message.\n\n\n\n\nmessage\n \nDriverConfig\n \n{\n\n\nmatrix_io.malos.v1.io.EverloopImage\n \nimage\n \n=\n \n3\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.\n\n\nEverloopImage\n \n\n\n\n\nled\n - Must hold the value for each LED on your MATRIX device. Each LED is defined as one \nLedValue\n.\n\n\n\n\n// Value for an led that ranges from 0 to 255 for each color\n\n\nmessage\n \nLedValue\n \n{\n\n\nuint32\n \nred\n \n=\n \n1\n;\n\n\nuint32\n \ngreen\n \n=\n \n2\n;\n\n\nuint32\n \nblue\n \n=\n \n3\n;\n\n\nuint32\n \nwhite\n \n=\n \n4\n;\n\n\n}\n\n\n\n// The led array.\n\n\nmessage\n \nEverloopImage\n \n{\n\n\nrepeated\n \nLedValue\n \nled\n \n=\n \n1\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.\n\n\n\n\n\n\n\nKeep-alive Port\nThis driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string \n\"\"\n because the contents of a keep-alive message are never read.\n\n\n\n\n\n\n\nError Port\nApplications can subscribe to this port to receive driver related errors.\n\n\n\n\n\n\n\nData Update Port\nApplications can subscribe to this port for Everloop data. The output will be a serialized message of type \nEverloopImage\n with the following information.\n\n\n// The led array.\n\n\nmessage\n \nEverloopImage\n \n{\n\n\nrepeated\n \nLedValue\n \nled\n \n=\n \n1\n;\n\n\n\n// Number of leds in the Everloop\n\n\nint32\n \neverloop_length\n \n=\n \n2\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-core/protocols/everloop/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/protocols/everloop/#overview", 
            "text": "The Everloop driver allows for:   Reading amount of LEDs your MATRIX device has.  Setting the RGBW colors for each individual LED.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/protocols/everloop/#protocol", 
            "text": "Base Port This port accepts a single configuration for communicating with the Everloop driver.    image  - the everloop configuration that's created from an  EverloopImage  message.   message   DriverConfig   {  matrix_io.malos.v1.io.EverloopImage   image   =   3 ;  }  \nView the defined message  here .  EverloopImage     led  - Must hold the value for each LED on your MATRIX device. Each LED is defined as one  LedValue .   // Value for an led that ranges from 0 to 255 for each color  message   LedValue   {  uint32   red   =   1 ;  uint32   green   =   2 ;  uint32   blue   =   3 ;  uint32   white   =   4 ;  }  // The led array.  message   EverloopImage   {  repeated   LedValue   led   =   1 ;  }  \nView the defined message  here .    Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string  \"\"  because the contents of a keep-alive message are never read.    Error Port Applications can subscribe to this port to receive driver related errors.    Data Update Port Applications can subscribe to this port for Everloop data. The output will be a serialized message of type  EverloopImage  with the following information.  // The led array.  message   EverloopImage   {  repeated   LedValue   led   =   1 ;  // Number of leds in the Everloop  int32   everloop_length   =   2 ;  }  \nView the defined message  here .", 
            "title": "Protocol"
        }, 
        {
            "location": "/matrix-core/protocols/humidity/", 
            "text": "Humidity\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe Humidity driver allows for:\n\n\n\n\nReading relative humidity on the board\n\n\nObtaining temperature in Celsius and raw values\n\n\nCalibrating temperature\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20017\n\n\nKeep-alive port\n: 20018\n\n\nError port\n: 20019\n\n\nData update port\n: 20020\n\n\n\n\nProtocol\n\n\n\n\n\nBase Port\nThis port accepts three configurations for communicating with the Humidity driver. \n\n\n\n\n\n\ndelay_between_updates\n - controls the output speed of messages from the \nData Update port\n. \n\n\n\n\n\n\ntimeout_after_last_ping\n - stops sending messages from the \nData Update port\n if nothing has been sent to the \nKeep-alive port\n after the specified amount of seconds.\n\n\n\n\n\n\nhumidity\n - the humidity configuration that's created from a \nHumidityParams\n message.\n\n\n\n\n\n\nmessage\n \nDriverConfig\n \n{\n\n\n// Delay between updates in seconds\n\n\nfloat\n \ndelay_between_updates\n \n=\n \n1\n;\n\n\n// Timeout after last ping\n\n\nfloat\n \ntimeout_after_last_ping\n \n=\n \n2\n;\n\n\n// Humidity configuration\n\n\nmatrix_io.malos.v1.sense.HumidityParams\n \nhumidity\n \n=\n \n9\n;\n\n\n\nView the defined message \nhere\n.\n\n\nHumidityParams\n\n\n\n\ncurrent_temperature\n - a reference of the current temperature for calibration.\n\n\n\n\nmessage\n \nHumidityParams\n{\n\n\n// Current temperature Celsius used for calibration.\n\n\nfloat\n \ncurrent_temperature\n \n=\n \n1\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.\n\n\n\n\n\n\n\nKeep-alive Port\nThis driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string \n\"\"\n because the contents of a keep-alive message are never read.\n\n\n\n\n\n\n\nError Port\nApplications can subscribe to this port to receive driver related errors.\n\n\n\n\n\n\n\nData Update Port\nApplications can subscribe to this port for humidity data. The output will be a serialized message of type \nHumidity\n with the following information.\n\n\nmessage\n \nHumidity\n \n{\n\n\n// Humidity\n\n\nfloat\n \nhumidity\n \n=\n \n1\n;\n\n\n\n// Temperature\n\n\nfloat\n \ntemperature\n \n=\n \n2\n;\n\n\n\n// Raw temperature value from the sensor\n\n\nfloat\n \ntemperature_raw\n \n=\n \n3\n;\n\n\n\n//  Flag that tells if the temperature is calibrated\n\n\nbool\n \ntemperature_is_calibrated\n \n=\n \n4\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-core/protocols/humidity/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/protocols/humidity/#overview", 
            "text": "The Humidity driver allows for:   Reading relative humidity on the board  Obtaining temperature in Celsius and raw values  Calibrating temperature", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/protocols/humidity/#protocol", 
            "text": "Base Port This port accepts three configurations for communicating with the Humidity driver.     delay_between_updates  - controls the output speed of messages from the  Data Update port .     timeout_after_last_ping  - stops sending messages from the  Data Update port  if nothing has been sent to the  Keep-alive port  after the specified amount of seconds.    humidity  - the humidity configuration that's created from a  HumidityParams  message.    message   DriverConfig   {  // Delay between updates in seconds  float   delay_between_updates   =   1 ;  // Timeout after last ping  float   timeout_after_last_ping   =   2 ;  // Humidity configuration  matrix_io.malos.v1.sense.HumidityParams   humidity   =   9 ;  \nView the defined message  here .  HumidityParams   current_temperature  - a reference of the current temperature for calibration.   message   HumidityParams {  // Current temperature Celsius used for calibration.  float   current_temperature   =   1 ;  }  \nView the defined message  here .    Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string  \"\"  because the contents of a keep-alive message are never read.    Error Port Applications can subscribe to this port to receive driver related errors.    Data Update Port Applications can subscribe to this port for humidity data. The output will be a serialized message of type  Humidity  with the following information.  message   Humidity   {  // Humidity  float   humidity   =   1 ;  // Temperature  float   temperature   =   2 ;  // Raw temperature value from the sensor  float   temperature_raw   =   3 ;  //  Flag that tells if the temperature is calibrated  bool   temperature_is_calibrated   =   4 ;  }  \nView the defined message  here .", 
            "title": "Protocol"
        }, 
        {
            "location": "/matrix-core/protocols/imu/", 
            "text": "Inertial Measurement Unit (IMU)\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe IMU driver reports values for:\n\n\n\n\nYaw, Pitch, and Roll\n\n\nAcceleration for \nx\n, \ny\n, \nz\n axes\n\n\nGyroscope for \nx\n, \ny\n, \nz\n axes\n\n\nMagnetometer for \nx\n, \ny\n, \nz\n axes\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20013\n\n\nKeep-alive port\n: 20014\n\n\nError port\n: 20015\n\n\nData Update port\n: 20016\n\n\n\n\nBase Port\nThis port accepts 2 configurations for communicating with the IMU driver. \n\n\n\n\n\n\ndelay_between_updates\n - controls the output speed of messages from the \nData Update port\n. \n\n\n\n\n\n\ntimeout_after_last_ping\n - stops sending messages from the \nData Update port\n if nothing has been sent to the \nKeep-alive port\n after the specified amount of seconds.\n\n\n\n\n\n\nmessage\n \nDriverConfig\n \n{\n\n\n// Delay between updates in seconds\n\n\nfloat\n \ndelay_between_updates\n \n=\n \n1\n;\n\n\n// Timeout after last ping\n\n\nfloat\n \ntimeout_after_last_ping\n \n=\n \n2\n;\n\n\n\nView the defined message \nhere\n.\n\n\n\n\n\n\n\nKeep-alive Port\nThis driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string \n\"\"\n because the contents of a keep-alive message are never read.\n\n\n\n\n\n\n\nError Port\nApplications can subscribe to this port to receive driver related errors.\n\n\n\n\n\n\n\nData Update Port\nApplications can subscribe to this port for IMU data. The output will be a serialized message of type \nImu\n with the following information.\n\nmessage\n \nImu\n \n{\n\n\n//Vertical axis (yaw)\n\n\nfloat\n \nyaw\n \n=\n \n1\n;\n\n\n\n//Lateral axis (pitch)\n\n\nfloat\n \npitch\n \n=\n \n2\n;\n\n\n\n//Longitudinal axis (roll)\n\n\nfloat\n \nroll\n \n=\n \n3\n;\n\n\n\n// Acceleration\n\n\nfloat\n \naccel_x\n \n=\n \n4\n;\n\n\nfloat\n \naccel_y\n \n=\n \n5\n;\n\n\nfloat\n \naccel_z\n \n=\n \n6\n;\n\n\n\n// Gyroscope\n\n\nfloat\n \ngyro_x\n \n=\n \n7\n;\n\n\nfloat\n \ngyro_y\n \n=\n \n8\n;\n\n\nfloat\n \ngyro_z\n \n=\n \n9\n;\n\n\n\n// Magnetometer\n\n\nfloat\n \nmag_x\n \n=\n \n10\n;\n\n\nfloat\n \nmag_y\n \n=\n \n11\n;\n\n\nfloat\n \nmag_z\n \n=\n \n12\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.", 
            "title": "IMU"
        }, 
        {
            "location": "/matrix-core/protocols/imu/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/protocols/imu/#overview", 
            "text": "The IMU driver reports values for:   Yaw, Pitch, and Roll  Acceleration for  x ,  y ,  z  axes  Gyroscope for  x ,  y ,  z  axes  Magnetometer for  x ,  y ,  z  axes", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/protocols/pressure/", 
            "text": "Pressure\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe Pressure driver reports values for:\n\n\n\n\nPressure\n\n\nAltitude\n\n\nTemperature\n\n\n\n\n\n\nBased on component location, the temperature values from the \nHumidity driver\n are recommended over the Pressure driver\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20025\n\n\nKeep-alive port\n: 20026\n\n\nError port\n: 20027\n\n\nData Update port\n: 20028\n\n\n\n\nProtocol\n\n\n\n\n\nBase Port\nThis port accepts 2 configurations for communicating with the Pressure driver. \n\n\n\n\n\n\ndelay_between_updates\n - controls the output speed of messages from the \nData Update port\n. \n\n\n\n\n\n\ntimeout_after_last_ping\n - stops sending messages from the \nData Update port\n if nothing has been sent to the \nKeep-alive port\n after the specified amount of seconds.\n\n\n\n\n\n\nmessage\n \nDriverConfig\n \n{\n\n\n// Delay between updates in seconds\n\n\nfloat\n \ndelay_between_updates\n \n=\n \n1\n;\n\n\n// Timeout after last ping\n\n\nfloat\n \ntimeout_after_last_ping\n \n=\n \n2\n;\n\n\n\nView the defined message \nhere\n.\n\n\n\n\n\n\n\nKeep-alive Port\nThis driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string \n\"\"\n because the contents of a keep-alive message are never read.\n\n\n\n\n\n\n\nError Port\nApplications can subscribe to this port to receive driver related errors.\n\n\n\n\n\n\n\nData Update Port\nApplications can subscribe to this port for pressure data. The output will be a serialized message of type \nPressure\n with the following information.\n\nmessage\n \nPressure\n \n{\n\n\n// Pressure\n\n\nfloat\n \npressure\n \n=\n \n1\n;\n\n\n\n// Altimeter\n\n\nfloat\n \naltitude\n \n=\n \n2\n;\n\n\n\n// Temperature\n\n\nfloat\n \ntemperature\n \n=\n \n3\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-core/protocols/pressure/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/protocols/pressure/#overview", 
            "text": "The Pressure driver reports values for:   Pressure  Altitude  Temperature    Based on component location, the temperature values from the  Humidity driver  are recommended over the Pressure driver", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/protocols/pressure/#protocol", 
            "text": "Base Port This port accepts 2 configurations for communicating with the Pressure driver.     delay_between_updates  - controls the output speed of messages from the  Data Update port .     timeout_after_last_ping  - stops sending messages from the  Data Update port  if nothing has been sent to the  Keep-alive port  after the specified amount of seconds.    message   DriverConfig   {  // Delay between updates in seconds  float   delay_between_updates   =   1 ;  // Timeout after last ping  float   timeout_after_last_ping   =   2 ;  \nView the defined message  here .    Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string  \"\"  because the contents of a keep-alive message are never read.    Error Port Applications can subscribe to this port to receive driver related errors.    Data Update Port Applications can subscribe to this port for pressure data. The output will be a serialized message of type  Pressure  with the following information. message   Pressure   {  // Pressure  float   pressure   =   1 ;  // Altimeter  float   altitude   =   2 ;  // Temperature  float   temperature   =   3 ;  }  \nView the defined message  here .", 
            "title": "Protocol"
        }, 
        {
            "location": "/matrix-core/protocols/uv/", 
            "text": "UV\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe UV driver reports values for:\n\n\n\n\nUV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization.  From \nUV Index Scale\n\n\nUV Risk scale established by World Health Organization. From \nUV Index Scale\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20029\n\n\nKeep-alive port\n: 20030\n\n\nError port\n: 20031\n\n\nData Update port\n: 20032\n\n\n\n\nBase Port\nThis port accepts 2 configurations for communicating with the UV driver. \n\n\n\n\n\n\ndelay_between_updates\n - controls the output speed of messages from the \nData Update port\n. \n\n\n\n\n\n\ntimeout_after_last_ping\n - stops sending messages from the \nData Update port\n if nothing has been sent to the \nKeep-alive port\n after the specified amount of seconds.\n\n\n\n\n\n\nmessage\n \nDriverConfig\n \n{\n\n\n// Delay between updates in seconds\n\n\nfloat\n \ndelay_between_updates\n \n=\n \n1\n;\n\n\n// Timeout after last ping\n\n\nfloat\n \ntimeout_after_last_ping\n \n=\n \n2\n;\n\n\n\nView the defined message \nhere\n.\n\n\n\n\n\n\n\nKeep-alive Port\nThis driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string \n\"\"\n because the contents of a keep-alive message are never read.\n\n\n\n\n\n\n\nError Port\nApplications can subscribe to this port to receive driver related errors.\n\n\n\n\n\n\n\nData Update Port\nApplications can subscribe to this port for UV data. The output will be a serialized message of type \nUV\n with the following information.\n\nmessage\n \nUV\n{\n\n\n// UV index.\n\n\nfloat\n \nuv_index\n \n=\n \n1\n;\n\n\n\n// Risk of harm from unprotected sun exposure, for the average adult.\n\n\n// According to the OMS table. https://www.epa.gov/sunsafety/uv-index-scale-0\n\n\nstring\n \noms_risk\n \n=\n \n2\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-core/protocols/uv/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/protocols/uv/#overview", 
            "text": "The UV driver reports values for:   UV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization.  From  UV Index Scale  UV Risk scale established by World Health Organization. From  UV Index Scale", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/protocols/servo/", 
            "text": "Servo\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe Servo driver can set the angle of your servos through the pins of your MATRIX device.\n\n\nDevice Pinouts\n:\n\n\n\n\nMATRIX Creator\n\n\nMATRIX Voice\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20045\n\n\nError port\n: 20047\n\n\n\n\nProtocol\n\n\n\n\n\nBase Port\nThis port accepts a single configuration for communicating with the Servo driver. \n\n\n\n\nservo\n - the servo configuration that's created from a \nServoParams\n message.\n\n\n\n\nmessage\n \nDriverConfig\n \n{\n\n\n// ServoMotor service configuration\n\n\nmatrix_io.malos.v1.io.ServoParams\n \nservo\n \n=\n \n7\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.\n\n\nServoParams\n\n\n\n\n\n\npin\n - Selects the pin you want to use on your MATRIX device. \n\n\n\n\n\n\nangle\n - emits a signal input that represents the angle set.\n\n\n\n\n\n\n// Servo handler params\n\n\nmessage\n \nServoParams\n \n{\n\n\n// Pin to configure\n\n\nuint32\n \npin\n \n=\n \n1\n;\n\n\n\n// Servo angle\n\n\nuint32\n \nangle\n \n=\n \n2\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.\n\n\n\n\n\n\n\nError Port\nApplications can subscribe to this port to receive driver related errors.", 
            "title": "Servo"
        }, 
        {
            "location": "/matrix-core/protocols/servo/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/protocols/servo/#overview", 
            "text": "The Servo driver can set the angle of your servos through the pins of your MATRIX device.  Device Pinouts :   MATRIX Creator  MATRIX Voice", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/protocols/servo/#protocol", 
            "text": "Base Port This port accepts a single configuration for communicating with the Servo driver.    servo  - the servo configuration that's created from a  ServoParams  message.   message   DriverConfig   {  // ServoMotor service configuration  matrix_io.malos.v1.io.ServoParams   servo   =   7 ;  }  \nView the defined message  here .  ServoParams    pin  - Selects the pin you want to use on your MATRIX device.     angle  - emits a signal input that represents the angle set.    // Servo handler params  message   ServoParams   {  // Pin to configure  uint32   pin   =   1 ;  // Servo angle  uint32   angle   =   2 ;  }  \nView the defined message  here .    Error Port Applications can subscribe to this port to receive driver related errors.", 
            "title": "Protocol"
        }, 
        {
            "location": "/matrix-core/protocols/gpio/", 
            "text": "General Purpose Input Output (GPIO)\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe GPIO driver supports:\na \n\n\n\n\nPin input\n\n\nPin output\n\n\nUpdates for the current state of all GPIO pins\n\n\n\n\nDevice Pinouts\n:\n\n\n\n\nMATRIX Creator\n\n\nMATRIX Voice\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20049\n\n\nKeep-alive port\n: 20050\n\n\nError port\n: 20051\n\n\nData Update port\n: 20052\n\n\n\n\nProtocol\n\n\n\n\n\nBase Port\nThis port accepts 3 configuration for communicating with the GPIO driver.\n\n\n\n\n\n\ndelay_between_updates\n - controls the output speed of messages from the \nData Update port\n. \n\n\n\n\n\n\ntimeout_after_last_ping\n - stops sending messages from the \nData Update port\n if nothing has been sent to the \nKeep-alive port\n after the specified amount of seconds.\n\n\n\n\n\n\ngpio\n - the gpio configuration that's created from a \nGpioParams\n message.\n\n\n\n\n\n\nmessage\n \nDriverConfig\n \n{\n\n\n// Delay between updates in seconds\n\n\nfloat\n \ndelay_between_updates\n \n=\n \n1\n;\n\n\n// Timeout after last ping\n\n\nfloat\n \ntimeout_after_last_ping\n \n=\n \n2\n;\n\n\n// Gpio service configuration\n\n\nmatrix_io.malos.v1.io.GpioParams\n \ngpio\n \n=\n \n8\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.\n\n\nGpioParams\n\n\n\n\n\n\npin\n - Selects the pin you want to use on your MATRIX device. \n\n\n\n\n\n\nEnumMode\n - Determines input or output mode for GPIO pins.\n\n\n\n\n\n\nvalue\n - Set as 1 or 0 to signify on/off.\n\n\n\n\n\n\n\n\nEach \npin\n will save its last set \nvalue\n until the next device boot.\n\n\n\n\n// GPIO handler params\n\n\nmessage\n \nGpioParams\n \n{\n\n\n// GPIO to config\n\n\nuint32\n \npin\n \n=\n \n1\n;\n\n\n\n// GPIO mode input/output\n\n\nenum\n \nEnumMode\n \n{\n\n    \nINPUT\n \n=\n \n0\n;\n\n    \nOUTPUT\n \n=\n \n1\n;\n\n\n}\n\n\nEnumMode\n \nmode\n \n=\n \n2\n;\n\n\n\n// GPIO value\n\n\nuint32\n \nvalue\n \n=\n \n3\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.\n\n\n\n\n\n\n\nKeep-alive Port\nThis driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string \n\"\"\n because the contents of a keep-alive message are never read.\n\n\n\n\n\n\n\nError Port\nApplications can subscribe to this port to receive driver related errors.\n\n\n\n\n\n\n\nData Update Port\nApplications can subscribe to this port for GPIO data. The output will be a serialized message of type \nGpioParams\n with the following information.\n\n// GPIO handler params\n\n\nmessage\n \nGpioParams\n \n{\n\n\n// Integer to represent all pin values (Convert to 16bit for readability)\n\n\nuint32\n \nvalues\n \n=\n \n4\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-core/protocols/gpio/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/protocols/gpio/#overview", 
            "text": "The GPIO driver supports: a    Pin input  Pin output  Updates for the current state of all GPIO pins   Device Pinouts :   MATRIX Creator  MATRIX Voice", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/protocols/gpio/#protocol", 
            "text": "Base Port This port accepts 3 configuration for communicating with the GPIO driver.    delay_between_updates  - controls the output speed of messages from the  Data Update port .     timeout_after_last_ping  - stops sending messages from the  Data Update port  if nothing has been sent to the  Keep-alive port  after the specified amount of seconds.    gpio  - the gpio configuration that's created from a  GpioParams  message.    message   DriverConfig   {  // Delay between updates in seconds  float   delay_between_updates   =   1 ;  // Timeout after last ping  float   timeout_after_last_ping   =   2 ;  // Gpio service configuration  matrix_io.malos.v1.io.GpioParams   gpio   =   8 ;  }  \nView the defined message  here .  GpioParams    pin  - Selects the pin you want to use on your MATRIX device.     EnumMode  - Determines input or output mode for GPIO pins.    value  - Set as 1 or 0 to signify on/off.     Each  pin  will save its last set  value  until the next device boot.   // GPIO handler params  message   GpioParams   {  // GPIO to config  uint32   pin   =   1 ;  // GPIO mode input/output  enum   EnumMode   { \n     INPUT   =   0 ; \n     OUTPUT   =   1 ;  }  EnumMode   mode   =   2 ;  // GPIO value  uint32   value   =   3 ;  }  \nView the defined message  here .    Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string  \"\"  because the contents of a keep-alive message are never read.    Error Port Applications can subscribe to this port to receive driver related errors.    Data Update Port Applications can subscribe to this port for GPIO data. The output will be a serialized message of type  GpioParams  with the following information. // GPIO handler params  message   GpioParams   {  // Integer to represent all pin values (Convert to 16bit for readability)  uint32   values   =   4 ;  }  \nView the defined message  here .", 
            "title": "Protocol"
        }, 
        {
            "location": "/matrix-core/protocols/wakeword/", 
            "text": "Wakeword\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe Wakeword driver allows for:\n\n\n\n\nReading custom wakewords created with \nSphinx Knowledge Base\n.\n\n\nNotifications on which wakewords are heard.\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 60001\n\n\nError port\n: 60003\n\n\nData update port\n: 60004\n\n\n\n\nInstallation\n\n\nIn order to use MATRIX CORE wakeword, you must install the following on your MATRIX device.\n\n\nInstall the \nMATRIX Kernel\n modules.\n\nsudo apt install matrixio-kernel-modules\n\n\nInstall the \nMATRIX CORE Wakeword Package\n.\n\nsudo apt install matrixio-malos-wakeword\n\n\nPerform a \nreboot\n before moving on.\n\nsudo reboot\n\n\n\nCreating Custom Phrases\n\n\nTo create custom phrases, you must upload a \n.txt\n file to \nSphinx Knowledge Base\n.\n\n\nBelow is an example text file that has each phrase separated by a line break. Once this is uploaded to the Sphinx Knowledge base, you will need to download the language model \n.lm\n and dictation \n.dic\n files for the Wakeword Driver.\n\n\nmatrix\n \nstart\n \naction\n\n\nmatrix\n \nstop\n \naction\n\n\nmatrix\n \nring\n \nred\n\n\nmatrix\n \nring\n \nblue\n\n\nmatrix\n \nring\n \ngreen\n\n\nmatrix\n \nring\n \nclear\n\n\n\n\n\nProtocol\n\n\n\n\n\nBase Port\nThis port accepts a single configuration for communicating with the Wakeword driver. \n\n\n\n\nwakeword\n - the wakeword configuration that's created from a \nWakeWordParams\n message.\n\n\n\n\nmessage\n \nDriverConfig\n \n{\n\n\n// Wakeword service configuration\n\n\nmatrix_io.malos.v1.io.WakeWordParams\n \nwakeword\n \n=\n \n12\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.\n\n\nWakeWordParams\n \n\n\n\n\n\n\nMicChannel\n - Desired MATRIX device microphone to use.\n\n\n\n\n\n\nlm_path\n - File path for language model. \nObtained from Sphinx Knowledge Base\n.\n\n\n\n\n\n\ndic_path\n - File path for dictation. \nObtained from Sphinx Knowledge Base\n.\n\n\n\n\n\n\nenable_verbose\n - Boolean to send output to stdout.\n\n\n\n\n\n\nstop_recognition\n - Stop Pocket Sphinx service.\n\n\n\n\n\n\nmessage\n \nWakeWordParams\n \n{\n\n\n// Mic channels\n\n\nenum\n \nMicChannel\n \n{\n\n    \nchannel0\n \n=\n \n0\n;\n\n    \nchannel1\n \n=\n \n1\n;\n\n    \nchannel2\n \n=\n \n2\n;\n\n    \nchannel3\n \n=\n \n3\n;\n\n    \nchannel4\n \n=\n \n4\n;\n\n    \nchannel5\n \n=\n \n5\n;\n\n    \nchannel6\n \n=\n \n6\n;\n\n    \nchannel7\n \n=\n \n7\n;\n\n    \nchannel8\n \n=\n \n8\n;\n\n\n}\n\n\n// Desired mic channel\n\n\nMicChannel\n \nchannel\n \n=\n \n2\n;\n\n\n\n// http://www.speech.cs.cmu.edu/tools/lmtool-new.html\n\n\n// Language model path\n\n\nstring\n \nlm_path\n \n=\n \n3\n;\n\n\n// Dictation path\n\n\nstring\n \ndic_path\n \n=\n \n4\n;\n\n\n\n// enable pocketsphinx verbose mode\n\n\nbool\n \nenable_verbose\n \n=\n \n5\n;\n\n\n\n// stop recognition service\n\n\nbool\n \nstop_recognition\n \n=\n \n6\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.\n\n\n\n\n\n\n\nKeep-alive Port\nThis driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string \n\"\"\n because the contents of a keep-alive message are never read.\n\n\n\n\n\n\n\nError Port\nApplications can subscribe to this port to receive driver related errors.\n\n\n\n\n\n\n\nData Update Port\nApplications can subscribe to this port for Everloop data. The output will be a serialized message of type \nEverloopImage\n with the following information.\n\n\n// The led array.\n\n\nmessage\n \nWakeWordParams\n \n{\n\n\n// Wake Word\n\n\nstring\n \nwake_word\n \n=\n \n1\n;\n\n\n}\n\n\n\nView the defined message \nhere\n.", 
            "title": "Wakeword"
        }, 
        {
            "location": "/matrix-core/protocols/wakeword/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/protocols/wakeword/#overview", 
            "text": "The Wakeword driver allows for:   Reading custom wakewords created with  Sphinx Knowledge Base .  Notifications on which wakewords are heard.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/protocols/wakeword/#installation", 
            "text": "In order to use MATRIX CORE wakeword, you must install the following on your MATRIX device.  Install the  MATRIX Kernel  modules. sudo apt install matrixio-kernel-modules \nInstall the  MATRIX CORE Wakeword Package . sudo apt install matrixio-malos-wakeword \nPerform a  reboot  before moving on. sudo reboot", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-core/protocols/wakeword/#creating-custom-phrases", 
            "text": "To create custom phrases, you must upload a  .txt  file to  Sphinx Knowledge Base .  Below is an example text file that has each phrase separated by a line break. Once this is uploaded to the Sphinx Knowledge base, you will need to download the language model  .lm  and dictation  .dic  files for the Wakeword Driver.  matrix   start   action  matrix   stop   action  matrix   ring   red  matrix   ring   blue  matrix   ring   green  matrix   ring   clear", 
            "title": "Creating Custom Phrases"
        }, 
        {
            "location": "/matrix-core/protocols/wakeword/#protocol", 
            "text": "Base Port This port accepts a single configuration for communicating with the Wakeword driver.    wakeword  - the wakeword configuration that's created from a  WakeWordParams  message.   message   DriverConfig   {  // Wakeword service configuration  matrix_io.malos.v1.io.WakeWordParams   wakeword   =   12 ;  }  \nView the defined message  here .  WakeWordParams      MicChannel  - Desired MATRIX device microphone to use.    lm_path  - File path for language model.  Obtained from Sphinx Knowledge Base .    dic_path  - File path for dictation.  Obtained from Sphinx Knowledge Base .    enable_verbose  - Boolean to send output to stdout.    stop_recognition  - Stop Pocket Sphinx service.    message   WakeWordParams   {  // Mic channels  enum   MicChannel   { \n     channel0   =   0 ; \n     channel1   =   1 ; \n     channel2   =   2 ; \n     channel3   =   3 ; \n     channel4   =   4 ; \n     channel5   =   5 ; \n     channel6   =   6 ; \n     channel7   =   7 ; \n     channel8   =   8 ;  }  // Desired mic channel  MicChannel   channel   =   2 ;  // http://www.speech.cs.cmu.edu/tools/lmtool-new.html  // Language model path  string   lm_path   =   3 ;  // Dictation path  string   dic_path   =   4 ;  // enable pocketsphinx verbose mode  bool   enable_verbose   =   5 ;  // stop recognition service  bool   stop_recognition   =   6 ;  }  \nView the defined message  here .    Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string  \"\"  because the contents of a keep-alive message are never read.    Error Port Applications can subscribe to this port to receive driver related errors.    Data Update Port Applications can subscribe to this port for Everloop data. The output will be a serialized message of type  EverloopImage  with the following information.  // The led array.  message   WakeWordParams   {  // Wake Word  string   wake_word   =   1 ;  }  \nView the defined message  here .", 
            "title": "Protocol"
        }, 
        {
            "location": "/matrix-core/javascript-examples/", 
            "text": "Javascript Examples\n\n\nEverloop\n\nLED interface.\n\n\nHumidity\n\n\n\nHumidity and temperature measurement.\n\n\nIMU\n\n\n\nInertial Measurement Unit.\n\n\nPressure\n\n\n\nPressure, altitude and temperature measurement.\n\n\nUV\n\n\n\nUltraviolet light sensor.\n\n\nServo\n\n\n\nAdjust servo positions.\n\n\nGPIO\n\n\n\nGeneral Purpose Input/Output.\n\n\nWakeword\n\n\n\nCreate custom voice commands with Pocket Sphinx.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-core/javascript-examples/#javascript-examples", 
            "text": "", 
            "title": "Javascript Examples"
        }, 
        {
            "location": "/matrix-core/javascript-examples/everloop/", 
            "text": "Everloop\n\n\n\nJavascript Example\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe Everloop driver allows for:\n\n\n\n\nReading amount of LEDs your MATRIX device has.\n\n\nSetting the RGBW colors for each individual LED.\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20021\n\n\nKeep-alive port\n: 20022\n\n\nError port\n: 20023\n\n\nData update port\n: 20024\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the Everloop driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references.\n\n\nvar\n \nzmq\n \n=\n \nrequire\n(\nzeromq\n);\n// Asynchronous Messaging Framework\n\n\nvar\n \nmatrix_io\n \n=\n \nrequire\n(\nmatrix-protos\n).\nmatrix_io\n;\n// Protocol Buffers for MATRIX function\n\n\nvar\n \nmatrix_ip\n \n=\n \n127.0.0.1\n;\n// Local IP\n\n\nvar\n \nmatrix_everloop_base_port\n \n=\n \n20021\n;\n// Port for Everloop driver\n\n\nvar\n \nmatrix_device_leds\n \n=\n \n0\n;\n// Holds amount of LEDs on MATRIX device\n\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the main logic for our Everloop example goes. Once we connect to the \nBase Port\n, the program will start an endless loop to create and send LED configurations with randomly generated RGBW values. However, before sending the LED configuration to you MATRIX device, it will wait until the amount of \nmatrix_device_leds\n is defined.\n\n// Create a Pusher socket\n\n\nvar\n \nconfigSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Base Port\n\n\nconfigSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \nmatrix_everloop_base_port\n);\n\n\n\n// Create an empty Everloop image\n\n\nvar\n \nimage\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nio\n.\nEverloopImage\n.\ncreate\n();\n\n\n\n// Loop every 50 milliseconds\n\n\nsetInterval\n(\nfunction\n(){\n\n    \n// For each device LED\n\n    \nfor\n \n(\nvar\n \ni\n \n=\n \n0\n;\n \ni\n \n \nmatrix_device_leds\n;\n \n++\ni\n)\n \n{\n\n    \n// Set individual LED value\n\n    \nimage\n.\nled\n[\ni\n]\n \n=\n \n{\n\n        \nred\n:\n \nMath\n.\nfloor\n(\nMath\n.\nrandom\n()\n \n*\n \n200\n)\n+\n1\n,\n\n        \ngreen\n:\n \nMath\n.\nfloor\n(\nMath\n.\nrandom\n()\n \n*\n \n255\n)\n+\n1\n,\n\n        \nblue\n:\n \nMath\n.\nfloor\n(\nMath\n.\nrandom\n()\n \n*\n \n50\n)\n+\n1\n,\n\n        \nwhite\n:\n \n0\n\n    \n};\n\n    \n}\n\n\n    \n// Store the Everloop image in MATRIX configuration\n\n    \nvar\n \nconfig\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\ncreate\n({\n\n    \nimage\n:\n \nimage\n\n    \n});\n\n\n    \n// Send MATRIX configuration to MATRIX device\n\n    \nif\n(\nmatrix_device_leds\n \n \n0\n)\n\n    \nconfigSocket\n.\nsend\n(\nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\nencode\n(\nconfig\n).\nfinish\n());\n\n\n},\n50\n);\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message, an empty string, will grant us a response from the \nData Update Port\n with the value we need for \nmatrix_device_leds\n.\n\n// Create a Pusher socket\n\n\nvar\n \npingSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n)\n\n\n// Connect Pusher to Keep-alive port\n\n\npingSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_everloop_base_port\n \n+\n \n1\n));\n\n\n// Send a single ping\n\n\npingSocket\n.\nsend\n(\n);\n\n\n\n\n\n\n\n\n\nError Port\nConnecting to the \nError Port\n is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE.\n\n// Create a Subscriber socket\n\n\nvar\n \nerrorSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_everloop_base_port\n \n+\n \n2\n));\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nerrorSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nerror_message\n){\n\n\nconsole\n.\nlog\n(\nError received: \n \n+\n \nerror_message\n.\ntoString\n(\nutf8\n));\n// Log error\n\n\n});\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n will allow us to receive the LED count we want for the \nmatrix_device_leds\n variable. Once that variable is set, the MATRIX device will begin reading the Everloop images being sent to the base port.\n\n\n// Create a Subscriber socket\n\n\nvar\n \nupdateSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Data Update port\n\n\nupdateSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_everloop_base_port\n \n+\n \n3\n));\n\n\n// Subscribe to messages\n\n\nupdateSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nupdateSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nbuffer\n){\n\n\nvar\n \ndata\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nio\n.\nEverloopImage\n.\ndecode\n(\nbuffer\n);\n// Extract message\n\n\nmatrix_device_leds\n \n=\n \ndata\n.\neverloopLength\n;\n// Save MATRIX device LED count\n\n\n});\n\n\n\n\nData Output\n\nThe javascript object below is an example output you'll receive from the \nData Update Port\n.\n\n{\n\n\nled\n:\n \n[],\n\n\neverloopLength\n:\n \n35\n\n\n}", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-core/javascript-examples/everloop/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/javascript-examples/everloop/#overview", 
            "text": "The Everloop driver allows for:   Reading amount of LEDs your MATRIX device has.  Setting the RGBW colors for each individual LED.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/javascript-examples/everloop/#code-example", 
            "text": "The following sections show how to implement a connection to each of the Everloop driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references.  var   zmq   =   require ( zeromq ); // Asynchronous Messaging Framework  var   matrix_io   =   require ( matrix-protos ). matrix_io ; // Protocol Buffers for MATRIX function  var   matrix_ip   =   127.0.0.1 ; // Local IP  var   matrix_everloop_base_port   =   20021 ; // Port for Everloop driver  var   matrix_device_leds   =   0 ; // Holds amount of LEDs on MATRIX device     Base Port Here is where the main logic for our Everloop example goes. Once we connect to the  Base Port , the program will start an endless loop to create and send LED configurations with randomly generated RGBW values. However, before sending the LED configuration to you MATRIX device, it will wait until the amount of  matrix_device_leds  is defined. // Create a Pusher socket  var   configSocket   =   zmq . socket ( push );  // Connect Pusher to Base Port  configSocket . connect ( tcp://   +   matrix_ip   +   :   +   matrix_everloop_base_port );  // Create an empty Everloop image  var   image   =   matrix_io . malos . v1 . io . EverloopImage . create ();  // Loop every 50 milliseconds  setInterval ( function (){ \n     // For each device LED \n     for   ( var   i   =   0 ;   i     matrix_device_leds ;   ++ i )   { \n     // Set individual LED value \n     image . led [ i ]   =   { \n         red :   Math . floor ( Math . random ()   *   200 ) + 1 , \n         green :   Math . floor ( Math . random ()   *   255 ) + 1 , \n         blue :   Math . floor ( Math . random ()   *   50 ) + 1 , \n         white :   0 \n     }; \n     } \n\n     // Store the Everloop image in MATRIX configuration \n     var   config   =   matrix_io . malos . v1 . driver . DriverConfig . create ({ \n     image :   image \n     }); \n\n     // Send MATRIX configuration to MATRIX device \n     if ( matrix_device_leds     0 ) \n     configSocket . send ( matrix_io . malos . v1 . driver . DriverConfig . encode ( config ). finish ());  }, 50 );     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message, an empty string, will grant us a response from the  Data Update Port  with the value we need for  matrix_device_leds . // Create a Pusher socket  var   pingSocket   =   zmq . socket ( push )  // Connect Pusher to Keep-alive port  pingSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_everloop_base_port   +   1 ));  // Send a single ping  pingSocket . send ( );     Error Port Connecting to the  Error Port  is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. // Create a Subscriber socket  var   errorSocket   =   zmq . socket ( sub );  // Connect Subscriber to Error port  errorSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_everloop_base_port   +   2 ));  // Connect Subscriber to Error port  errorSocket . subscribe ( );  // On Message  errorSocket . on ( message ,   function ( error_message ){  console . log ( Error received:    +   error_message . toString ( utf8 )); // Log error  });     Data Update Port A connection to the  Data Update Port  will allow us to receive the LED count we want for the  matrix_device_leds  variable. Once that variable is set, the MATRIX device will begin reading the Everloop images being sent to the base port.  // Create a Subscriber socket  var   updateSocket   =   zmq . socket ( sub );  // Connect Subscriber to Data Update port  updateSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_everloop_base_port   +   3 ));  // Subscribe to messages  updateSocket . subscribe ( );  // On Message  updateSocket . on ( message ,   function ( buffer ){  var   data   =   matrix_io . malos . v1 . io . EverloopImage . decode ( buffer ); // Extract message  matrix_device_leds   =   data . everloopLength ; // Save MATRIX device LED count  });", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/javascript-examples/humidity/", 
            "text": "Humidity\n\n\n\nJavascript Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe Humidity driver allows for:\n\n\n\n\nReading relative humidity on the board\n\n\nObtaining temperature in Celsius and raw values\n\n\nCalibrating temperature\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20017\n\n\nKeep-alive port\n: 20018\n\n\nError port\n: 20019\n\n\nData update port\n: 20020\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the Humidity driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references.\n\nvar\n \nzmq\n \n=\n \nrequire\n(\nzeromq\n);\n// Asynchronous Messaging Framework\n\n\nvar\n \nmatrix_io\n \n=\n \nrequire\n(\nmatrix-protos\n).\nmatrix_io\n;\n// Protocol Buffers for MATRIX function\n\n\nvar\n \nmatrix_ip\n \n=\n \n127.0.0.1\n;\n// Local IP\n\n\nvar\n \nmatrix_humidity_base_port\n \n=\n \n20017\n;\n// Port for Humidity driver\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our Humidity example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the humidity driver. With this we can set the update rate, timeout, and temperature configuration.\n\n// Create a Pusher socket\n\n\nvar\n \nconfigSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Base port\n\n\nconfigSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \nmatrix_humidity_base_port\n);\n\n\n// Create driver configuration\n\n\nvar\n \nconfig\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\ncreate\n({\n\n    \n// Update rate configuration\n\n    \ndelayBetweenUpdates\n:\n \n2.0\n,\n// 2 seconds between updates\n\n    \ntimeoutAfterLastPing\n:\n \n6.0\n,\n// Stop sending updates 6 seconds after pings.\n\n    \n// Humidity configuration\n\n    \nhumidity\n:\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nsense\n.\nHumidityParams\n.\ncreate\n({\n\n    \ncurrentTemperature\n:\n \n23\n// Real current temperature [Celsius] for calibration \n\n    \n})\n\n\n});\n\n\n// Send driver configuration\n\n\nconfigSocket\n.\nsend\n(\nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\nencode\n(\nconfig\n).\nfinish\n());\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message, an empty string, will grant us a response from the \nData Update Port\n for the current humidity value. An interval for pinging is then set to continuously obtain that data.\n\n// Create a Pusher socket\n\n\nvar\n \npingSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Keep-alive port\n\n\npingSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_humidity_base_port\n \n+\n \n1\n));\n\n\n// Send initial ping\n\n\npingSocket\n.\nsend\n(\n);\n\n\n// Send ping every 5 seconds\n\n\nsetInterval\n(\nfunction\n(){\n\n    \npingSocket\n.\nsend\n(\n);\n\n\n},\n \n5000\n);\n\n\n\n\n\n\n\n\n\nError Port\nConnecting to the \nError Port\n is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE.\n\n// Create a Subscriber socket\n\n\nvar\n \nerrorSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_humidity_base_port\n \n+\n \n2\n));\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nerrorSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nerror_message\n){\n\n\nconsole\n.\nlog\n(\nError received: \n \n+\n \nerror_message\n.\ntoString\n(\nutf8\n));\n// Log error\n\n\n});\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n will allow us to receive the current humidity data we want.\n\n\n// Create a Subscriber socket\n\n\nvar\n \nupdateSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Data Update port\n\n\nupdateSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_humidity_base_port\n \n+\n \n3\n));\n\n\n// Subscribe to messages\n\n\nupdateSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nupdateSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nbuffer\n){\n\n\nvar\n \ndata\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nsense\n.\nHumidity\n.\ndecode\n(\nbuffer\n);\n// Extract message\n\n    \nconsole\n.\nlog\n(\ndata\n);\n// Log new humidity data\n\n\n});\n\n\n\n\nData Output\n\nThe javascript object below is an example output you'll receive from the \nData Update Port\n.\n\n{\n\n\nhumidity\n:\n \n29.003999710083008\n,\n\n\ntemperature\n:\n \n22.998397827148438\n,\n\n\ntemperatureRaw\n:\n \n33.124000549316406\n,\n\n\ntemperatureIsCalibrated\n:\n \ntrue\n \n\n}", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-core/javascript-examples/humidity/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/javascript-examples/humidity/#overview", 
            "text": "The Humidity driver allows for:   Reading relative humidity on the board  Obtaining temperature in Celsius and raw values  Calibrating temperature", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/javascript-examples/humidity/#code-example", 
            "text": "The following sections show how to implement a connection to each of the Humidity driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. var   zmq   =   require ( zeromq ); // Asynchronous Messaging Framework  var   matrix_io   =   require ( matrix-protos ). matrix_io ; // Protocol Buffers for MATRIX function  var   matrix_ip   =   127.0.0.1 ; // Local IP  var   matrix_humidity_base_port   =   20017 ; // Port for Humidity driver     Base Port Here is where the configuration for our Humidity example goes. Once we connect to the  Base Port , we will pass a configuration to the humidity driver. With this we can set the update rate, timeout, and temperature configuration. // Create a Pusher socket  var   configSocket   =   zmq . socket ( push );  // Connect Pusher to Base port  configSocket . connect ( tcp://   +   matrix_ip   +   :   +   matrix_humidity_base_port );  // Create driver configuration  var   config   =   matrix_io . malos . v1 . driver . DriverConfig . create ({ \n     // Update rate configuration \n     delayBetweenUpdates :   2.0 , // 2 seconds between updates \n     timeoutAfterLastPing :   6.0 , // Stop sending updates 6 seconds after pings. \n     // Humidity configuration \n     humidity :   matrix_io . malos . v1 . sense . HumidityParams . create ({ \n     currentTemperature :   23 // Real current temperature [Celsius] for calibration  \n     })  });  // Send driver configuration  configSocket . send ( matrix_io . malos . v1 . driver . DriverConfig . encode ( config ). finish ());     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message, an empty string, will grant us a response from the  Data Update Port  for the current humidity value. An interval for pinging is then set to continuously obtain that data. // Create a Pusher socket  var   pingSocket   =   zmq . socket ( push );  // Connect Pusher to Keep-alive port  pingSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_humidity_base_port   +   1 ));  // Send initial ping  pingSocket . send ( );  // Send ping every 5 seconds  setInterval ( function (){ \n     pingSocket . send ( );  },   5000 );     Error Port Connecting to the  Error Port  is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. // Create a Subscriber socket  var   errorSocket   =   zmq . socket ( sub );  // Connect Subscriber to Error port  errorSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_humidity_base_port   +   2 ));  // Connect Subscriber to Error port  errorSocket . subscribe ( );  // On Message  errorSocket . on ( message ,   function ( error_message ){  console . log ( Error received:    +   error_message . toString ( utf8 )); // Log error  });     Data Update Port A connection to the  Data Update Port  will allow us to receive the current humidity data we want.  // Create a Subscriber socket  var   updateSocket   =   zmq . socket ( sub );  // Connect Subscriber to Data Update port  updateSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_humidity_base_port   +   3 ));  // Subscribe to messages  updateSocket . subscribe ( );  // On Message  updateSocket . on ( message ,   function ( buffer ){  var   data   =   matrix_io . malos . v1 . sense . Humidity . decode ( buffer ); // Extract message \n     console . log ( data ); // Log new humidity data  });", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/javascript-examples/imu/", 
            "text": "Inertial Measurement Unit (IMU)\n\n\n\nJavascript Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe IMU driver reports values for:\n\n\n\n\nYaw, Pitch, and Roll\n\n\nAcceleration for \nx\n, \ny\n, \nz\n axes\n\n\nGyroscope for \nx\n, \ny\n, \nz\n axes\n\n\nMagnetometer for \nx\n, \ny\n, \nz\n axes\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20013\n\n\nKeep-alive port\n: 20014\n\n\nError port\n: 20015\n\n\nData Update port\n: 20016\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the IMU driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references.\n\nvar\n \nzmq\n \n=\n \nrequire\n(\nzeromq\n);\n// Asynchronous Messaging Framework\n\n\nvar\n \nmatrix_io\n \n=\n \nrequire\n(\nmatrix-protos\n).\nmatrix_io\n;\n// Protocol Buffers for MATRIX function\n\n\nvar\n \nmatrix_ip\n \n=\n \n127.0.0.1\n;\n// Local IP\n\n\nvar\n \nmatrix_imu_base_port\n \n=\n \n20013\n;\n// Port for IMU driver\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our IMU example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the IMU driver. With this we can set the update rate and timeout configuration.\n\n// Create a Pusher socket\n\n\nvar\n \nconfigSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Base port\n\n\nconfigSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \nmatrix_imu_base_port\n);\n\n\n// Create driver configuration\n\n\nvar\n \nconfig\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\ncreate\n({\n\n\n// Update rate configuration\n\n\ndelayBetweenUpdates\n:\n \n2.0\n,\n// 2 seconds between updates\n\n\ntimeoutAfterLastPing\n:\n \n6.0\n,\n// Stop sending updates 6 seconds after pings.\n\n\n});\n\n\n// Send driver configuration\n\n\nconfigSocket\n.\nsend\n(\nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\nencode\n(\nconfig\n).\nfinish\n());\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message, an empty string, will grant us a response from the \nData Update Port\n for the current IMU values. An interval for pinging is then set to continuously obtain that data.\n\n// Create a Pusher socket\n\n\nvar\n \npingSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Keep-alive port\n\n\npingSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_imu_base_port\n \n+\n \n1\n));\n\n\n// Send initial ping\n\n\npingSocket\n.\nsend\n(\n);\n\n\n// Send ping every 5 seconds\n\n\nsetInterval\n(\nfunction\n(){\n\n\npingSocket\n.\nsend\n(\n);\n\n\n},\n \n5000\n);\n\n\n\n\n\n\n\n\n\nError Port\nConnecting to the \nError Port\n is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE.\n\n// Create a Subscriber socket\n\n\nvar\n \nerrorSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_imu_base_port\n \n+\n \n2\n));\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nerrorSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nerror_message\n){\n\n\nconsole\n.\nlog\n(\nError received: \n \n+\n \nerror_message\n.\ntoString\n(\nutf8\n));\n// Log error\n\n\n});\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n is then made to allow us to receive the current IMU data we want.\n\n\n// Create a Subscriber socket\n\n\nvar\n \nupdateSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Data Update port\n\n\nupdateSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_imu_base_port\n \n+\n \n3\n));\n\n\n// Subscribe to messages\n\n\nupdateSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nupdateSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nbuffer\n){\n\n\nvar\n \ndata\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nsense\n.\nImu\n.\ndecode\n(\nbuffer\n);\n// Extract message\n\n    \nconsole\n.\nlog\n(\ndata\n);\n// Log new IMU data\n\n\n});\n\n\n\n\nData Output\n\nThe javascript object below is an example output you'll receive from the \nData Update Port\n.\n\n{\n\n\nyaw\n:\n \n29.820072174072266\n,\n\n\npitch\n:\n \n9.994316101074219\n,\n\n\nroll\n:\n \n-\n179.4230194091797\n,\n\n\naccelX\n:\n \n-\n0.17499999701976776\n,\n\n\naccelY\n:\n \n-\n0.009999999776482582\n,\n\n\naccelZ\n:\n \n-\n0.9929999709129333\n,\n\n\ngyroX\n:\n \n2.871000051498413\n,\n\n\ngyroY\n:\n \n0.3059999942779541\n,\n\n\ngyroZ\n:\n \n0.8069999814033508\n,\n\n\nmagX\n:\n \n-\n0.0820000022649765\n,\n\n\nmagY\n:\n \n0.04699999839067459\n,\n\n\nmagZ\n:\n \n0.11299999803304672\n\n\n}", 
            "title": "IMU"
        }, 
        {
            "location": "/matrix-core/javascript-examples/imu/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/javascript-examples/imu/#overview", 
            "text": "The IMU driver reports values for:   Yaw, Pitch, and Roll  Acceleration for  x ,  y ,  z  axes  Gyroscope for  x ,  y ,  z  axes  Magnetometer for  x ,  y ,  z  axes", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/javascript-examples/imu/#code-example", 
            "text": "The following sections show how to implement a connection to each of the IMU driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. var   zmq   =   require ( zeromq ); // Asynchronous Messaging Framework  var   matrix_io   =   require ( matrix-protos ). matrix_io ; // Protocol Buffers for MATRIX function  var   matrix_ip   =   127.0.0.1 ; // Local IP  var   matrix_imu_base_port   =   20013 ; // Port for IMU driver     Base Port Here is where the configuration for our IMU example goes. Once we connect to the  Base Port , we will pass a configuration to the IMU driver. With this we can set the update rate and timeout configuration. // Create a Pusher socket  var   configSocket   =   zmq . socket ( push );  // Connect Pusher to Base port  configSocket . connect ( tcp://   +   matrix_ip   +   :   +   matrix_imu_base_port );  // Create driver configuration  var   config   =   matrix_io . malos . v1 . driver . DriverConfig . create ({  // Update rate configuration  delayBetweenUpdates :   2.0 , // 2 seconds between updates  timeoutAfterLastPing :   6.0 , // Stop sending updates 6 seconds after pings.  });  // Send driver configuration  configSocket . send ( matrix_io . malos . v1 . driver . DriverConfig . encode ( config ). finish ());     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message, an empty string, will grant us a response from the  Data Update Port  for the current IMU values. An interval for pinging is then set to continuously obtain that data. // Create a Pusher socket  var   pingSocket   =   zmq . socket ( push );  // Connect Pusher to Keep-alive port  pingSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_imu_base_port   +   1 ));  // Send initial ping  pingSocket . send ( );  // Send ping every 5 seconds  setInterval ( function (){  pingSocket . send ( );  },   5000 );     Error Port Connecting to the  Error Port  is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. // Create a Subscriber socket  var   errorSocket   =   zmq . socket ( sub );  // Connect Subscriber to Error port  errorSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_imu_base_port   +   2 ));  // Connect Subscriber to Error port  errorSocket . subscribe ( );  // On Message  errorSocket . on ( message ,   function ( error_message ){  console . log ( Error received:    +   error_message . toString ( utf8 )); // Log error  });     Data Update Port A connection to the  Data Update Port  is then made to allow us to receive the current IMU data we want.  // Create a Subscriber socket  var   updateSocket   =   zmq . socket ( sub );  // Connect Subscriber to Data Update port  updateSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_imu_base_port   +   3 ));  // Subscribe to messages  updateSocket . subscribe ( );  // On Message  updateSocket . on ( message ,   function ( buffer ){  var   data   =   matrix_io . malos . v1 . sense . Imu . decode ( buffer ); // Extract message \n     console . log ( data ); // Log new IMU data  });", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/javascript-examples/pressure/", 
            "text": "Pressure\n\n\n\nJavascript Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe Pressure driver reports values for:\n\n\n\n\nPressure\n\n\nAltitude\n\n\nTemperature\n\n\n\n\n\n\nBased on component location, the temperature values from the \nHumidity driver\n are recommended over the Pressure driver\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20025\n\n\nKeep-alive port\n: 20026\n\n\nError port\n: 20027\n\n\nData Update port\n: 20028\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references.\n\nvar\n \nzmq\n \n=\n \nrequire\n(\nzeromq\n);\n// Asynchronous Messaging Framework\n\n\nvar\n \nmatrix_io\n \n=\n \nrequire\n(\nmatrix-protos\n).\nmatrix_io\n;\n// Protocol Buffers for MATRIX function\n\n\nvar\n \nmatrix_ip\n \n=\n \n127.0.0.1\n;\n// Local IP\n\n\nvar\n \nmatrix_pressure_base_port\n \n=\n \n20025\n;\n// Port for Pressure driver\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our Pressure example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the pressure driver. With this we can set the update rate and timeout configuration.\n\n// Create a Pusher socket\n\n\nvar\n \nconfigSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Base port\n\n\nconfigSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \nmatrix_pressure_base_port\n);\n\n\n// Create driver configuration\n\n\nvar\n \nconfig\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\ncreate\n({\n\n\n// Update rate configuration\n\n\ndelayBetweenUpdates\n:\n \n2.0\n,\n// 2 seconds between updates\n\n\ntimeoutAfterLastPing\n:\n \n6.0\n,\n// Stop sending updates 6 seconds after pings.\n\n\n});\n\n\n// Send driver configuration\n\n\nconfigSocket\n.\nsend\n(\nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\nencode\n(\nconfig\n).\nfinish\n());\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message, an empty string, will grant us a response from the \nData Update Port\n for the current pressure value. An interval for pinging is then set to continuously obtain that data.\n\n// Create a Pusher socket\n\n\nvar\n \npingSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Keep-alive port\n\n\npingSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_pressure_base_port\n \n+\n \n1\n));\n\n\n// Send initial ping\n\n\npingSocket\n.\nsend\n(\n);\n\n\n// Send ping every 5 seconds\n\n\nsetInterval\n(\nfunction\n(){\n\n\npingSocket\n.\nsend\n(\n);\n\n\n},\n \n5000\n);\n\n\n\n\n\n\n\n\n\nError Port\nConnecting to the \nError Port\n is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE.\n\n// Create a Subscriber socket\n\n\nvar\n \nerrorSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_pressure_base_port\n \n+\n \n2\n));\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nerrorSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nerror_message\n){\n\n\nconsole\n.\nlog\n(\nError received: \n \n+\n \nerror_message\n.\ntoString\n(\nutf8\n));\n// Log error\n\n\n});\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n will allow us to receive the current pressure data we want.\n\n\n// Create a Subscriber socket\n\n\nvar\n \nupdateSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Data Update port\n\n\nupdateSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_pressure_base_port\n \n+\n \n3\n));\n\n\n// Subscribe to messages\n\n\nupdateSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nupdateSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nbuffer\n){\n\n\nvar\n \ndata\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nsense\n.\nPressure\n.\ndecode\n(\nbuffer\n);\n// Extract message\n\n    \nconsole\n.\nlog\n(\ndata\n);\n// Log new pressure data\n\n\n});\n\n\n\n\nData Output\n\nThe javascript object below is an example output you'll receive from the \nData Update Port\n.\n\n{\n\n\npressure\n:\n \n101173.75\n,\n\n\naltitude\n:\n \n12.812000274658203\n,\n\n\ntemperature\n:\n \n37.3120002746582\n \n\n}", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-core/javascript-examples/pressure/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/javascript-examples/pressure/#overview", 
            "text": "The Pressure driver reports values for:   Pressure  Altitude  Temperature    Based on component location, the temperature values from the  Humidity driver  are recommended over the Pressure driver", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/javascript-examples/uv/", 
            "text": "UV\n\n\n\nJavascript Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe UV driver reports values for:\n\n\n\n\nUV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization.  From \nUV Index Scale\n\n\nUV Risk scale established by World Health Organization. From \nUV Index Scale\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20029\n\n\nKeep-alive port\n: 20030\n\n\nError port\n: 20031\n\n\nData Update port\n: 20032\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the UV driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references.\n\nvar\n \nzmq\n \n=\n \nrequire\n(\nzeromq\n);\n// Asynchronous Messaging Framework\n\n\nvar\n \nmatrix_io\n \n=\n \nrequire\n(\nmatrix-protos\n).\nmatrix_io\n;\n// Protocol Buffers for MATRIX function\n\n\nvar\n \nmatrix_ip\n \n=\n \n127.0.0.1\n;\n// Local IP\n\n\nvar\n \nmatrix_uv_base_port\n \n=\n \n20029\n;\n// Port for UV driver\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our UV example goes. Once we connect to the \nBase Port\n, We will pass a configuration to the UV driver. With this we can set the update rate and timeout configuration.\n\n// Create a Pusher socket\n\n\nvar\n \nconfigSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Base port\n\n\nconfigSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \nmatrix_uv_base_port\n);\n\n\n// Create driver configuration\n\n\nvar\n \nconfig\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\ncreate\n({\n\n    \n// Update rate configuration\n\n    \ndelayBetweenUpdates\n:\n \n2.0\n,\n// 2 seconds between updates\n\n    \ntimeoutAfterLastPing\n:\n \n6.0\n,\n// Stop sending updates 6 seconds after pings.\n\n\n});\n\n\n// Send driver configuration\n\n\nconfigSocket\n.\nsend\n(\nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\nencode\n(\nconfig\n).\nfinish\n());\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message, an empty string, will grant us a response from the \nData Update Port\n for the current UV value. An interval for pinging is then set to continuously obtain that data.\n\n// Create a Pusher socket\n\n\nvar\n \npingSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Keep-alive port\n\n\npingSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_uv_base_port\n \n+\n \n1\n));\n\n\n// Send initial ping\n\n\npingSocket\n.\nsend\n(\n);\n\n\n// Send ping every 5 seconds\n\n\nsetInterval\n(\nfunction\n(){\n\n    \npingSocket\n.\nsend\n(\n);\n\n\n},\n \n5000\n);\n\n\n\n\n\n\n\n\n\nError Port\nConnecting to the \nError Port\n is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE.\n\n// Create a Subscriber socket\n\n\nvar\n \nerrorSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_uv_base_port\n \n+\n \n2\n));\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nerrorSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nerror_message\n){\n\n    \nconsole\n.\nlog\n(\nError received: \n \n+\n \nerror_message\n.\ntoString\n(\nutf8\n));\n// Log error\n\n\n});\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n will allow us to receive the current UV data we want.\n\n\n// Create a Subscriber socket\n\n\nvar\n \nupdateSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Data Update port\n\n\nupdateSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_uv_base_port\n \n+\n \n3\n));\n\n\n// Subscribe to messages\n\n\nupdateSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nupdateSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nbuffer\n){\n\n    \nvar\n \ndata\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nsense\n.\nUV\n.\ndecode\n(\nbuffer\n);\n// Extract message\n\n    \nconsole\n.\nlog\n(\ndata\n);\n// Log new UV data\n\n\n});\n\n\n\n\nData Output\n\nThe javascript object below is an example output you'll receive from the \nData Update Port\n.\n\n{\n\n    \nuvIndex\n:\n \n0.0010000000474974513\n,\n\n    \nomsRisk\n:\n \nLow\n\n\n}", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-core/javascript-examples/uv/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/javascript-examples/uv/#overview", 
            "text": "The UV driver reports values for:   UV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization.  From  UV Index Scale  UV Risk scale established by World Health Organization. From  UV Index Scale", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/javascript-examples/uv/#code-example", 
            "text": "The following sections show how to implement a connection to each of the UV driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. var   zmq   =   require ( zeromq ); // Asynchronous Messaging Framework  var   matrix_io   =   require ( matrix-protos ). matrix_io ; // Protocol Buffers for MATRIX function  var   matrix_ip   =   127.0.0.1 ; // Local IP  var   matrix_uv_base_port   =   20029 ; // Port for UV driver     Base Port Here is where the configuration for our UV example goes. Once we connect to the  Base Port , We will pass a configuration to the UV driver. With this we can set the update rate and timeout configuration. // Create a Pusher socket  var   configSocket   =   zmq . socket ( push );  // Connect Pusher to Base port  configSocket . connect ( tcp://   +   matrix_ip   +   :   +   matrix_uv_base_port );  // Create driver configuration  var   config   =   matrix_io . malos . v1 . driver . DriverConfig . create ({ \n     // Update rate configuration \n     delayBetweenUpdates :   2.0 , // 2 seconds between updates \n     timeoutAfterLastPing :   6.0 , // Stop sending updates 6 seconds after pings.  });  // Send driver configuration  configSocket . send ( matrix_io . malos . v1 . driver . DriverConfig . encode ( config ). finish ());     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message, an empty string, will grant us a response from the  Data Update Port  for the current UV value. An interval for pinging is then set to continuously obtain that data. // Create a Pusher socket  var   pingSocket   =   zmq . socket ( push );  // Connect Pusher to Keep-alive port  pingSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_uv_base_port   +   1 ));  // Send initial ping  pingSocket . send ( );  // Send ping every 5 seconds  setInterval ( function (){ \n     pingSocket . send ( );  },   5000 );     Error Port Connecting to the  Error Port  is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. // Create a Subscriber socket  var   errorSocket   =   zmq . socket ( sub );  // Connect Subscriber to Error port  errorSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_uv_base_port   +   2 ));  // Connect Subscriber to Error port  errorSocket . subscribe ( );  // On Message  errorSocket . on ( message ,   function ( error_message ){ \n     console . log ( Error received:    +   error_message . toString ( utf8 )); // Log error  });     Data Update Port A connection to the  Data Update Port  will allow us to receive the current UV data we want.  // Create a Subscriber socket  var   updateSocket   =   zmq . socket ( sub );  // Connect Subscriber to Data Update port  updateSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_uv_base_port   +   3 ));  // Subscribe to messages  updateSocket . subscribe ( );  // On Message  updateSocket . on ( message ,   function ( buffer ){ \n     var   data   =   matrix_io . malos . v1 . sense . UV . decode ( buffer ); // Extract message \n     console . log ( data ); // Log new UV data  });", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/javascript-examples/servo/", 
            "text": "Servo\n\n\n\nJavascript Example\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe Servo driver can set the angle of your servos through the pins of your MATRIX device.\n\n\nDevice Pinouts\n:\n\n\n\n\nMATRIX Creator\n\n\nMATRIX Voice\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20045\n\n\nError port\n: 20047\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the Servo driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references.\n\nvar\n \nzmq\n \n=\n \nrequire\n(\nzeromq\n);\n// Asynchronous Messaging Framework\n\n\nvar\n \nmatrix_io\n \n=\n \nrequire\n(\nmatrix-protos\n).\nmatrix_io\n;\n// Protocol Buffers for MATRIX function\n\n\nvar\n \nmatrix_ip\n \n=\n \n127.0.0.1\n;\n// Local IP\n\n\nvar\n \nmatrix_servo_base_port\n \n=\n \n20045\n;\n// Port for Servo driver\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our servo example goes. Once we connect to the \nBase Port\n, We will pass a configuration to the servo driver. With this we can choose the pin we want to edit and the angle to set for it. This example will send random numbers to any servo attached to pin 0.\n\n\n// Create a Pusher socket\n\n\nvar\n \nconfigSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Base port\n\n\nconfigSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \nmatrix_servo_base_port\n);\n\n\n// Create driver configuration\n\n\nvar\n \nconfig\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\ncreate\n({\n\n\n// Create servo configuration\n\n\nservo\n:\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nio\n.\nServoParams\n.\ncreate\n({\n\n    \npin\n:\n \n0\n,\n// Use pin 0\n\n    \nangle\n:\n \n0\n// Set angle 0\n\n\n})\n\n\n});\n\n\n// Loop every second\n\n\nsetInterval\n(\nfunction\n(){\n\n\n// Pick number from 1-180\n\n\nvar\n \nangle\n \n=\n \nMath\n.\nfloor\n(\nMath\n.\nrandom\n()\n \n*\n \n180\n)\n+\n1\n;\n\n\n// Set number as new random angle\n\n\nconfig\n.\nservo\n.\nangle\n \n=\n \nangle\n;\n\n\n// Log angle\n\n\nconsole\n.\nlog\n(\nangle\n);\n\n\n// Send driver configuration\n\n\nconfigSocket\n.\nsend\n(\nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\nencode\n(\nconfig\n).\nfinish\n());\n\n\n},\n \n1000\n);\n\n\n\n\n\n\n\n\n\n\nError Port\nConnecting to the \nError Port\n is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE.\n\n// Create a Subscriber socket\n\n\nvar\n \nerrorSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_servo_base_port\n \n+\n \n2\n));\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nerrorSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nerror_message\n){\n\n\nconsole\n.\nlog\n(\nError received: \n \n+\n \nerror_message\n.\ntoString\n(\nutf8\n));\n// Log error\n\n\n});", 
            "title": "Servo"
        }, 
        {
            "location": "/matrix-core/javascript-examples/servo/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/javascript-examples/servo/#overview", 
            "text": "The Servo driver can set the angle of your servos through the pins of your MATRIX device.  Device Pinouts :   MATRIX Creator  MATRIX Voice", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/javascript-examples/servo/#code-example", 
            "text": "The following sections show how to implement a connection to each of the Servo driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. var   zmq   =   require ( zeromq ); // Asynchronous Messaging Framework  var   matrix_io   =   require ( matrix-protos ). matrix_io ; // Protocol Buffers for MATRIX function  var   matrix_ip   =   127.0.0.1 ; // Local IP  var   matrix_servo_base_port   =   20045 ; // Port for Servo driver     Base Port Here is where the configuration for our servo example goes. Once we connect to the  Base Port , We will pass a configuration to the servo driver. With this we can choose the pin we want to edit and the angle to set for it. This example will send random numbers to any servo attached to pin 0.  // Create a Pusher socket  var   configSocket   =   zmq . socket ( push );  // Connect Pusher to Base port  configSocket . connect ( tcp://   +   matrix_ip   +   :   +   matrix_servo_base_port );  // Create driver configuration  var   config   =   matrix_io . malos . v1 . driver . DriverConfig . create ({  // Create servo configuration  servo :   matrix_io . malos . v1 . io . ServoParams . create ({ \n     pin :   0 , // Use pin 0 \n     angle :   0 // Set angle 0  })  });  // Loop every second  setInterval ( function (){  // Pick number from 1-180  var   angle   =   Math . floor ( Math . random ()   *   180 ) + 1 ;  // Set number as new random angle  config . servo . angle   =   angle ;  // Log angle  console . log ( angle );  // Send driver configuration  configSocket . send ( matrix_io . malos . v1 . driver . DriverConfig . encode ( config ). finish ());  },   1000 );     Error Port Connecting to the  Error Port  is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. // Create a Subscriber socket  var   errorSocket   =   zmq . socket ( sub );  // Connect Subscriber to Error port  errorSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_servo_base_port   +   2 ));  // Connect Subscriber to Error port  errorSocket . subscribe ( );  // On Message  errorSocket . on ( message ,   function ( error_message ){  console . log ( Error received:    +   error_message . toString ( utf8 )); // Log error  });", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/javascript-examples/gpio/", 
            "text": "General Purpose Input Output (GPIO)\n\n\n\nJavascript Example\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe GPIO driver supports:\n\n\n\n\nReading pin input\n\n\nSetting pin output\n\n\n\n\nDevice Pinouts\n:\n\n\n\n\nMATRIX Creator\n\n\nMATRIX Voice\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20049\n\n\nKeep-alive port\n: 20050\n\n\nError port\n: 20051\n\n\nData Update port\n: 20052\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the GPIO driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references.\n\nvar\n \nzmq\n \n=\n \nrequire\n(\nzeromq\n);\n// Asynchronous Messaging Framework\n\n\nvar\n \nmatrix_io\n \n=\n \nrequire\n(\nmatrix-protos\n).\nmatrix_io\n;\n// Protocol Buffers for MATRIX function\n\n\nvar\n \nmatrix_ip\n \n=\n \n127.0.0.1\n;\n// Local IP\n\n\nvar\n \nmatrix_gpio_base_port\n \n=\n \n20049\n;\n// Port for GPIO driver\n\n\nvar\n \ncounter\n \n=\n \n1\n;\n// Counter for gpio value toggle \n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our GPIO example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the GPIO driver. With this, we can set the update rate, timeout, and pin configuration. This example will use \npin: 0\n and \ntoggle the pin state between on\noff\n through a \ntoggle()\n function.\n\n\n\n\nEach \npin\n will save its last set \nvalue\n until the next device boot.\n\n\n\n\n// Create a Pusher socket\n\n\nvar\n \nconfigSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Base port\n\n\nconfigSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \nmatrix_gpio_base_port\n);\n\n\n\n//Create driver configuration\n\n\nvar\n \noutputConfig\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\ncreate\n({\n\n\n// Update rate configuration\n\n\ndelayBetweenUpdates\n:\n \n2.0\n,\n// 2 seconds between updates\n\n\ntimeoutAfterLastPing\n:\n \n6.0\n,\n// Stop sending updates 6 seconds after pings.\n\n\n//GPIO Configuration\n\n\ngpio\n:\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nio\n.\nGpioParams\n.\ncreate\n({\n\n    \npin\n:\n \n0\n,\n// Use pin 0\n\n    \nmode\n:\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nio\n.\nGpioParams\n.\nEnumMode\n.\nOUTPUT\n,\n// Set as output mode\n\n    \nvalue\n:\n \n0\n// Set initial pin value as off\n\n\n})\n\n\n});\n\n\n\n//Function to toggle gpio value to 0 or 1\n\n\nfunction\n \ntoggle\n(){\n\n\noutputConfig\n.\ngpio\n.\nvalue\n \n=\n \ncounter\n%\n2\n;\n// Set pin value as 1 or 0\n\n\ncounter\n++\n;\n// increase counter\n\n\n// Send MATRIX configuration to MATRIX device\n\n\nconfigSocket\n.\nsend\n(\nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\nencode\n(\noutputConfig\n).\nfinish\n());\n\n\n}\n\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message, an empty string, will grant us a response from the \nData Update Port\n for the current GPIO pin values. An interval for pinging is then set to continuously obtain that data. The, previously defined, toggle function is also called to swap the pin state after a ping.\n\n// Create a Pusher socket\n\n\nvar\n \npingSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Keep-alive port\n\n\npingSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_gpio_base_port\n \n+\n \n1\n));\n\n\n// Send initial ping\n\n\npingSocket\n.\nsend\n(\n);\n\n\n// Send ping \n toggle pin value every 2 seconds\n\n\nsetInterval\n(\nfunction\n(){\n\n\npingSocket\n.\nsend\n(\n);\n// Send ping\n\n\ntoggle\n();\n// Change pin value\n\n\n},\n \n2000\n);\n\n\n\n\n\n\n\n\n\nError Port\nConnecting to the \nError Port\n is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE.\n\n// Create a Subscriber socket\n\n\nvar\n \nerrorSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_gpio_base_port\n \n+\n \n2\n));\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nerrorSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nerror_message\n){\n\n\nconsole\n.\nlog\n(\nError received: \n \n+\n \nerror_message\n.\ntoString\n(\nutf8\n));\n// Log error\n\n\n});\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n is then made to allow us to receive the current IMU data we want. The message received from the GPIO driver is converted into a 16 bit array, named \ngpioValues\n that represents each pin on your MATRIX device.\n\n\n// Create a Subscriber socket\n\n\nvar\n \nupdateSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Data Update port\n\n\nupdateSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_gpio_base_port\n \n+\n \n3\n));\n\n\n// Subscribe to messages\n\n\nupdateSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nupdateSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nbuffer\n){\n\n\n// Extract message\n\n\nvar\n \ndata\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nio\n.\nGpioParams\n.\ndecode\n(\nbuffer\n);\n\n\n// String value to represent all GPIO pins as off\n\n\nvar\n \nzeroPadding\n \n=\n \n0000000000000000\n;\n\n\n// Remove padding to make room for GPIO values\n\n\nvar\n \ngpioValues\n \n=\n \nzeroPadding\n.\nslice\n(\n0\n,\n \nzeroPadding\n.\nlength\n \n-\n \ndata\n.\nvalues\n.\ntoString\n(\n2\n).\nlength\n);\n\n\n// Convert GPIO values to 16-bit and add to string\n\n\ngpioValues\n \n=\n \ngpioValues\n.\nconcat\n(\ndata\n.\nvalues\n.\ntoString\n(\n2\n));\n\n\n// Convert string to chronologically ordered array\n\n\ngpioValues\n \n=\n \ngpioValues\n.\nsplit\n(\n).\nreverse\n();\n\n\n// Log GPIO pin states from gpioValues[0-15]\n\n\nconsole\n.\nlog\n(\nGPIO PINS--\n[0-15]\\n\n+\n[\n+\ngpioValues\n.\ntoString\n()\n+\n]\n);\n\n\n});\n\n\n\n\nData Output\n\nThe Javascript object below is an example output you'll receive from the \nData Update Port\n. For readability, the code above has converted the output as a 16-bit value and turned it into an array.\n\n{\n\n\nvalues\n:\n \n513\n\n\n}", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-core/javascript-examples/gpio/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/javascript-examples/gpio/#overview", 
            "text": "The GPIO driver supports:   Reading pin input  Setting pin output   Device Pinouts :   MATRIX Creator  MATRIX Voice", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/javascript-examples/gpio/#code-example", 
            "text": "The following sections show how to implement a connection to each of the GPIO driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. var   zmq   =   require ( zeromq ); // Asynchronous Messaging Framework  var   matrix_io   =   require ( matrix-protos ). matrix_io ; // Protocol Buffers for MATRIX function  var   matrix_ip   =   127.0.0.1 ; // Local IP  var   matrix_gpio_base_port   =   20049 ; // Port for GPIO driver  var   counter   =   1 ; // Counter for gpio value toggle      Base Port Here is where the configuration for our GPIO example goes. Once we connect to the  Base Port , we will pass a configuration to the GPIO driver. With this, we can set the update rate, timeout, and pin configuration. This example will use  pin: 0  and  toggle the pin state between on off  through a  toggle()  function.   Each  pin  will save its last set  value  until the next device boot.   // Create a Pusher socket  var   configSocket   =   zmq . socket ( push );  // Connect Pusher to Base port  configSocket . connect ( tcp://   +   matrix_ip   +   :   +   matrix_gpio_base_port );  //Create driver configuration  var   outputConfig   =   matrix_io . malos . v1 . driver . DriverConfig . create ({  // Update rate configuration  delayBetweenUpdates :   2.0 , // 2 seconds between updates  timeoutAfterLastPing :   6.0 , // Stop sending updates 6 seconds after pings.  //GPIO Configuration  gpio :   matrix_io . malos . v1 . io . GpioParams . create ({ \n     pin :   0 , // Use pin 0 \n     mode :   matrix_io . malos . v1 . io . GpioParams . EnumMode . OUTPUT , // Set as output mode \n     value :   0 // Set initial pin value as off  })  });  //Function to toggle gpio value to 0 or 1  function   toggle (){  outputConfig . gpio . value   =   counter % 2 ; // Set pin value as 1 or 0  counter ++ ; // increase counter  // Send MATRIX configuration to MATRIX device  configSocket . send ( matrix_io . malos . v1 . driver . DriverConfig . encode ( outputConfig ). finish ());  }     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message, an empty string, will grant us a response from the  Data Update Port  for the current GPIO pin values. An interval for pinging is then set to continuously obtain that data. The, previously defined, toggle function is also called to swap the pin state after a ping. // Create a Pusher socket  var   pingSocket   =   zmq . socket ( push );  // Connect Pusher to Keep-alive port  pingSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_gpio_base_port   +   1 ));  // Send initial ping  pingSocket . send ( );  // Send ping   toggle pin value every 2 seconds  setInterval ( function (){  pingSocket . send ( ); // Send ping  toggle (); // Change pin value  },   2000 );     Error Port Connecting to the  Error Port  is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. // Create a Subscriber socket  var   errorSocket   =   zmq . socket ( sub );  // Connect Subscriber to Error port  errorSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_gpio_base_port   +   2 ));  // Connect Subscriber to Error port  errorSocket . subscribe ( );  // On Message  errorSocket . on ( message ,   function ( error_message ){  console . log ( Error received:    +   error_message . toString ( utf8 )); // Log error  });     Data Update Port A connection to the  Data Update Port  is then made to allow us to receive the current IMU data we want. The message received from the GPIO driver is converted into a 16 bit array, named  gpioValues  that represents each pin on your MATRIX device.  // Create a Subscriber socket  var   updateSocket   =   zmq . socket ( sub );  // Connect Subscriber to Data Update port  updateSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_gpio_base_port   +   3 ));  // Subscribe to messages  updateSocket . subscribe ( );  // On Message  updateSocket . on ( message ,   function ( buffer ){  // Extract message  var   data   =   matrix_io . malos . v1 . io . GpioParams . decode ( buffer );  // String value to represent all GPIO pins as off  var   zeroPadding   =   0000000000000000 ;  // Remove padding to make room for GPIO values  var   gpioValues   =   zeroPadding . slice ( 0 ,   zeroPadding . length   -   data . values . toString ( 2 ). length );  // Convert GPIO values to 16-bit and add to string  gpioValues   =   gpioValues . concat ( data . values . toString ( 2 ));  // Convert string to chronologically ordered array  gpioValues   =   gpioValues . split ( ). reverse ();  // Log GPIO pin states from gpioValues[0-15]  console . log ( GPIO PINS-- [0-15]\\n + [ + gpioValues . toString () + ] );  });", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/javascript-examples/wakeword/", 
            "text": "Wakeword\n\n\n\nJavascript Example\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe Wakeword driver allows for:\n\n\n\n\nReading custom wakewords created with \nSphinx Knowledge Base\n.\n\n\nNotifications on which wakewords are heard.\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 60001\n\n\nError port\n: 60003\n\n\nData update port\n: 60004\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the Wakeword driver's ports. You can download this example \nhere\n.\n\n\n\n\n\n\n\nBefore moving on, please take a look at the Wakeword driver's protocol page and follow the \nInstallation\n \n \nCreating Custom Phrases\n sections.\n\n\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables and the path for our \nSphinx Knowledge Base\n files.\n\nvar\n \nmatrix_ip\n \n=\n \n127.0.0.1\n;\n// Local Device IP\n\n\nvar\n \nmatrix_wakeword_base_port\n \n=\n \n60001\n;\n \n// Wakeword base port\n\n\nvar\n \nmatrix_io\n \n=\n \nrequire\n(\nmatrix-protos\n).\nmatrix_io\n;\n// MATRIX Protocol Buffers\n\n\nvar\n \nzmq\n \n=\n \nrequire\n(\nzeromq\n);\n// Asynchronous Messaging Framework\n\n\nconst\n \nLM_PATH\n \n=\n \nINSERT_PATH_TO_YOUR_FILE.lm\n;\n// Language Model File\n\n\nconst\n \nDIC_PATH\n \n=\n \nINSERT_PATH_TO_YOUR_FILE.dic\n;\n// Dictation File\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our wakeword example goes. Once we connect to the \nBase Port\n, We will pass a configuration to the Wakeword driver. With this we can set our wakeword configurations.\n\n// Create a Pusher socket\n\n\nvar\n \nconfigSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Base port\n\n\nconfigSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \nmatrix_wakeword_base_port\n \n/* config */\n);\n\n\n// Create driver configuration\n\n\nvar\n \nconfig\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\ncreate\n(\n\n\n{\n \n// Create \n Set wakeword configurations\n\n\nwakeword\n:\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nio\n.\nWakeWordParams\n.\ncreate\n({\n\n    \nlmPath\n:\n \nLM_PATH\n,\n// Language model file path\n\n    \ndicPath\n:\n \nDIC_PATH\n,\n// Dictation file path\n\n    \nchannel\n:\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nio\n.\nWakeWordParams\n.\nMicChannel\n.\nchannel8\n,\n// Desired MATRIX microphone\n\n    \nenableVerbose\n:\n \nfalse\n// Enable verbose option\n\n\n})\n\n\n});\n\n\n// Send configuration to MATRIX device\n\n\nconfigSocket\n.\nsend\n(\nmatrix_io\n.\nmalos\n.\nv1\n.\ndriver\n.\nDriverConfig\n.\nencode\n(\nconfig\n).\nfinish\n());\n\n\nconsole\n.\nlog\n(\nListening for wakewords\n);\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message will grant us a response from the Data Update Port with the wake words that were understood.\n\n// Create a Pusher socket\n\n\nvar\n \npingSocket\n \n=\n \nzmq\n.\nsocket\n(\npush\n);\n\n\n// Connect Pusher to Keep-alive port\n\n\npingSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_wakeword_base_port\n \n+\n \n1\n));\n\n\n// Send initial ping\n\n\npingSocket\n.\nsend\n(\n);\n\n\n// Send a ping every 2 seconds\n\n\nsetInterval\n(\nfunction\n(){\n\n\npingSocket\n.\nsend\n(\n);\n// Send ping\n\n\n},\n \n2000\n);\n\n\n\n\n\n\n\n\n\nError Port\nConnecting to the \nError Port\n is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE.\n\n\n\n\nThe Error Port is currently reporting false errors. \n\n// Create a Subscriber socket\n\n\nvar\n \nerrorSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_wakeword_base_port\n \n+\n \n2\n));\n\n\n// Connect Subscriber to Error port\n\n\nerrorSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nerrorSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nerror_message\n){\n\n\n//console.log(\nError received: \n + error_message.toString(\nutf8\n));// Log error\n\n\n});\n\n\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n is then made to allow us to receive each custom phrase the Wakeword driver picks up.\n\n\n// Create a Subscriber socket\n\n\nvar\n \nupdateSocket\n \n=\n \nzmq\n.\nsocket\n(\nsub\n);\n\n\n// Connect Subscriber to Base port\n\n\nupdateSocket\n.\nconnect\n(\ntcp://\n \n+\n \nmatrix_ip\n \n+\n \n:\n \n+\n \n(\nmatrix_wakeword_base_port\n \n+\n \n3\n));\n\n\n// Subscribe to messages\n\n\nupdateSocket\n.\nsubscribe\n(\n);\n\n\n// On Message\n\n\nupdateSocket\n.\non\n(\nmessage\n,\n \nfunction\n(\nwakeword_buffer\n)\n \n{\n\n\n// Extract message\n\n\nvar\n \nwakeWordData\n \n=\n \nmatrix_io\n.\nmalos\n.\nv1\n.\nio\n.\nWakeWordParams\n.\ndecode\n(\nwakeword_buffer\n);\n\n\n// Log message\n\n\nconsole\n.\nlog\n(\nwakeWordData\n);\n\n\n// Run actions based on the phrase heard\n\n\nswitch\n(\nwakeWordData\n.\nwakeWord\n)\n \n{\n\n    \n// CHANGE TO YOUR PHRASE\n\n    \ncase\n \nMATRIX START\n:\n\n    \nconsole\n.\nlog\n(\nI HEARD MATRIX START!\n);\n\n    \nbreak\n;\n\n    \n// CHANGE TO YOUR PHRASE\n\n    \ncase\n \nMATRIX STOP\n:\n\n    \nconsole\n.\nlog\n(\nI HEARD MATRIX STOP!\n);\n\n    \nbreak\n;\n\n\n}\n\n\n});\n\n\n\n\nData Output\n\nThe javascript object below is an example output you'll receive from the \nData Update Port\n. All wakeword strings are capitalized.\n\n{\n\n\nWakeWordParams\n \n{\n \nwakeWord\n:\n \nMATRIX START\n \n}\n\n\n}", 
            "title": "Wakeword"
        }, 
        {
            "location": "/matrix-core/javascript-examples/wakeword/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/javascript-examples/wakeword/#overview", 
            "text": "The Wakeword driver allows for:   Reading custom wakewords created with  Sphinx Knowledge Base .  Notifications on which wakewords are heard.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/javascript-examples/wakeword/#code-example", 
            "text": "The following sections show how to implement a connection to each of the Wakeword driver's ports. You can download this example  here .    Before moving on, please take a look at the Wakeword driver's protocol page and follow the  Installation     Creating Custom Phrases  sections.    Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables and the path for our  Sphinx Knowledge Base  files. var   matrix_ip   =   127.0.0.1 ; // Local Device IP  var   matrix_wakeword_base_port   =   60001 ;   // Wakeword base port  var   matrix_io   =   require ( matrix-protos ). matrix_io ; // MATRIX Protocol Buffers  var   zmq   =   require ( zeromq ); // Asynchronous Messaging Framework  const   LM_PATH   =   INSERT_PATH_TO_YOUR_FILE.lm ; // Language Model File  const   DIC_PATH   =   INSERT_PATH_TO_YOUR_FILE.dic ; // Dictation File     Base Port Here is where the configuration for our wakeword example goes. Once we connect to the  Base Port , We will pass a configuration to the Wakeword driver. With this we can set our wakeword configurations. // Create a Pusher socket  var   configSocket   =   zmq . socket ( push );  // Connect Pusher to Base port  configSocket . connect ( tcp://   +   matrix_ip   +   :   +   matrix_wakeword_base_port   /* config */ );  // Create driver configuration  var   config   =   matrix_io . malos . v1 . driver . DriverConfig . create (  {   // Create   Set wakeword configurations  wakeword :   matrix_io . malos . v1 . io . WakeWordParams . create ({ \n     lmPath :   LM_PATH , // Language model file path \n     dicPath :   DIC_PATH , // Dictation file path \n     channel :   matrix_io . malos . v1 . io . WakeWordParams . MicChannel . channel8 , // Desired MATRIX microphone \n     enableVerbose :   false // Enable verbose option  })  });  // Send configuration to MATRIX device  configSocket . send ( matrix_io . malos . v1 . driver . DriverConfig . encode ( config ). finish ());  console . log ( Listening for wakewords );     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message will grant us a response from the Data Update Port with the wake words that were understood. // Create a Pusher socket  var   pingSocket   =   zmq . socket ( push );  // Connect Pusher to Keep-alive port  pingSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_wakeword_base_port   +   1 ));  // Send initial ping  pingSocket . send ( );  // Send a ping every 2 seconds  setInterval ( function (){  pingSocket . send ( ); // Send ping  },   2000 );     Error Port Connecting to the  Error Port  is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE.   The Error Port is currently reporting false errors.  // Create a Subscriber socket  var   errorSocket   =   zmq . socket ( sub );  // Connect Subscriber to Error port  errorSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_wakeword_base_port   +   2 ));  // Connect Subscriber to Error port  errorSocket . subscribe ( );  // On Message  errorSocket . on ( message ,   function ( error_message ){  //console.log( Error received:   + error_message.toString( utf8 ));// Log error  });      Data Update Port A connection to the  Data Update Port  is then made to allow us to receive each custom phrase the Wakeword driver picks up.  // Create a Subscriber socket  var   updateSocket   =   zmq . socket ( sub );  // Connect Subscriber to Base port  updateSocket . connect ( tcp://   +   matrix_ip   +   :   +   ( matrix_wakeword_base_port   +   3 ));  // Subscribe to messages  updateSocket . subscribe ( );  // On Message  updateSocket . on ( message ,   function ( wakeword_buffer )   {  // Extract message  var   wakeWordData   =   matrix_io . malos . v1 . io . WakeWordParams . decode ( wakeword_buffer );  // Log message  console . log ( wakeWordData );  // Run actions based on the phrase heard  switch ( wakeWordData . wakeWord )   { \n     // CHANGE TO YOUR PHRASE \n     case   MATRIX START : \n     console . log ( I HEARD MATRIX START! ); \n     break ; \n     // CHANGE TO YOUR PHRASE \n     case   MATRIX STOP : \n     console . log ( I HEARD MATRIX STOP! ); \n     break ;  }  });", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/python-examples/", 
            "text": "Python Examples\n\n\nEverloop\n\nLED interface.\n\n\nHumidity\n\n\n\nHumidity and temperature measurement.\n\n\nIMU\n\n\n\nInertial Measurement Unit.\n\n\nPressure\n\n\n\nPressure, altitude and temperature measurement.\n\n\nUV\n\n\n\nUltraviolet light sensor.\n\n\nServo\n\n\n\nAdjust servo positions.\n\n\nGPIO\n\n\n\nGeneral Purpose Input/Output.\n\n\nWakeword\n\n\n\nCreate custom voice commands with Pocket Sphinx.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-core/python-examples/#python-examples", 
            "text": "", 
            "title": "Python Examples"
        }, 
        {
            "location": "/matrix-core/python-examples/everloop/", 
            "text": "Everloop\n\n\n\nPython Example\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe Everloop driver allows for:\n\n\n\n\nReading amount of LEDs your MATRIX device has.\n\n\nSetting the RGBW colors for each individual LED.\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20021\n\n\nKeep-alive port\n: 20022\n\n\nError port\n: 20023\n\n\nData update port\n: 20024\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the Everloop driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references.\n\nimport\n \nos\n \n# Miscellaneous operating system interface\n\n\nimport\n \nzmq\n \n# Asynchronous messaging framework\n\n\nimport\n \ntime\n \n# Time access and conversions\n\n\nfrom\n \nrandom\n \nimport\n \nrandint\n \n# Random numbers\n\n\nimport\n \nsys\n \n# System-specific parameters and functions\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \ndriver_pb2\n \n# MATRIX Protocol Buffer driver library\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \nio_pb2\n \n# MATRIX Protocol Buffer sensor library\n\n\nfrom\n \nmultiprocessing\n \nimport\n \nProcess\n,\n \nManager\n,\n \nValue\n \n# Allow for multiple processes at once\n\n\nfrom\n \nzmq.eventloop\n \nimport\n \nioloop\n,\n \nzmqstream\n# Asynchronous events through ZMQ\n\n\nmatrix_ip\n \n=\n \n127.0.0.1\n \n# Local device ip\n\n\neverloop_port\n \n=\n \n20021\n \n# Driver Base port\n\n\nled_count\n \n=\n \n0\n \n# Amount of LEDs on MATRIX device\n\n\n# Handy function for connecting to the Error port \n\n\nfrom\n \nutils\n \nimport\n \nregister_error_callback\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our Everloop example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the Everloop driver. With this we can set the LED configuration. The \nwhile True\n loop is used to show how you can rapidly push different LED colors.\n\ndef\n \nconfig_socket\n(\nledCount\n):\n  \n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Pusher socket\n\n    \nsocket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n    \n# Connect Pusher to configuration socket\n\n    \nsocket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \neverloop_port\n))\n\n\n    \n# Loop forever\n\n    \nwhile\n \nTrue\n:\n\n        \n# Create a new driver config\n\n        \ndriver_config_proto\n \n=\n \ndriver_pb2\n.\nDriverConfig\n()\n\n        \n# Create an empty Everloop image\n\n        \nimage\n \n=\n \n[]\n\n        \n# For each device LED\n\n        \nfor\n \nled\n \nin\n \nrange\n(\nledCount\n):\n\n            \n# Set individual LED value\n\n            \nledValue\n \n=\n \nio_pb2\n.\nLedValue\n()\n\n            \nledValue\n.\nblue\n \n=\n \nrandint\n(\n0\n,\n \n50\n)\n\n            \nledValue\n.\nred\n \n=\n \nrandint\n(\n0\n,\n \n200\n)\n\n            \nledValue\n.\ngreen\n \n=\n \nrandint\n(\n0\n,\n \n255\n)\n\n            \nledValue\n.\nwhite\n \n=\n \n0\n\n            \nimage\n.\nappend\n(\nledValue\n)\n\n        \n# Store the Everloop image in driver configuration\n\n        \ndriver_config_proto\n.\nimage\n.\nled\n.\nextend\n(\nimage\n)\n\n\n        \n# Send driver configuration through ZMQ socket\n\n        \nsocket\n.\nsend\n(\ndriver_config_proto\n.\nSerializeToString\n())\n\n        \n# Wait before restarting loop\n\n        \ntime\n.\nsleep\n(\n0.05\n)\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message will grant us a response from the \nData Update Port\n for the current LED count of your MATRIX device. The code below will give only send one ping because LED count will not change.\n\ndef\n \nping_socket\n():\n\n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Pusher socket\n\n    \nping_socket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n    \n# Connect to the socket\n\n    \nping_socket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \neverloop_port\n+\n1\n))\n\n    \n# Send one ping\n\n    \nping_socket\n.\nsend_string\n(\n)\n\n\n\n\n\n\n\n\n\nError Port\nThe \nError Port\n connection is taken care of by the \nutils import\n. Below we define a function to be called and given any error messages that occur within MATRIX CORE.\n\ndef\n \neverloop_error_callback\n(\nerror\n):\n\n    \n# Log error\n\n    \nprint\n(\n{0}\n.\nformat\n(\nerror\n))\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n will allow us to receive the current LED count on your MATRIX device. Once we connect to the port, the \nupdateLedCount\n function will pass the LED count to a global variable and then close the connection the \nData-update Port\n.\n\n\ndef\n \nupdate_socket\n():\n\n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Subscriber socket\n\n    \nsocket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nSUB\n)\n\n    \n# Connect to the Data Update port\n\n    \nsocket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \neverloop_port\n+\n3\n))\n\n    \n# Connect Subscriber to Error port\n\n    \nsocket\n.\nsetsockopt\n(\nzmq\n.\nSUBSCRIBE\n,\n \nb\n)\n\n    \n# Create the stream to listen to data from port\n\n    \nstream\n \n=\n \nzmqstream\n.\nZMQStream\n(\nsocket\n)\n\n\n    \n# Function to update LED count and close connection to the Data Update Port\n\n    \ndef\n \nupdateLedCount\n(\ndata\n):\n\n        \n# Extract data and pass into led_count global variable\n\n        \nglobal\n \nled_count\n\n        \nled_count\n \n=\n \nio_pb2\n.\nLedValue\n()\n.\nFromString\n(\ndata\n[\n0\n])\n.\ngreen\n\n        \n# Log LEDs\n\n        \nprint\n(\n{0} LEDs counted\n.\nformat\n(\nled_count\n))\n\n        \n# If LED count obtained\n\n        \nif\n \nled_count\n \n \n0\n:\n\n            \n# Close Data Update Port connection\n\n            \nioloop\n.\nIOLoop\n.\ninstance\n()\n.\nstop\n()\n\n            \nprint\n(\nLED count obtained. Disconnecting from data publisher {0}\n.\nformat\n(\neverloop_port\n+\n3\n))\n\n    \n# Call updateLedCount() once data is received\n\n    \nstream\n.\non_recv\n(\nupdateLedCount\n)\n\n\n    \n# Log and begin event loop for ZMQ connection to Data Update Port\n\n    \nprint\n(\nConnected to data publisher with port {0}\n.\nformat\n(\neverloop_port\n+\n3\n))\n\n    \nioloop\n.\nIOLoop\n.\ninstance\n()\n.\nstart\n()\n\n\n\n\nData Output\n\nThe Python object below is an example output you'll receive from the \nData Update Port\n.\n\n\n\n\nThe output name will be changed in a following update\n\ngreen\n:\n \n18\n\n\n\n\n\n\n\n\n\n\n\nStart Processes\nThis is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port. This example is only using the \nError Port\n connection asynchronously because the \nKeep-alive Port\n and \nData-update Port\n are only used once.\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \n# Initiate asynchronous events\n\n    \nioloop\n.\ninstall\n()\n\n    \n# Start Error Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_error_callback\n,\n \nargs\n=\n(\neverloop_error_callback\n,\n \nmatrix_ip\n,\n \neverloop_port\n))\n.\nstart\n()\n    \n    \n# Ping the Keep-alive Port once\n\n    \nping_socket\n()\n\n    \n# Start Data Update Port connection \n close after response\n\n    \nupdate_socket\n()\n\n    \n# Send Base Port configuration\n\n    \ntry\n:\n\n        \nconfig_socket\n(\nled_count\n)\n\n    \n# Avoid logging Everloop errors on user quiting\n\n    \nexcept\n \nKeyboardInterrupt\n:\n\n        \nprint\n(\n quit\n)", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-core/python-examples/everloop/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/python-examples/everloop/#overview", 
            "text": "The Everloop driver allows for:   Reading amount of LEDs your MATRIX device has.  Setting the RGBW colors for each individual LED.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/python-examples/everloop/#code-example", 
            "text": "The following sections show how to implement a connection to each of the Everloop driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. import   os   # Miscellaneous operating system interface  import   zmq   # Asynchronous messaging framework  import   time   # Time access and conversions  from   random   import   randint   # Random numbers  import   sys   # System-specific parameters and functions  from   matrix_io.proto.malos.v1   import   driver_pb2   # MATRIX Protocol Buffer driver library  from   matrix_io.proto.malos.v1   import   io_pb2   # MATRIX Protocol Buffer sensor library  from   multiprocessing   import   Process ,   Manager ,   Value   # Allow for multiple processes at once  from   zmq.eventloop   import   ioloop ,   zmqstream # Asynchronous events through ZMQ  matrix_ip   =   127.0.0.1   # Local device ip  everloop_port   =   20021   # Driver Base port  led_count   =   0   # Amount of LEDs on MATRIX device  # Handy function for connecting to the Error port   from   utils   import   register_error_callback     Base Port Here is where the configuration for our Everloop example goes. Once we connect to the  Base Port , we will pass a configuration to the Everloop driver. With this we can set the LED configuration. The  while True  loop is used to show how you can rapidly push different LED colors. def   config_socket ( ledCount ):   \n     # Define zmq socket \n     context   =   zmq . Context () \n     # Create a Pusher socket \n     socket   =   context . socket ( zmq . PUSH ) \n     # Connect Pusher to configuration socket \n     socket . connect ( tcp://{0}:{1} . format ( matrix_ip ,   everloop_port )) \n\n     # Loop forever \n     while   True : \n         # Create a new driver config \n         driver_config_proto   =   driver_pb2 . DriverConfig () \n         # Create an empty Everloop image \n         image   =   [] \n         # For each device LED \n         for   led   in   range ( ledCount ): \n             # Set individual LED value \n             ledValue   =   io_pb2 . LedValue () \n             ledValue . blue   =   randint ( 0 ,   50 ) \n             ledValue . red   =   randint ( 0 ,   200 ) \n             ledValue . green   =   randint ( 0 ,   255 ) \n             ledValue . white   =   0 \n             image . append ( ledValue ) \n         # Store the Everloop image in driver configuration \n         driver_config_proto . image . led . extend ( image ) \n\n         # Send driver configuration through ZMQ socket \n         socket . send ( driver_config_proto . SerializeToString ()) \n         # Wait before restarting loop \n         time . sleep ( 0.05 )     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message will grant us a response from the  Data Update Port  for the current LED count of your MATRIX device. The code below will give only send one ping because LED count will not change. def   ping_socket (): \n     # Define zmq socket \n     context   =   zmq . Context () \n     # Create a Pusher socket \n     ping_socket   =   context . socket ( zmq . PUSH ) \n     # Connect to the socket \n     ping_socket . connect ( tcp://{0}:{1} . format ( matrix_ip ,   everloop_port + 1 )) \n     # Send one ping \n     ping_socket . send_string ( )     Error Port The  Error Port  connection is taken care of by the  utils import . Below we define a function to be called and given any error messages that occur within MATRIX CORE. def   everloop_error_callback ( error ): \n     # Log error \n     print ( {0} . format ( error ))     Data Update Port A connection to the  Data Update Port  will allow us to receive the current LED count on your MATRIX device. Once we connect to the port, the  updateLedCount  function will pass the LED count to a global variable and then close the connection the  Data-update Port .  def   update_socket (): \n     # Define zmq socket \n     context   =   zmq . Context () \n     # Create a Subscriber socket \n     socket   =   context . socket ( zmq . SUB ) \n     # Connect to the Data Update port \n     socket . connect ( tcp://{0}:{1} . format ( matrix_ip ,   everloop_port + 3 )) \n     # Connect Subscriber to Error port \n     socket . setsockopt ( zmq . SUBSCRIBE ,   b ) \n     # Create the stream to listen to data from port \n     stream   =   zmqstream . ZMQStream ( socket ) \n\n     # Function to update LED count and close connection to the Data Update Port \n     def   updateLedCount ( data ): \n         # Extract data and pass into led_count global variable \n         global   led_count \n         led_count   =   io_pb2 . LedValue () . FromString ( data [ 0 ]) . green \n         # Log LEDs \n         print ( {0} LEDs counted . format ( led_count )) \n         # If LED count obtained \n         if   led_count     0 : \n             # Close Data Update Port connection \n             ioloop . IOLoop . instance () . stop () \n             print ( LED count obtained. Disconnecting from data publisher {0} . format ( everloop_port + 3 )) \n     # Call updateLedCount() once data is received \n     stream . on_recv ( updateLedCount ) \n\n     # Log and begin event loop for ZMQ connection to Data Update Port \n     print ( Connected to data publisher with port {0} . format ( everloop_port + 3 )) \n     ioloop . IOLoop . instance () . start ()", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/python-examples/humidity/", 
            "text": "Humidity\n\n\n\nPython Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe Humidity driver allows for:\n\n\n\n\nReading relative humidity on the board\n\n\nObtaining temperature in Celsius and raw values\n\n\nCalibrating temperature\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20017\n\n\nKeep-alive port\n: 20018\n\n\nError port\n: 20019\n\n\nData update port\n: 20020\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the Humidity driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references.\n\nimport\n \nos\n \n# Miscellaneous operating system interface\n\n\nimport\n \nzmq\n \n# Asynchronous messaging framework\n\n\nimport\n \ntime\n \n# Time access and conversions\n\n\nimport\n \nsys\n \n# System-specific parameters and functions\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \ndriver_pb2\n \n# MATRIX Protocol Buffer driver library\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \nsense_pb2\n \n# MATRIX Protocol Buffer sensor library\n\n\nfrom\n \nmultiprocessing\n \nimport\n \nProcess\n \n# Allow for multiple processes at once\n\n\nfrom\n \nzmq.eventloop\n \nimport\n \nioloop\n \n# Asynchronous events through ZMQ\n\n\nmatrix_ip\n \n=\n \n127.0.0.1\n \n# Local device ip\n\n\nhumidity_port\n \n=\n \n20017\n \n# Driver Base port\n\n\n# Handy functions for connecting to the keep-Alive, Data Update, \n Error port \n\n\nfrom\n \nutils\n \nimport\n \ndriver_keep_alive\n,\n \nregister_data_callback\n,\n \nregister_error_callback\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our humidity example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the humidity driver. With this we can set the update rate, timeout, and temperature configuration.\n\ndef\n \nconfig_socket\n():\n\n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Pusher socket\n\n    \nsocket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n    \n# Connect Pusher to configuration socket\n\n    \nsocket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \nhumidity_port\n))\n\n\n    \n# Create a new driver config\n\n    \ndriver_config_proto\n \n=\n \ndriver_pb2\n.\nDriverConfig\n()\n\n    \n# Delay between updates in seconds\n\n    \ndriver_config_proto\n.\ndelay_between_updates\n \n=\n \n2.0\n\n    \n# Timeout after last ping\n\n    \ndriver_config_proto\n.\ntimeout_after_last_ping\n \n=\n \n6.0\n\n    \n# Current temperature in Celsius for calibration\n\n    \ndriver_config_proto\n.\nhumidity\n.\ncurrent_temperature\n \n=\n \n23\n\n\n    \n# Send driver configuration through ZMQ socket\n\n    \nsocket\n.\nsend\n(\ndriver_config_proto\n.\nSerializeToString\n())\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message will grant us a response from the \nData Update Port\n for the current humidity value. The \nutils import\n from the \nInitial Variables\n section takes care of this.\n\n\n\n\n\n\n\nError Port\nThe \nError Port\n connection is also taken care of by the \nutils import\n. Below we define a function to be called and given any error messages that occur within MATRIX CORE.\n\ndef\n \nhumidity_error_callback\n(\nerror\n):\n\n    \n# Log error\n\n    \nprint\n(\n{0}\n.\nformat\n(\nerror\n))\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n will allow us to receive the current humidity data we want. The \nutils import\n takes care of this as well. We can define a function and expect humidity data to be passed to it.\n\n\ndef\n \nhumidity_data_callback\n(\ndata\n):\n\n    \n# Extract data\n\n    \ndata\n \n=\n \nsense_pb2\n.\nHumidity\n()\n.\nFromString\n(\ndata\n[\n0\n])\n\n    \n# Log data \n\n    \nprint\n(\n{0}\n.\nformat\n(\ndata\n))\n\n\n\n\nData Output\n\nThe Python object below is an example output you'll receive from the \nData Update Port\n.\n\nhumidity\n:\n \n29.0049991608\n\n\ntemperature\n:\n \n23.4913063049\n\n\ntemperature_raw\n:\n \n33.1269989014\n\n\ntemperature_is_calibrated\n:\n \ntrue\n\n\n\n\n\n\n\n\n\nStart Processes\nThis is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port.\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \n# Initiate asynchronous events\n\n    \nioloop\n.\ninstall\n()\n\n    \n# Send Base Port configuration \n\n    \nconfig_socket\n()\n\n    \n# Start Error Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_error_callback\n,\n \nargs\n=\n(\nhumidity_error_callback\n,\n \nmatrix_ip\n,\n \nhumidity_port\n))\n.\nstart\n()\n\n    \n# Start Data Update Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_data_callback\n,\n \nargs\n=\n(\nhumidity_data_callback\n,\n \nmatrix_ip\n,\n \nhumidity_port\n))\n.\nstart\n()\n\n    \n# Start Keep-alive Port connection\n\n    \nProcess\n(\ntarget\n=\ndriver_keep_alive\n,\n \nargs\n=\n(\nmatrix_ip\n,\n \nhumidity_port\n))\n.\nstart\n()", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-core/python-examples/humidity/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/python-examples/humidity/#overview", 
            "text": "The Humidity driver allows for:   Reading relative humidity on the board  Obtaining temperature in Celsius and raw values  Calibrating temperature", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/python-examples/humidity/#code-example", 
            "text": "The following sections show how to implement a connection to each of the Humidity driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. import   os   # Miscellaneous operating system interface  import   zmq   # Asynchronous messaging framework  import   time   # Time access and conversions  import   sys   # System-specific parameters and functions  from   matrix_io.proto.malos.v1   import   driver_pb2   # MATRIX Protocol Buffer driver library  from   matrix_io.proto.malos.v1   import   sense_pb2   # MATRIX Protocol Buffer sensor library  from   multiprocessing   import   Process   # Allow for multiple processes at once  from   zmq.eventloop   import   ioloop   # Asynchronous events through ZMQ  matrix_ip   =   127.0.0.1   # Local device ip  humidity_port   =   20017   # Driver Base port  # Handy functions for connecting to the keep-Alive, Data Update,   Error port   from   utils   import   driver_keep_alive ,   register_data_callback ,   register_error_callback     Base Port Here is where the configuration for our humidity example goes. Once we connect to the  Base Port , we will pass a configuration to the humidity driver. With this we can set the update rate, timeout, and temperature configuration. def   config_socket (): \n     # Define zmq socket \n     context   =   zmq . Context () \n     # Create a Pusher socket \n     socket   =   context . socket ( zmq . PUSH ) \n     # Connect Pusher to configuration socket \n     socket . connect ( tcp://{0}:{1} . format ( matrix_ip ,   humidity_port )) \n\n     # Create a new driver config \n     driver_config_proto   =   driver_pb2 . DriverConfig () \n     # Delay between updates in seconds \n     driver_config_proto . delay_between_updates   =   2.0 \n     # Timeout after last ping \n     driver_config_proto . timeout_after_last_ping   =   6.0 \n     # Current temperature in Celsius for calibration \n     driver_config_proto . humidity . current_temperature   =   23 \n\n     # Send driver configuration through ZMQ socket \n     socket . send ( driver_config_proto . SerializeToString ())     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message will grant us a response from the  Data Update Port  for the current humidity value. The  utils import  from the  Initial Variables  section takes care of this.    Error Port The  Error Port  connection is also taken care of by the  utils import . Below we define a function to be called and given any error messages that occur within MATRIX CORE. def   humidity_error_callback ( error ): \n     # Log error \n     print ( {0} . format ( error ))     Data Update Port A connection to the  Data Update Port  will allow us to receive the current humidity data we want. The  utils import  takes care of this as well. We can define a function and expect humidity data to be passed to it.  def   humidity_data_callback ( data ): \n     # Extract data \n     data   =   sense_pb2 . Humidity () . FromString ( data [ 0 ]) \n     # Log data  \n     print ( {0} . format ( data ))", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/python-examples/imu/", 
            "text": "Inertial Measurement Unit (IMU)\n\n\n\nPython Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe IMU driver reports values for:\n\n\n\n\nYaw, Pitch, and Roll\n\n\nAcceleration for \nx\n, \ny\n, \nz\n axes\n\n\nGyroscope for \nx\n, \ny\n, \nz\n axes\n\n\nMagnetometer for \nx\n, \ny\n, \nz\n axes\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20013\n\n\nKeep-alive port\n: 20014\n\n\nError port\n: 20015\n\n\nData Update port\n: 20016\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the IMU driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references.\n\nimport\n \nos\n \n# Miscellaneous operating system interface\n\n\nimport\n \nzmq\n \n# Asynchronous messaging framework\n\n\nimport\n \ntime\n \n# Time access and conversions\n\n\nimport\n \nsys\n \n# System-specific parameters and functions\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \ndriver_pb2\n \n# MATRIX Protocol Buffer driver library\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \nsense_pb2\n \n# MATRIX Protocol Buffer sensor library\n\n\nfrom\n \nmultiprocessing\n \nimport\n \nProcess\n \n# Allow for multiple processes at once\n\n\nfrom\n \nzmq.eventloop\n \nimport\n \nioloop\n \n# Asynchronous events through ZMQ\n\n\nmatrix_ip\n \n=\n \n127.0.0.1\n \n# Local device ip\n\n\nimu_port\n \n=\n \n20013\n \n# Driver Base port\n\n\n# Handy functions for connecting to the keep-Alive, Data Update, \n Error port \n\n\nfrom\n \nutils\n \nimport\n \ndriver_keep_alive\n,\n \nregister_data_callback\n,\n \nregister_error_callback\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our IMU example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the IMU driver. With this we can set the update rate, timeout, and temperature configuration.\n\ndef\n \nconfig_socket\n():\n\n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Pusher socket\n\n    \nsocket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n    \n# Connect Pusher to configuration socket\n\n    \nsocket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \nimu_port\n))\n\n\n    \n# Create a new driver config\n\n    \ndriver_config_proto\n \n=\n \ndriver_pb2\n.\nDriverConfig\n()\n\n    \n# Delay between updates in seconds\n\n    \ndriver_config_proto\n.\ndelay_between_updates\n \n=\n \n0.05\n\n    \n# Timeout after last ping\n\n    \ndriver_config_proto\n.\ntimeout_after_last_ping\n \n=\n \n6.0\n\n\n    \n# Send driver configuration through ZMQ socket\n\n    \nsocket\n.\nsend\n(\ndriver_config_proto\n.\nSerializeToString\n())\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message will grant us a response from the \nData Update Port\n for the current IMU value. The \nutils import\n from the \nInitial Variables\n section takes care of this.\n\n\n\n\n\n\n\nError Port\nThe \nError Port\n connection is also taken care of by the \nutils import\n. Below we define a function to be called and given any error messages that occur within MATRIX CORE.\n\ndef\n \nimu_error_callback\n(\nerror\n):\n\n    \n# Log error\n\n    \nprint\n(\n{0}\n.\nformat\n(\nerror\n))\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n will allow us to receive the current IMU data we want. The \nutils import\n takes care of this as well. We can define a function and expect IMU data to be passed to it.\n\n\ndef\n \nimu_data_callback\n(\ndata\n):\n\n    \n# Extract data\n\n    \ndata\n \n=\n \nsense_pb2\n.\nImu\n()\n.\nFromString\n(\ndata\n[\n0\n])\n\n    \n# Log data \n\n    \nprint\n(\n{0}\n.\nformat\n(\ndata\n))\n\n\n\n\nData Output\n\nThe Python object below is an example output you'll receive from the \nData Update Port\n.\n\nyaw\n:\n \n151.336044312\n\n\nroll\n:\n \n0.174327388406\n\n\naccel_y\n:\n \n0.00300000002608\n\n\naccel_z\n:\n \n0.986000001431\n\n\ngyro_x\n:\n \n2.58599996567\n\n\ngyro_y\n:\n \n0.0289999991655\n\n\ngyro_z\n:\n \n0.84399998188\n\n\nmag_x\n:\n \n0.300000011921\n\n\nmag_y\n:\n \n0.16400000453\n\n\nmag_z\n:\n \n-\n0.0780000016093\n\n\n\n\n\n\n\n\n\nStart Processes\nThis is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port.\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \n# Initiate asynchronous events\n\n    \nioloop\n.\ninstall\n()\n\n    \n# Send Base Port configuration \n\n    \nconfig_socket\n()\n\n    \n# Start Error Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_error_callback\n,\n \nargs\n=\n(\nimu_error_callback\n,\n \nmatrix_ip\n,\n \nimu_port\n))\n.\nstart\n()\n\n    \n# Start Data Update Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_data_callback\n,\n \nargs\n=\n(\nimu_data_callback\n,\n \nmatrix_ip\n,\n \nimu_port\n))\n.\nstart\n()\n\n    \n# Start Keep-alive Port connection\n\n    \nProcess\n(\ntarget\n=\ndriver_keep_alive\n,\n \nargs\n=\n(\nmatrix_ip\n,\n \nimu_port\n))\n.\nstart\n()", 
            "title": "IMU"
        }, 
        {
            "location": "/matrix-core/python-examples/imu/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/python-examples/imu/#overview", 
            "text": "The IMU driver reports values for:   Yaw, Pitch, and Roll  Acceleration for  x ,  y ,  z  axes  Gyroscope for  x ,  y ,  z  axes  Magnetometer for  x ,  y ,  z  axes", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/python-examples/imu/#code-example", 
            "text": "The following sections show how to implement a connection to each of the IMU driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. import   os   # Miscellaneous operating system interface  import   zmq   # Asynchronous messaging framework  import   time   # Time access and conversions  import   sys   # System-specific parameters and functions  from   matrix_io.proto.malos.v1   import   driver_pb2   # MATRIX Protocol Buffer driver library  from   matrix_io.proto.malos.v1   import   sense_pb2   # MATRIX Protocol Buffer sensor library  from   multiprocessing   import   Process   # Allow for multiple processes at once  from   zmq.eventloop   import   ioloop   # Asynchronous events through ZMQ  matrix_ip   =   127.0.0.1   # Local device ip  imu_port   =   20013   # Driver Base port  # Handy functions for connecting to the keep-Alive, Data Update,   Error port   from   utils   import   driver_keep_alive ,   register_data_callback ,   register_error_callback     Base Port Here is where the configuration for our IMU example goes. Once we connect to the  Base Port , we will pass a configuration to the IMU driver. With this we can set the update rate, timeout, and temperature configuration. def   config_socket (): \n     # Define zmq socket \n     context   =   zmq . Context () \n     # Create a Pusher socket \n     socket   =   context . socket ( zmq . PUSH ) \n     # Connect Pusher to configuration socket \n     socket . connect ( tcp://{0}:{1} . format ( matrix_ip ,   imu_port )) \n\n     # Create a new driver config \n     driver_config_proto   =   driver_pb2 . DriverConfig () \n     # Delay between updates in seconds \n     driver_config_proto . delay_between_updates   =   0.05 \n     # Timeout after last ping \n     driver_config_proto . timeout_after_last_ping   =   6.0 \n\n     # Send driver configuration through ZMQ socket \n     socket . send ( driver_config_proto . SerializeToString ())     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message will grant us a response from the  Data Update Port  for the current IMU value. The  utils import  from the  Initial Variables  section takes care of this.    Error Port The  Error Port  connection is also taken care of by the  utils import . Below we define a function to be called and given any error messages that occur within MATRIX CORE. def   imu_error_callback ( error ): \n     # Log error \n     print ( {0} . format ( error ))     Data Update Port A connection to the  Data Update Port  will allow us to receive the current IMU data we want. The  utils import  takes care of this as well. We can define a function and expect IMU data to be passed to it.  def   imu_data_callback ( data ): \n     # Extract data \n     data   =   sense_pb2 . Imu () . FromString ( data [ 0 ]) \n     # Log data  \n     print ( {0} . format ( data ))", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/python-examples/pressure/", 
            "text": "Pressure\n\n\n\nPython Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe Pressure driver reports values for:\n\n\n\n\nPressure\n\n\nAltitude\n\n\nTemperature\n\n\n\n\n\n\nBased on component location, the temperature values from the \nHumidity driver\n are recommended over the Pressure driver\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20025\n\n\nKeep-alive port\n: 20026\n\n\nError port\n: 20027\n\n\nData Update port\n: 20028\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the Pressure driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references.\n\nimport\n \nos\n \n# Miscellaneous operating system interface\n\n\nimport\n \nzmq\n \n# Asynchronous messaging framework\n\n\nimport\n \ntime\n \n# Time access and conversions\n\n\nimport\n \nsys\n \n# System-specific parameters and functions\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \ndriver_pb2\n \n# MATRIX Protocol Buffer driver library\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \nsense_pb2\n \n# MATRIX Protocol Buffer sensor library\n\n\nfrom\n \nmultiprocessing\n \nimport\n \nProcess\n \n# Allow for multiple processes at once\n\n\nfrom\n \nzmq.eventloop\n \nimport\n \nioloop\n \n# Asynchronous events through ZMQ\n\n\nmatrix_ip\n \n=\n \n127.0.0.1\n \n# Local device ip\n\n\npressure_port\n \n=\n \n20025\n \n# Driver Base port\n\n\n# Handy functions for connecting to the keep-Alive, Data Update, \n Error port \n\n\nfrom\n \nutils\n \nimport\n \ndriver_keep_alive\n,\n \nregister_data_callback\n,\n \nregister_error_callback\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our pressure example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the pressure driver. With this we can set the update rate, timeout, and temperature configuration.\n\ndef\n \nconfig_socket\n():\n\n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Pusher socket\n\n    \nsocket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n    \n# Connect Pusher to configuration socket\n\n    \nsocket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \npressure_port\n))\n\n\n    \n# Create a new driver config\n\n    \ndriver_config_proto\n \n=\n \ndriver_pb2\n.\nDriverConfig\n()\n\n    \n# Delay between updates in seconds\n\n    \ndriver_config_proto\n.\ndelay_between_updates\n \n=\n \n1.0\n\n    \n# Timeout after last ping\n\n    \ndriver_config_proto\n.\ntimeout_after_last_ping\n \n=\n \n6.0\n\n\n    \n# Send driver configuration through ZMQ socket\n\n    \nsocket\n.\nsend\n(\ndriver_config_proto\n.\nSerializeToString\n())\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message will grant us a response from the \nData Update Port\n for the current pressure value. The \nutils import\n from the \nInitial Variables\n section takes care of this.\n\n\n\n\n\n\n\nError Port\nThe \nError Port\n connection is also taken care of by the \nutils import\n. Below we define a function to be called and given any error messages that occur within MATRIX CORE.\n\ndef\n \npressure_error_callback\n(\nerror\n):\n\n    \n# Log error\n\n    \nprint\n(\n{0}\n.\nformat\n(\nerror\n))\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n will allow us to receive the current pressure data we want. The \nutils import\n takes care of this as well. We can define a function and expect pressure data to be passed to it.\n\n\ndef\n \npressure_data_callback\n(\ndata\n):\n\n    \n# Extract data\n\n    \ndata\n \n=\n \nsense_pb2\n.\nPressure\n()\n.\nFromString\n(\ndata\n[\n0\n])\n\n    \n# Log data \n\n    \nprint\n(\n{0}\n.\nformat\n(\ndata\n))\n\n\n\n\nData Output\n\nThe Python object below is an example output you'll receive from the \nData Update Port\n.\n\npressure\n:\n \n101268.492188\n\n\naltitude\n:\n \n4.81199979782\n\n\ntemperature\n:\n \n33.625\n\n\n\n\n\n\n\n\n\nStart Processes\nThis is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port.\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \n# Initiate asynchronous events\n\n    \nioloop\n.\ninstall\n()\n\n    \n# Send Base Port configuration \n\n    \nconfig_socket\n()\n\n    \n# Start Error Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_error_callback\n,\n \nargs\n=\n(\npressure_error_callback\n,\n \nmatrix_ip\n,\n \npressure_port\n))\n.\nstart\n()\n\n    \n# Start Data Update Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_data_callback\n,\n \nargs\n=\n(\npressure_data_callback\n,\n \nmatrix_ip\n,\n \npressure_port\n))\n.\nstart\n()\n\n    \n# Start Keep-alive Port connection\n\n    \nProcess\n(\ntarget\n=\ndriver_keep_alive\n,\n \nargs\n=\n(\nmatrix_ip\n,\n \npressure_port\n))\n.\nstart\n()", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-core/python-examples/pressure/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/python-examples/pressure/#overview", 
            "text": "The Pressure driver reports values for:   Pressure  Altitude  Temperature    Based on component location, the temperature values from the  Humidity driver  are recommended over the Pressure driver", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/python-examples/pressure/#code-example", 
            "text": "The following sections show how to implement a connection to each of the Pressure driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. import   os   # Miscellaneous operating system interface  import   zmq   # Asynchronous messaging framework  import   time   # Time access and conversions  import   sys   # System-specific parameters and functions  from   matrix_io.proto.malos.v1   import   driver_pb2   # MATRIX Protocol Buffer driver library  from   matrix_io.proto.malos.v1   import   sense_pb2   # MATRIX Protocol Buffer sensor library  from   multiprocessing   import   Process   # Allow for multiple processes at once  from   zmq.eventloop   import   ioloop   # Asynchronous events through ZMQ  matrix_ip   =   127.0.0.1   # Local device ip  pressure_port   =   20025   # Driver Base port  # Handy functions for connecting to the keep-Alive, Data Update,   Error port   from   utils   import   driver_keep_alive ,   register_data_callback ,   register_error_callback     Base Port Here is where the configuration for our pressure example goes. Once we connect to the  Base Port , we will pass a configuration to the pressure driver. With this we can set the update rate, timeout, and temperature configuration. def   config_socket (): \n     # Define zmq socket \n     context   =   zmq . Context () \n     # Create a Pusher socket \n     socket   =   context . socket ( zmq . PUSH ) \n     # Connect Pusher to configuration socket \n     socket . connect ( tcp://{0}:{1} . format ( matrix_ip ,   pressure_port )) \n\n     # Create a new driver config \n     driver_config_proto   =   driver_pb2 . DriverConfig () \n     # Delay between updates in seconds \n     driver_config_proto . delay_between_updates   =   1.0 \n     # Timeout after last ping \n     driver_config_proto . timeout_after_last_ping   =   6.0 \n\n     # Send driver configuration through ZMQ socket \n     socket . send ( driver_config_proto . SerializeToString ())     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message will grant us a response from the  Data Update Port  for the current pressure value. The  utils import  from the  Initial Variables  section takes care of this.    Error Port The  Error Port  connection is also taken care of by the  utils import . Below we define a function to be called and given any error messages that occur within MATRIX CORE. def   pressure_error_callback ( error ): \n     # Log error \n     print ( {0} . format ( error ))     Data Update Port A connection to the  Data Update Port  will allow us to receive the current pressure data we want. The  utils import  takes care of this as well. We can define a function and expect pressure data to be passed to it.  def   pressure_data_callback ( data ): \n     # Extract data \n     data   =   sense_pb2 . Pressure () . FromString ( data [ 0 ]) \n     # Log data  \n     print ( {0} . format ( data ))", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/python-examples/uv/", 
            "text": "UV\n\n\n\nPython Example\n\n\n\nDevice Compatibility\n\n\n\n\nOverview\n\n\nThe UV driver reports values for:\n\n\n\n\nUV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization.  From \nUV Index Scale\n\n\nUV Risk scale established by World Health Organization. From \nUV Index Scale\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20029\n\n\nKeep-alive port\n: 20030\n\n\nError port\n: 20031\n\n\nData Update port\n: 20032\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the UV driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references.\n\nimport\n \nos\n \n# Miscellaneous operating system interface\n\n\nimport\n \nzmq\n \n# Asynchronous messaging framework\n\n\nimport\n \ntime\n \n# Time access and conversions\n\n\nimport\n \nsys\n \n# System-specific parameters and functions\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \ndriver_pb2\n \n# MATRIX Protocol Buffer driver library\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \nsense_pb2\n \n# MATRIX Protocol Buffer sensor library\n\n\nfrom\n \nmultiprocessing\n \nimport\n \nProcess\n \n# Allow for multiple processes at once\n\n\nfrom\n \nzmq.eventloop\n \nimport\n \nioloop\n \n# Asynchronous events through ZMQ\n\n\nmatrix_ip\n \n=\n \n127.0.0.1\n \n# Local device ip\n\n\nuv_port\n \n=\n \n20029\n \n# Driver Base port\n\n\n# Handy functions for connecting to the keep-Alive, Data Update, \n Error port \n\n\nfrom\n \nutils\n \nimport\n \ndriver_keep_alive\n,\n \nregister_data_callback\n,\n \nregister_error_callback\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our UV example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the UV driver. With this we can set the update rate, timeout, and temperature configuration.\n\ndef\n \nconfig_socket\n():\n\n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Pusher socket\n\n    \nsocket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n    \n# Connect Pusher to configuration socket\n\n    \nsocket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \nuv_port\n))\n\n\n    \n# Create a new driver config\n\n    \ndriver_config_proto\n \n=\n \ndriver_pb2\n.\nDriverConfig\n()\n\n    \n# Delay between updates in seconds\n\n    \ndriver_config_proto\n.\ndelay_between_updates\n \n=\n \n1.0\n\n    \n# Timeout after last ping\n\n    \ndriver_config_proto\n.\ntimeout_after_last_ping\n \n=\n \n6.0\n\n\n    \n# Send driver configuration through ZMQ socket\n\n    \nsocket\n.\nsend\n(\ndriver_config_proto\n.\nSerializeToString\n())\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message will grant us a response from the \nData Update Port\n for the current UV value. The \nutils import\n from the \nInitial Variables\n section takes care of this.\n\n\n\n\n\n\n\nError Port\nThe \nError Port\n connection is also taken care of by the \nutils import\n. Below we define a function to be called and given any error messages that occur within MATRIX CORE.\n\ndef\n \nuv_error_callback\n(\nerror\n):\n\n    \n# Log error\n\n    \nprint\n(\n{0}\n.\nformat\n(\nerror\n))\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n will allow us to receive the current UV data we want. The \nutils import\n takes care of this as well. We can define a function and expect UV data to be passed to it.\n\n\ndef\n \nuv_data_callback\n(\ndata\n):\n\n    \n# Extract data\n\n    \ndata\n \n=\n \nsense_pb2\n.\nUV\n()\n.\nFromString\n(\ndata\n[\n0\n])\n\n    \n# Log data \n\n    \nprint\n(\n{0}\n.\nformat\n(\ndata\n))\n\n\n\n\nData Output\n\nThe Python object below is an example output you'll receive from the \nData Update Port\n.\n\nuv_index\n:\n \n0.00600000005215\n\n\noms_risk\n:\n \nLow\n\n\n\n\n\n\n\n\n\nStart Processes\nThis is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port.\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \n# Initiate asynchronous events\n\n    \nioloop\n.\ninstall\n()\n\n    \n# Send Base Port configuration \n\n    \nconfig_socket\n()\n\n    \n# Start Error Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_error_callback\n,\n \nargs\n=\n(\nuv_error_callback\n,\n \nmatrix_ip\n,\n \nuv_port\n))\n.\nstart\n()\n\n    \n# Start Data Update Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_data_callback\n,\n \nargs\n=\n(\nuv_data_callback\n,\n \nmatrix_ip\n,\n \nuv_port\n))\n.\nstart\n()\n\n    \n# Start Keep-alive Port connection\n\n    \nProcess\n(\ntarget\n=\ndriver_keep_alive\n,\n \nargs\n=\n(\nmatrix_ip\n,\n \nuv_port\n))\n.\nstart\n()", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-core/python-examples/uv/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/python-examples/uv/#overview", 
            "text": "The UV driver reports values for:   UV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization.  From  UV Index Scale  UV Risk scale established by World Health Organization. From  UV Index Scale", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/python-examples/uv/#code-example", 
            "text": "The following sections show how to implement a connection to each of the UV driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. import   os   # Miscellaneous operating system interface  import   zmq   # Asynchronous messaging framework  import   time   # Time access and conversions  import   sys   # System-specific parameters and functions  from   matrix_io.proto.malos.v1   import   driver_pb2   # MATRIX Protocol Buffer driver library  from   matrix_io.proto.malos.v1   import   sense_pb2   # MATRIX Protocol Buffer sensor library  from   multiprocessing   import   Process   # Allow for multiple processes at once  from   zmq.eventloop   import   ioloop   # Asynchronous events through ZMQ  matrix_ip   =   127.0.0.1   # Local device ip  uv_port   =   20029   # Driver Base port  # Handy functions for connecting to the keep-Alive, Data Update,   Error port   from   utils   import   driver_keep_alive ,   register_data_callback ,   register_error_callback     Base Port Here is where the configuration for our UV example goes. Once we connect to the  Base Port , we will pass a configuration to the UV driver. With this we can set the update rate, timeout, and temperature configuration. def   config_socket (): \n     # Define zmq socket \n     context   =   zmq . Context () \n     # Create a Pusher socket \n     socket   =   context . socket ( zmq . PUSH ) \n     # Connect Pusher to configuration socket \n     socket . connect ( tcp://{0}:{1} . format ( matrix_ip ,   uv_port )) \n\n     # Create a new driver config \n     driver_config_proto   =   driver_pb2 . DriverConfig () \n     # Delay between updates in seconds \n     driver_config_proto . delay_between_updates   =   1.0 \n     # Timeout after last ping \n     driver_config_proto . timeout_after_last_ping   =   6.0 \n\n     # Send driver configuration through ZMQ socket \n     socket . send ( driver_config_proto . SerializeToString ())     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message will grant us a response from the  Data Update Port  for the current UV value. The  utils import  from the  Initial Variables  section takes care of this.    Error Port The  Error Port  connection is also taken care of by the  utils import . Below we define a function to be called and given any error messages that occur within MATRIX CORE. def   uv_error_callback ( error ): \n     # Log error \n     print ( {0} . format ( error ))     Data Update Port A connection to the  Data Update Port  will allow us to receive the current UV data we want. The  utils import  takes care of this as well. We can define a function and expect UV data to be passed to it.  def   uv_data_callback ( data ): \n     # Extract data \n     data   =   sense_pb2 . UV () . FromString ( data [ 0 ]) \n     # Log data  \n     print ( {0} . format ( data ))", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/python-examples/servo/", 
            "text": "Servo\n\n\n\nPython Example\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe Servo driver can set the angle of your servos through the pins of your MATRIX device.\n\n\nDevice Pinouts\n:\n\n\n\n\nMATRIX Creator\n\n\nMATRIX Voice\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20045\n\n\nError port\n: 20047\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the Servo driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references.\n\nimport\n \nos\n \n# Miscellaneous operating system interface\n\n\nimport\n \nzmq\n \n# Asynchronous messaging framework\n\n\nimport\n \ntime\n \n# Time access and conversions\n\n\nimport\n \nsys\n \n# System-specific parameters and functions\n\n\nimport\n \nrandom\n \n# Generate pseudo-random numbers\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \ndriver_pb2\n \n# MATRIX Protocol Buffer driver library\n\n\nfrom\n \nmultiprocessing\n \nimport\n \nProcess\n \n# Allow for multiple processes at once\n\n\nfrom\n \nzmq.eventloop\n \nimport\n \nioloop\n \n# Asynchronous events through ZMQ\n\n\nmatrix_ip\n \n=\n \n127.0.0.1\n \n# Local device ip\n\n\nservo_port\n \n=\n \n20045\n \n# Driver Base port\n\n\n# Handy function for connecting to the Error port \n\n\nfrom\n \nutils\n \nimport\n \nregister_error_callback\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our servo example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the servo driver. With this we can choose the pin we want to edit and the angle to set for it. This example will send random numbers to any servo attached to pin 0. This example has a \nmoveServo()\n function that calls itself to send random angles to your servo.\n\n\ndef\n \nsend_servo_command\n(\npin\n):\n\n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Pusher socket\n\n    \nsocket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n    \n# Connect Pusher to configuration socket\n\n    \nsocket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \nservo_port\n))\n\n\n    \n# Create a new driver config\n\n    \nservo_config\n \n=\n \ndriver_pb2\n.\nDriverConfig\n()\n\n    \n# Set a pin that the servo will operate on\n\n    \nservo_config\n.\nservo\n.\npin\n \n=\n \npin\n\n\n    \n# Function to change servo angle\n\n    \ndef\n \nmoveServo\n(\nangle\n):\n\n        \n# Log angle\n\n        \nprint\n(\nAngle: {0}\n.\nformat\n(\nangle\n))\n\n        \n# Set the servo\ns angle in the config\n\n        \nservo_config\n.\nservo\n.\nangle\n \n=\n \nangle\n\n        \n# Serialize the config and send it to the driver\n\n        \nsocket\n.\nsend\n(\nservo_config\n.\nSerializeToString\n())\n\n        \n# Wait for 1 second\n\n        \ntime\n.\nsleep\n(\n1\n)\n\n        \n# Run function again with random angle\n\n        \nmoveServo\n(\nrandom\n.\nrandint\n(\n0\n,\n \n180\n))\n\n\n    \n# Initial moveServo call\n\n    \nmoveServo\n(\n180\n)\n\n\n\n\n\n\n\n\n\n\nError Port\nThe \nError Port\n connection is taken care of by the \nutils import\n. Below we define a function to be called and given any error messages that occur within MATRIX CORE.\n\ndef\n \nservo_error_callback\n(\nerror\n):\n\n    \n# Log error\n\n    \nprint\n(\n{0}\n.\nformat\n(\nerror\n))\n\n\n\n\n\n\n\n\n\nStart Processes\nThis is where we begin the asynchronous events for each of the driver ports used and where we define the functions we want to use for each port.\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \n# Initiate asynchronous events\n\n    \nioloop\n.\ninstall\n()\n\n    \n# Start Error Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_error_callback\n,\n \nargs\n=\n(\nservo_error_callback\n,\n \nmatrix_ip\n,\n \nservo_port\n))\n.\nstart\n()\n\n    \n# Send Base Port configuration \n\n    \ntry\n:\n\n        \nsend_servo_command\n(\n0\n)\n\n    \n# Avoid logging servo angle errors on user quiting\n\n    \nexcept\n \nKeyboardInterrupt\n:\n\n        \nprint\n(\n quit\n)", 
            "title": "Servo"
        }, 
        {
            "location": "/matrix-core/python-examples/servo/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/python-examples/servo/#overview", 
            "text": "The Servo driver can set the angle of your servos through the pins of your MATRIX device.  Device Pinouts :   MATRIX Creator  MATRIX Voice", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/python-examples/servo/#code-example", 
            "text": "The following sections show how to implement a connection to each of the Servo driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. import   os   # Miscellaneous operating system interface  import   zmq   # Asynchronous messaging framework  import   time   # Time access and conversions  import   sys   # System-specific parameters and functions  import   random   # Generate pseudo-random numbers  from   matrix_io.proto.malos.v1   import   driver_pb2   # MATRIX Protocol Buffer driver library  from   multiprocessing   import   Process   # Allow for multiple processes at once  from   zmq.eventloop   import   ioloop   # Asynchronous events through ZMQ  matrix_ip   =   127.0.0.1   # Local device ip  servo_port   =   20045   # Driver Base port  # Handy function for connecting to the Error port   from   utils   import   register_error_callback     Base Port Here is where the configuration for our servo example goes. Once we connect to the  Base Port , we will pass a configuration to the servo driver. With this we can choose the pin we want to edit and the angle to set for it. This example will send random numbers to any servo attached to pin 0. This example has a  moveServo()  function that calls itself to send random angles to your servo.  def   send_servo_command ( pin ): \n     # Define zmq socket \n     context   =   zmq . Context () \n     # Create a Pusher socket \n     socket   =   context . socket ( zmq . PUSH ) \n     # Connect Pusher to configuration socket \n     socket . connect ( tcp://{0}:{1} . format ( matrix_ip ,   servo_port )) \n\n     # Create a new driver config \n     servo_config   =   driver_pb2 . DriverConfig () \n     # Set a pin that the servo will operate on \n     servo_config . servo . pin   =   pin \n\n     # Function to change servo angle \n     def   moveServo ( angle ): \n         # Log angle \n         print ( Angle: {0} . format ( angle )) \n         # Set the servo s angle in the config \n         servo_config . servo . angle   =   angle \n         # Serialize the config and send it to the driver \n         socket . send ( servo_config . SerializeToString ()) \n         # Wait for 1 second \n         time . sleep ( 1 ) \n         # Run function again with random angle \n         moveServo ( random . randint ( 0 ,   180 )) \n\n     # Initial moveServo call \n     moveServo ( 180 )     Error Port The  Error Port  connection is taken care of by the  utils import . Below we define a function to be called and given any error messages that occur within MATRIX CORE. def   servo_error_callback ( error ): \n     # Log error \n     print ( {0} . format ( error ))     Start Processes This is where we begin the asynchronous events for each of the driver ports used and where we define the functions we want to use for each port.  if   __name__   ==   __main__ : \n     # Initiate asynchronous events \n     ioloop . install () \n     # Start Error Port connection \n     Process ( target = register_error_callback ,   args = ( servo_error_callback ,   matrix_ip ,   servo_port )) . start () \n     # Send Base Port configuration  \n     try : \n         send_servo_command ( 0 ) \n     # Avoid logging servo angle errors on user quiting \n     except   KeyboardInterrupt : \n         print (  quit )", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/python-examples/gpio/", 
            "text": "General Purpose Input Output (GPIO)\n\n\n\nPython Example\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe GPIO driver supports:\n\n\n\n\nReading pin input\n\n\nSetting pin output\n\n\n\n\nDevice Pinouts\n:\n\n\n\n\nMATRIX Creator\n\n\nMATRIX Voice\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 20049\n\n\nKeep-alive port\n: 20050\n\n\nError port\n: 20051\n\n\nData Update port\n: 20052\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the GPIO driver's ports. You can download this example \nhere\n.\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references.\n\nimport\n \nos\n \n# Miscellaneous operating system interface\n\n\nimport\n \nzmq\n \n# Asynchronous messaging framework\n\n\nimport\n \ntime\n \n# Time access and conversions\n\n\nimport\n \nsys\n \n# System-specific parameters and functions\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \ndriver_pb2\n \n# MATRIX Protocol Buffer driver library\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \nio_pb2\n \n# MATRIX Protocol Buffer sensor library\n\n\nfrom\n \nmultiprocessing\n \nimport\n \nProcess\n \n# Allow for multiple processes at once\n\n\nfrom\n \nzmq.eventloop\n \nimport\n \nioloop\n \n# Asynchronous events through ZMQ\n\n\nmatrix_ip\n \n=\n \n127.0.0.1\n \n# Local device ip\n\n\ngpio_port\n \n=\n \n20049\n \n# Driver Base port\n\n\n# Handy functions for connecting to the keep-Alive, Data Update, \n Error port \n\n\nfrom\n \nutils\n \nimport\n \ndriver_keep_alive\n,\n \nregister_data_callback\n,\n \nregister_error_callback\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our GPIO example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the GPIO driver. With this, we can set the update rate, timeout, and pin configuration. This example will use \npin: 0\n and \ntoggle the pin state between on\noff\n through a \ntoggle()\n function.\n\n\n\n\nEach \npin\n will save its last set \nvalue\n until the next device boot.\n\n\n\n\n# Define zmq socket\n\n\ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n\n# Create a Pusher socket\n\n\nsocket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n\n# Connect Pusher to configuration socket\n\n\nsocket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \ngpio_port\n))\n\n\n\n# Configure GPIO update rates and timeout\n\n\ndef\n \nconfig_gpio_read\n():\n\n    \n# Create a new driver config\n\n    \nconfig\n \n=\n \ndriver_pb2\n.\nDriverConfig\n()\n\n    \n# Delay between updates in seconds\n\n    \nconfig\n.\ndelay_between_updates\n \n=\n \n2.0\n\n    \n# Timeout after last ping\n\n    \nconfig\n.\ntimeout_after_last_ping\n \n=\n \n3.5\n\n    \n# Send driver configuration through ZMQ socket\n\n    \nsocket\n.\nsend\n(\nconfig\n.\nSerializeToString\n())\n\n\n\n# Recursive function to toggle pin state\n\n\ndef\n \nconfig_gpio_write\n(\npin\n,\n \nvalue\n):\n\n    \n# Create a new driver config\n\n    \nconfig\n \n=\n \ndriver_pb2\n.\nDriverConfig\n()\n\n    \n# set desired pin\n\n    \nconfig\n.\ngpio\n.\npin\n \n=\n \npin\n\n    \n# Set pin mode to output\n\n    \nconfig\n.\ngpio\n.\nmode\n \n=\n \nio_pb2\n.\nGpioParams\n.\nOUTPUT\n\n    \n# Set the output of the pin initially\n\n    \nconfig\n.\ngpio\n.\nvalue\n \n=\n \nvalue\n%\n2\n\n    \n# Send driver configuration through ZMQ socket\n\n    \nsocket\n.\nsend\n(\nconfig\n.\nSerializeToString\n())\n\n\n    \n# Wait 2 seconds\n\n    \ntime\n.\nsleep\n(\n2\n)\n\n    \n# Increase value and run again\n\n    \nvalue\n \n+=\n \n1\n\n    \nconfig_gpio_write\n(\n0\n,\n \nvalue\n%\n2\n)\n\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message will grant us a response from the \nData Update Port\n for the current GPIO values. The \nutils import\n from the \nInitial Variables\n section takes care of this.\n\n\n\n\n\n\n\nError Port\nThe \nError Port\n connection is also taken care of by the \nutils import\n. Below we define a function to be called and given any error messages that occur within MATRIX CORE.\n\ndef\n \ngpio_error_callback\n(\nerror\n):\n\n    \n# Log error\n\n    \nprint\n(\n{0}\n.\nformat\n(\nerror\n))\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n is then made to allow us to receive the current IMU data we want. The message received from the GPIO driver is converted into a 16 bit array, named \ngpioValues\n that represents each pin on your MATRIX device.\n\n\ndef\n \ngpio_callback\n(\nmsg\n):\n\n    \n# Extract data\n\n    \ndata\n \n=\n \nio_pb2\n.\nGpioParams\n()\n.\nFromString\n(\nmsg\n[\n0\n])\n\n    \n# Convert GPIO values to 16-bit\n\n    \ngpioValues\n \n=\n \n(\n{0:016b}\n.\nformat\n(\ndata\n.\nvalues\n))\n\n    \n# Reverse string for chronological order\n\n    \ngpioValues\n \n=\n \ngpioValues\n[::\n-\n1\n]\n\n    \n# Convert string into an array\n\n    \ngpioValues\n \n=\n \nlist\n(\ngpioValues\n)\n\n    \n# Log GPIO pin states from gpioValues[0-15]\n\n    \nprint\n(\nGPIO PINS--\n[0-15]\n\\n\n{0}\n.\nformat\n(\ngpioValues\n))\n\n\n\n\nData Output\n\nThe Python object below is an example output you'll receive from the \nData Update Port\n. For readability, the code above has converted the output as a 16-bit value and turned it into an array.\n\nvalues\n:\n \n513\n\n\n\n\n\n\n\n\n\nStart Processes\nThis is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port.\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \n# Initiate asynchronous events\n\n    \nioloop\n.\ninstall\n()\n\n    \n# Start Error Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_error_callback\n,\n \nargs\n=\n(\ngpio_error_callback\n,\n \nmatrix_ip\n,\n \ngpio_port\n))\n.\nstart\n()\n\n    \n# Start Keep-alive Port connection\n\n    \nProcess\n(\ntarget\n=\ndriver_keep_alive\n,\n \nargs\n=\n(\nmatrix_ip\n,\n \ngpio_port\n,\n \n1\n))\n.\nstart\n()\n\n    \n# Start Data Update Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_data_callback\n,\n \nargs\n=\n(\ngpio_callback\n,\n \nmatrix_ip\n,\n \ngpio_port\n))\n.\nstart\n()\n\n    \n# Send Base Port configurations\n\n    \ntry\n:\n\n        \n# Configure GPIO update and timeout\n\n        \nconfig_gpio_read\n()\n\n        \n# Toggle state of selected pin, start with pin on\n\n        \nconfig_gpio_write\n(\n0\n,\n \n1\n)\n\n    \n# Avoid logging GPIO errors on user quiting\n\n    \nexcept\n \nKeyboardInterrupt\n:\n\n        \nprint\n(\nquit\n)", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-core/python-examples/gpio/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/python-examples/gpio/#overview", 
            "text": "The GPIO driver supports:   Reading pin input  Setting pin output   Device Pinouts :   MATRIX Creator  MATRIX Voice", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/python-examples/gpio/#code-example", 
            "text": "The following sections show how to implement a connection to each of the GPIO driver's ports. You can download this example  here .   Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. import   os   # Miscellaneous operating system interface  import   zmq   # Asynchronous messaging framework  import   time   # Time access and conversions  import   sys   # System-specific parameters and functions  from   matrix_io.proto.malos.v1   import   driver_pb2   # MATRIX Protocol Buffer driver library  from   matrix_io.proto.malos.v1   import   io_pb2   # MATRIX Protocol Buffer sensor library  from   multiprocessing   import   Process   # Allow for multiple processes at once  from   zmq.eventloop   import   ioloop   # Asynchronous events through ZMQ  matrix_ip   =   127.0.0.1   # Local device ip  gpio_port   =   20049   # Driver Base port  # Handy functions for connecting to the keep-Alive, Data Update,   Error port   from   utils   import   driver_keep_alive ,   register_data_callback ,   register_error_callback     Base Port Here is where the configuration for our GPIO example goes. Once we connect to the  Base Port , we will pass a configuration to the GPIO driver. With this, we can set the update rate, timeout, and pin configuration. This example will use  pin: 0  and  toggle the pin state between on off  through a  toggle()  function.   Each  pin  will save its last set  value  until the next device boot.   # Define zmq socket  context   =   zmq . Context ()  # Create a Pusher socket  socket   =   context . socket ( zmq . PUSH )  # Connect Pusher to configuration socket  socket . connect ( tcp://{0}:{1} . format ( matrix_ip ,   gpio_port ))  # Configure GPIO update rates and timeout  def   config_gpio_read (): \n     # Create a new driver config \n     config   =   driver_pb2 . DriverConfig () \n     # Delay between updates in seconds \n     config . delay_between_updates   =   2.0 \n     # Timeout after last ping \n     config . timeout_after_last_ping   =   3.5 \n     # Send driver configuration through ZMQ socket \n     socket . send ( config . SerializeToString ())  # Recursive function to toggle pin state  def   config_gpio_write ( pin ,   value ): \n     # Create a new driver config \n     config   =   driver_pb2 . DriverConfig () \n     # set desired pin \n     config . gpio . pin   =   pin \n     # Set pin mode to output \n     config . gpio . mode   =   io_pb2 . GpioParams . OUTPUT \n     # Set the output of the pin initially \n     config . gpio . value   =   value % 2 \n     # Send driver configuration through ZMQ socket \n     socket . send ( config . SerializeToString ()) \n\n     # Wait 2 seconds \n     time . sleep ( 2 ) \n     # Increase value and run again \n     value   +=   1 \n     config_gpio_write ( 0 ,   value % 2 )     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message will grant us a response from the  Data Update Port  for the current GPIO values. The  utils import  from the  Initial Variables  section takes care of this.    Error Port The  Error Port  connection is also taken care of by the  utils import . Below we define a function to be called and given any error messages that occur within MATRIX CORE. def   gpio_error_callback ( error ): \n     # Log error \n     print ( {0} . format ( error ))     Data Update Port A connection to the  Data Update Port  is then made to allow us to receive the current IMU data we want. The message received from the GPIO driver is converted into a 16 bit array, named  gpioValues  that represents each pin on your MATRIX device.  def   gpio_callback ( msg ): \n     # Extract data \n     data   =   io_pb2 . GpioParams () . FromString ( msg [ 0 ]) \n     # Convert GPIO values to 16-bit \n     gpioValues   =   ( {0:016b} . format ( data . values )) \n     # Reverse string for chronological order \n     gpioValues   =   gpioValues [:: - 1 ] \n     # Convert string into an array \n     gpioValues   =   list ( gpioValues ) \n     # Log GPIO pin states from gpioValues[0-15] \n     print ( GPIO PINS-- [0-15] \\n {0} . format ( gpioValues ))", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/python-examples/wakeword/", 
            "text": "Wakeword\n\n\n\nPython Example\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nOverview\n\n\nThe Wakeword driver allows for:\n\n\n\n\nReading custom wakewords created with \nSphinx Knowledge Base\n.\n\n\nNotifications on which wakewords are heard.\n\n\n\n\nAvailable ZeroMQ Ports\n\n\n\n\n\nBase port\n: 60001\n\n\nError port\n: 60003\n\n\nData update port\n: 60004\n\n\n\n\nCode Example\n\n\nThe following sections show how to implement a connection to each of the IMU driver's ports. You can download this example \nhere\n.\n\n\n\n\n\n\n\nBefore moving on, please take a look at the Wakeword driver's protocol page and follow the \nInstallation\n \n \nCreating Custom Phrases\n sections.\n\n\n\n\n\n\n\nInitial Variables\nBefore we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables and the path for our \nSphinx Knowledge Base\n files.\n\nimport\n \nos\n \n# Miscellaneous operating system interface\n\n\nimport\n \nzmq\n \n# Asynchronous messaging framework\n\n\nimport\n \ntime\n \n# Time access and conversions\n\n\nimport\n \nsys\n \n# System-specific parameters and functions\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \ndriver_pb2\n \n# MATRIX Protocol Buffer driver library\n\n\nfrom\n \nmatrix_io.proto.malos.v1\n \nimport\n \nio_pb2\n \n# MATRIX Protocol Buffer io library\n\n\nfrom\n \nmultiprocessing\n \nimport\n \nProcess\n \n# Allow for multiple processes at once\n\n\nfrom\n \nzmq.eventloop\n \nimport\n \nioloop\n \n# Asynchronous events through ZMQ\n\n\nmatrix_ip\n \n=\n \n127.0.0.1\n \n# Local device ip\n\n\nwakeword_port\n \n=\n \n60001\n \n# Driver Base port\n\n\n# Handy functions for connecting to the Data Update, \n Error port \n\n\nfrom\n \nutils\n \nimport\n \nregister_data_callback\n,\n \nregister_error_callback\n\n\n# Sphinx Knowledge Base files\n\n\nLM_PATH\n \n=\n \nINSERT_PATH_TO_YOUR_FILE.lm\n# Language Model File\n\n\nDIC_PATH\n \n=\n \nINSERT_PATH_TO_YOUR_FILE.dic\n# Dictation File\n\n\n\n\n\n\n\n\n\nBase Port\nHere is where the configuration for our wakeword example goes. Once we connect to the \nBase Port\n, we will pass a configuration to the Wakeword driver. With this we can set our wakeword configurations.\n\ndef\n \nconfig_socket\n():\n\n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Pusher socket\n\n    \nsocket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n    \n# Connect Pusher to configuration socket\n\n    \nsocket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \nwakeword_port\n))\n\n\n    \n# Create a new driver config\n\n    \nconfig\n \n=\n \ndriver_pb2\n.\nDriverConfig\n()\n\n    \n# Language Model File\n\n    \nconfig\n.\nwakeword\n.\nlm_path\n \n=\n \nLM_PATH\n\n    \n# Dictation File\n\n    \nconfig\n.\nwakeword\n.\ndic_path\n \n=\n \nDIC_PATH\n\n    \n# Desired MATRIX microphone\n\n    \nconfig\n.\nwakeword\n.\nchannel\n \n=\n \n8\n\n    \n# Enable verbose option\n\n    \nconfig\n.\nwakeword\n.\nenable_verbose\n \n=\n \nFalse\n\n\n    \n# Send driver configuration through ZMQ socket\n\n    \nsocket\n.\nsend\n(\nconfig\n.\nSerializeToString\n())\n\n    \nprint\n \n(\nListening for wakewords\n)\n\n\n\n\n\n\n\n\n\nKeep-alive Port\nThe next step is to connect and send a message to the \nKeep-alive Port\n. That message will grant us a response from the Data Update Port with the wake words that were understood.\n\ndef\n \nping_socket\n():\n\n    \n# Define zmq socket\n\n    \ncontext\n \n=\n \nzmq\n.\nContext\n()\n\n    \n# Create a Pusher socket\n\n    \nping_socket\n \n=\n \ncontext\n.\nsocket\n(\nzmq\n.\nPUSH\n)\n\n    \n# Connect to the socket\n\n    \nping_socket\n.\nconnect\n(\ntcp://{0}:{1}\n.\nformat\n(\nmatrix_ip\n,\n \nwakeword_port\n+\n1\n))\n\n    \n# Send a ping every 2 seconds\n\n    \nwhile\n \nTrue\n:\n\n        \nping_socket\n.\nsend_string\n(\n)\n\n        \ntime\n.\nsleep\n(\n2\n)\n\n\n\n\n\n\n\n\n\nError Port\nThe \nError Port\n connection is also taken care of by the \nutils import\n. Below we define a function to be called and given any error messages that occur within MATRIX CORE.\n\n\n\n\nThe Error Port is currently reporting false errors. \n\ndef\n \nwakeword_error_callback\n(\nerror\n):\n\n    \n# Log error\n\n    \nprint\n(\n{0}\n.\nformat\n(\nerror\n))\n\n\n\n\n\n\n\n\n\n\n\nData Update Port\nA connection to the \nData Update Port\n is then made to allow us to receive each custom phrase the Wakeword driver picks up.\n\n\ndef\n \nwakeword_data_callback\n(\ndata\n):\n\n    \n# Extract data\n\n    \ndata\n \n=\n \nio_pb2\n.\nWakeWordParams\n()\n.\nFromString\n(\ndata\n[\n0\n])\n\n    \n# Log data \n\n    \nprint\n(\n{0}\n.\nformat\n(\ndata\n))\n\n    \n# Run actions based on the phrase heard\n\n    \n# CHANGE TO YOUR PHRASE\n\n    \nif\n \ndata\n.\nwake_word\n \n==\n \nMATRIX START\n:\n\n        \nprint\n \n(\nI HEARD MATRIX START!\n\\n\n)\n\n    \n# CHANGE TO YOUR PHRASE\n\n    \nelif\n \ndata\n.\nwake_word\n \n==\n \nMATRIX STOP\n:\n\n        \nprint\n \n(\nI HEARD MATRIX STOP!\n\\n\n)\n\n\n\n\nData Output\n\nThe Python object below is an example output you'll receive from the \nData Update Port\n. All wakeword strings are capitalized.\n\nwake_word\n:\n \nMATRIX START\n\n\n\n\n\n\n\n\n\nStart Processes\nThis is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port.\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \n# Initiate asynchronous events\n\n    \nioloop\n.\ninstall\n()\n\n    \n# Send Base Port configuration \n\n    \nconfig_socket\n()\n\n    \n# Start Error Port connection\n\n    \n# Process(target=register_error_callback, args=(wakeword_error_callback, matrix_ip, wakeword_port)).start()\n\n    \n# Start Data Update Port connection\n\n    \nProcess\n(\ntarget\n=\nregister_data_callback\n,\n \nargs\n=\n(\nwakeword_data_callback\n,\n \nmatrix_ip\n,\n \nwakeword_port\n))\n.\nstart\n()\n\n    \n# Start Keep-alive Port connection\n\n    \nProcess\n(\ntarget\n=\nping_socket\n)\n.\nstart\n()", 
            "title": "Wakeword"
        }, 
        {
            "location": "/matrix-core/python-examples/wakeword/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-core/python-examples/wakeword/#overview", 
            "text": "The Wakeword driver allows for:   Reading custom wakewords created with  Sphinx Knowledge Base .  Notifications on which wakewords are heard.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-core/python-examples/wakeword/#code-example", 
            "text": "The following sections show how to implement a connection to each of the IMU driver's ports. You can download this example  here .    Before moving on, please take a look at the Wakeword driver's protocol page and follow the  Installation     Creating Custom Phrases  sections.    Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables and the path for our  Sphinx Knowledge Base  files. import   os   # Miscellaneous operating system interface  import   zmq   # Asynchronous messaging framework  import   time   # Time access and conversions  import   sys   # System-specific parameters and functions  from   matrix_io.proto.malos.v1   import   driver_pb2   # MATRIX Protocol Buffer driver library  from   matrix_io.proto.malos.v1   import   io_pb2   # MATRIX Protocol Buffer io library  from   multiprocessing   import   Process   # Allow for multiple processes at once  from   zmq.eventloop   import   ioloop   # Asynchronous events through ZMQ  matrix_ip   =   127.0.0.1   # Local device ip  wakeword_port   =   60001   # Driver Base port  # Handy functions for connecting to the Data Update,   Error port   from   utils   import   register_data_callback ,   register_error_callback  # Sphinx Knowledge Base files  LM_PATH   =   INSERT_PATH_TO_YOUR_FILE.lm # Language Model File  DIC_PATH   =   INSERT_PATH_TO_YOUR_FILE.dic # Dictation File     Base Port Here is where the configuration for our wakeword example goes. Once we connect to the  Base Port , we will pass a configuration to the Wakeword driver. With this we can set our wakeword configurations. def   config_socket (): \n     # Define zmq socket \n     context   =   zmq . Context () \n     # Create a Pusher socket \n     socket   =   context . socket ( zmq . PUSH ) \n     # Connect Pusher to configuration socket \n     socket . connect ( tcp://{0}:{1} . format ( matrix_ip ,   wakeword_port )) \n\n     # Create a new driver config \n     config   =   driver_pb2 . DriverConfig () \n     # Language Model File \n     config . wakeword . lm_path   =   LM_PATH \n     # Dictation File \n     config . wakeword . dic_path   =   DIC_PATH \n     # Desired MATRIX microphone \n     config . wakeword . channel   =   8 \n     # Enable verbose option \n     config . wakeword . enable_verbose   =   False \n\n     # Send driver configuration through ZMQ socket \n     socket . send ( config . SerializeToString ()) \n     print   ( Listening for wakewords )     Keep-alive Port The next step is to connect and send a message to the  Keep-alive Port . That message will grant us a response from the Data Update Port with the wake words that were understood. def   ping_socket (): \n     # Define zmq socket \n     context   =   zmq . Context () \n     # Create a Pusher socket \n     ping_socket   =   context . socket ( zmq . PUSH ) \n     # Connect to the socket \n     ping_socket . connect ( tcp://{0}:{1} . format ( matrix_ip ,   wakeword_port + 1 )) \n     # Send a ping every 2 seconds \n     while   True : \n         ping_socket . send_string ( ) \n         time . sleep ( 2 )     Error Port The  Error Port  connection is also taken care of by the  utils import . Below we define a function to be called and given any error messages that occur within MATRIX CORE.   The Error Port is currently reporting false errors.  def   wakeword_error_callback ( error ): \n     # Log error \n     print ( {0} . format ( error ))      Data Update Port A connection to the  Data Update Port  is then made to allow us to receive each custom phrase the Wakeword driver picks up.  def   wakeword_data_callback ( data ): \n     # Extract data \n     data   =   io_pb2 . WakeWordParams () . FromString ( data [ 0 ]) \n     # Log data  \n     print ( {0} . format ( data )) \n     # Run actions based on the phrase heard \n     # CHANGE TO YOUR PHRASE \n     if   data . wake_word   ==   MATRIX START : \n         print   ( I HEARD MATRIX START! \\n ) \n     # CHANGE TO YOUR PHRASE \n     elif   data . wake_word   ==   MATRIX STOP : \n         print   ( I HEARD MATRIX STOP! \\n )", 
            "title": "Code Example"
        }, 
        {
            "location": "/matrix-core/troubleshooting/", 
            "text": "Community\n\n\nPlease visit our community support forums at\n\ncommunity.matrix.one\n\n\nCheck Active MATRIX CORE Services\n\n\nRun the following command on your Raspberry Pi's terminal to see the MATRIX Services currently running.\n\nps aux \n|\n grep \nmalos\n\n\n\n\nReinstall MATRIX CORE\n\n\nIf you experience strange behavior, reinstall MATRIX CORE.\n\n\nUninstall the \nmatrixio-malos\n package.\n\n\nsudo apt-get --purge remove matrixio-malos\n\n\n\n\nReboot your device.\n\n\nsudo reboot\n\n\n\n\nInstall MATRIX CORE \nhere\n.\n\n\nAudio Open Error\n\n\nIf you encounter the error log below, your microphones are being used by the Pocketsphinx service for the \nWakeword Driver\n.\n\narecord\n:\n \nmain\n:\n788\n:\n \naudio\n \nopen\n \nerror\n:\n \nDevice\n \nor\n \nresource\n \nbusy\n\n\n\nYou can solve this by running the following command to kill the service.\n\nsudo pkill malos_wakeword", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#community", 
            "text": "Please visit our community support forums at community.matrix.one", 
            "title": "Community"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#check-active-matrix-core-services", 
            "text": "Run the following command on your Raspberry Pi's terminal to see the MATRIX Services currently running. ps aux  |  grep  malos", 
            "title": "Check Active MATRIX CORE Services"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#reinstall-matrix-core", 
            "text": "If you experience strange behavior, reinstall MATRIX CORE.  Uninstall the  matrixio-malos  package.  sudo apt-get --purge remove matrixio-malos  Reboot your device.  sudo reboot  Install MATRIX CORE  here .", 
            "title": "Reinstall MATRIX CORE"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#audio-open-error", 
            "text": "If you encounter the error log below, your microphones are being used by the Pocketsphinx service for the  Wakeword Driver . arecord :   main : 788 :   audio   open   error :   Device   or   resource   busy  \nYou can solve this by running the following command to kill the service. sudo pkill malos_wakeword", 
            "title": "Audio Open Error"
        }
    ]
}